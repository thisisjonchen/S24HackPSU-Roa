{"ast":null,"code":"/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, util } from '@tensorflow/tfjs-core';\nexport function sparseSegmentReductionImpl(input, inputShape, inputDType, indices, segmentIds, isMean = false, defaultValue = 0) {\n  const numIndices = indices.length;\n  // Flatten the array to two dimensions\n  const inputFlat = [inputShape[0], input.length / inputShape[0]];\n  const numCol = inputFlat[1];\n  // Note that the current implementation assumes that segmentIds values are\n  // sorted.\n  const lastSegmentIdPlusOne = numIndices > 0 ? segmentIds[numIndices - 1] + 1 : 0;\n  const outputRows = lastSegmentIdPlusOne;\n  if (outputRows < 0) {\n    throw new Error(backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());\n  }\n  const outputShape = inputShape.slice();\n  outputShape[0] = outputRows;\n  const outputLength = outputShape.reduce((product, value) => product * value, 1);\n  // Output array is initialized with the value 0 by default.\n  const output = util.getArrayFromDType(inputDType, outputLength);\n  // Note that we do not initialize the output buffer with a default value, so\n  // we need to explicitly set missing indices to the default value.\n  if (numIndices === 0) {\n    if (outputRows > 0) {\n      output.fill(defaultValue);\n    }\n    return [output, outputShape];\n  }\n  if (outputRows <= 0) {\n    throw new Error(backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());\n  }\n  let start = 0,\n    end = 1;\n  // Index from which the output is not initialized.\n  let uninitializedIndex = 0;\n  let outIndex = segmentIds[start];\n  while (true) {\n    // We initialize nextIndex to 0 to avoid may be uninitialized warning\n    let nextIndex = 0;\n    if (end < numIndices) {\n      nextIndex = segmentIds[end];\n      if (outIndex === nextIndex) {\n        ++end;\n        continue;\n      }\n      // We have a new segment here.  Verify that the segment ids are growing.\n      if (outIndex >= nextIndex) {\n        throw new Error(backend_util.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage());\n      }\n    }\n    if (outIndex < 0 || outIndex >= outputRows) {\n      throw new Error(backend_util.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(outIndex, outputRows));\n    }\n    // If there is a gap between two indices, we need to set that gap to the\n    // default value.\n    if (outIndex > uninitializedIndex) {\n      output.fill(defaultValue, uninitializedIndex * numCol, outIndex * numCol);\n    }\n    for (let i = start; i < end; ++i) {\n      const index = indices[i];\n      if (index < 0 || index >= inputFlat[0]) {\n        throw new Error(backend_util.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(i, indices[i], inputFlat[0]));\n      }\n      for (let j = 0; j < numCol; j++) {\n        output[outIndex * numCol + j] += input[index * numCol + j];\n      }\n    }\n    if (isMean) {\n      for (let j = 0; j < numCol; j++) {\n        output[outIndex * numCol + j] /= end - start;\n      }\n    }\n    start = end;\n    ++end;\n    uninitializedIndex = outIndex + 1;\n    outIndex = nextIndex;\n    if (end > numIndices) {\n      break;\n    }\n  }\n  // Fill the gap at the end with the default value.\n  if (uninitializedIndex < outputRows) {\n    output.fill(defaultValue, uninitializedIndex * numCol, outputRows * numCol);\n  }\n  return [output, outputShape];\n}","map":{"version":3,"names":["backend_util","util","sparseSegmentReductionImpl","input","inputShape","inputDType","indices","segmentIds","isMean","defaultValue","numIndices","length","inputFlat","numCol","lastSegmentIdPlusOne","outputRows","Error","getSparseSegmentReductionNegativeSegmentIdsErrorMessage","outputShape","slice","outputLength","reduce","product","value","output","getArrayFromDType","fill","start","end","uninitializedIndex","outIndex","nextIndex","getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage","getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage","i","index","getSparseSegmentReductionIndicesOutOfRangeErrorMessage","j"],"sources":["/Users/jonchen/Documents/HackPSU/tfjs-backend-cpu/src/kernels/SparseSegmentReduction_impl.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, DataType, TypedArray, util} from '@tensorflow/tfjs-core';\n\nexport function sparseSegmentReductionImpl(\n    input: TypedArray, inputShape: number[], inputDType: DataType,\n    indices: TypedArray, segmentIds: TypedArray, isMean = false,\n    defaultValue = 0): [TypedArray, number[]] {\n  const numIndices = indices.length;\n\n  // Flatten the array to two dimensions\n  const inputFlat: number[] = [inputShape[0], input.length / inputShape[0]];\n  const numCol = inputFlat[1];\n  // Note that the current implementation assumes that segmentIds values are\n  // sorted.\n  const lastSegmentIdPlusOne =\n      numIndices > 0 ? segmentIds[numIndices - 1] + 1 : 0;\n  const outputRows = lastSegmentIdPlusOne;\n\n  if (outputRows < 0) {\n    throw new Error(\n        backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());\n  }\n\n  const outputShape = inputShape.slice();\n  outputShape[0] = outputRows;\n\n  const outputLength =\n      outputShape.reduce((product, value) => product * value, 1);\n  // Output array is initialized with the value 0 by default.\n  const output = util.getArrayFromDType(inputDType, outputLength) as TypedArray;\n\n  // Note that we do not initialize the output buffer with a default value, so\n  // we need to explicitly set missing indices to the default value.\n  if (numIndices === 0) {\n    if (outputRows > 0) {\n      output.fill(defaultValue);\n    }\n    return [output, outputShape];\n  }\n\n  if (outputRows <= 0) {\n    throw new Error(\n        backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());\n  }\n\n  let start = 0, end = 1;\n  // Index from which the output is not initialized.\n  let uninitializedIndex = 0;\n  let outIndex = segmentIds[start];\n\n  while (true) {\n    // We initialize nextIndex to 0 to avoid may be uninitialized warning\n    let nextIndex = 0;\n    if (end < numIndices) {\n      nextIndex = segmentIds[end];\n      if (outIndex === nextIndex) {\n        ++end;\n        continue;\n      }\n      // We have a new segment here.  Verify that the segment ids are growing.\n      if (outIndex >= nextIndex) {\n        throw new Error(backend_util\n            .getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage());\n      }\n    }\n\n    if (outIndex < 0 || outIndex >= outputRows) {\n      throw new Error(\n          backend_util.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(\n              outIndex, outputRows));\n    }\n\n    // If there is a gap between two indices, we need to set that gap to the\n    // default value.\n    if (outIndex > uninitializedIndex) {\n      output.fill(defaultValue, uninitializedIndex * numCol, outIndex * numCol);\n    }\n\n    for (let i = start; i < end; ++i) {\n      const index = indices[i];\n      if (index < 0 || index >= inputFlat[0]) {\n        throw new Error(\n            backend_util.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(\n                i, indices[i], inputFlat[0]));\n      }\n      for (let j = 0; j < numCol; j++) {\n        output[outIndex * numCol + j] += input[index * numCol + j];\n      }\n    }\n\n    if (isMean) {\n      for (let j = 0; j < numCol; j++) {\n        output[outIndex * numCol + j] /= end - start;\n      }\n    }\n\n    start = end;\n    ++end;\n    uninitializedIndex = outIndex + 1;\n    outIndex = nextIndex;\n    if (end > numIndices) {\n      break;\n    }\n  }\n\n  // Fill the gap at the end with the default value.\n  if (uninitializedIndex < outputRows) {\n    output.fill(defaultValue, uninitializedIndex * numCol, outputRows * numCol);\n  }\n\n  return [output, outputShape];\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}