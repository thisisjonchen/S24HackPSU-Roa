{"ast":null,"code":"/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { BroadcastArgs } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport { op } from './operation';\n/**\n * Return the shape of s0 op s1 with broadcast.\n *\n * compute r0, the broadcasted shape as a tensor.\n * s0, s1 and r0 are all integer vectors.\n *\n * This function returns the shape of the result of an operation between\n * two tensors of size s0 and s1 performed with broadcast.\n *\n * @param s0 A tensor representing a shape\n * @param s1 A tensor representing a shape\n *\n * @doc {heading: 'Tensors', subheading: 'Transformations'}\n */\nfunction broadcastArgs_(s0, s1) {\n  const shape1Input = convertToTensor(s0, 's0', 'broadcastArgs', 'int32');\n  const shape2Input = convertToTensor(s1, 's1', 'broadcastArgs', 'int32');\n  if (shape1Input.rank !== 1) {\n    throw new Error('broadcastArgs(): first input must be a vector (rank=1). ' + `Has rank ${shape1Input.rank}`);\n  }\n  if (shape2Input.rank !== 1) {\n    throw new Error('broadcastArgs(): second input must be a vector (rank=1). ' + `Has rank ${shape2Input.rank}`);\n  }\n  const inputs = {\n    s0: shape1Input,\n    s1: shape2Input\n  };\n  return ENGINE.runKernel(BroadcastArgs, inputs);\n}\nexport const broadcastArgs = /* @__PURE__ */op({\n  broadcastArgs_\n});","map":{"version":3,"names":["ENGINE","BroadcastArgs","convertToTensor","op","broadcastArgs_","s0","s1","shape1Input","shape2Input","rank","Error","inputs","runKernel","broadcastArgs"],"sources":["/Users/jonchen/Documents/HackPSU/tfjs-core/src/ops/broadcast_args.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport { NamedTensorMap } from '../tensor_types';\nimport { ENGINE } from '../engine';\nimport { BroadcastArgs, BroadcastArgsInputs } from '../kernel_names';\nimport { Tensor } from '../tensor';\nimport { convertToTensor } from '../tensor_util_env';\nimport { Rank, TensorLike } from '../types';\n\nimport { op } from './operation';\n\n/**\n * Return the shape of s0 op s1 with broadcast.\n *\n * compute r0, the broadcasted shape as a tensor.\n * s0, s1 and r0 are all integer vectors.\n *\n * This function returns the shape of the result of an operation between\n * two tensors of size s0 and s1 performed with broadcast.\n *\n * @param s0 A tensor representing a shape\n * @param s1 A tensor representing a shape\n *\n * @doc {heading: 'Tensors', subheading: 'Transformations'}\n */\nfunction broadcastArgs_<R extends Rank>(\n  s0: Tensor | TensorLike, s1: Tensor | TensorLike): Tensor<R> {\n  const shape1Input = convertToTensor(s0, 's0', 'broadcastArgs', 'int32');\n  const shape2Input = convertToTensor(s1, 's1', 'broadcastArgs', 'int32');\n\n  if (shape1Input.rank !== 1) {\n    throw new Error(\n      'broadcastArgs(): first input must be a vector (rank=1). ' +\n      `Has rank ${shape1Input.rank}`);\n  }\n\n  if (shape2Input.rank !== 1) {\n    throw new Error(\n      'broadcastArgs(): second input must be a vector (rank=1). ' +\n      `Has rank ${shape2Input.rank}`);\n  }\n\n  const inputs: BroadcastArgsInputs = { s0: shape1Input, s1: shape2Input };\n  return ENGINE.runKernel(BroadcastArgs, inputs as unknown as NamedTensorMap);\n}\n\nexport const broadcastArgs = /* @__PURE__ */ op({ broadcastArgs_ });\n"],"mappings":"AAAA;;;;;;;;;;;;;;;;AAkBA,SAASA,MAAM,QAAQ,WAAW;AAClC,SAASC,aAAa,QAA6B,iBAAiB;AAEpE,SAASC,eAAe,QAAQ,oBAAoB;AAGpD,SAASC,EAAE,QAAQ,aAAa;AAEhC;;;;;;;;;;;;;;AAcA,SAASC,cAAcA,CACrBC,EAAuB,EAAEC,EAAuB;EAChD,MAAMC,WAAW,GAAGL,eAAe,CAACG,EAAE,EAAE,IAAI,EAAE,eAAe,EAAE,OAAO,CAAC;EACvE,MAAMG,WAAW,GAAGN,eAAe,CAACI,EAAE,EAAE,IAAI,EAAE,eAAe,EAAE,OAAO,CAAC;EAEvE,IAAIC,WAAW,CAACE,IAAI,KAAK,CAAC,EAAE;IAC1B,MAAM,IAAIC,KAAK,CACb,0DAA0D,GAC1D,YAAYH,WAAW,CAACE,IAAI,EAAE,CAAC;;EAGnC,IAAID,WAAW,CAACC,IAAI,KAAK,CAAC,EAAE;IAC1B,MAAM,IAAIC,KAAK,CACb,2DAA2D,GAC3D,YAAYF,WAAW,CAACC,IAAI,EAAE,CAAC;;EAGnC,MAAME,MAAM,GAAwB;IAAEN,EAAE,EAAEE,WAAW;IAAED,EAAE,EAAEE;EAAW,CAAE;EACxE,OAAOR,MAAM,CAACY,SAAS,CAACX,aAAa,EAAEU,MAAmC,CAAC;AAC7E;AAEA,OAAO,MAAME,aAAa,GAAG,eAAgBV,EAAE,CAAC;EAAEC;AAAc,CAAE,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}