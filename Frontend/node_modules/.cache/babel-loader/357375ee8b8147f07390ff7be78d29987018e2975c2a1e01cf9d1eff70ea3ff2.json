{"ast":null,"code":"import { convertToTensor, convertToTensorArray } from '../tensor_util_env';\nimport { op } from './operation';\n/**\n * Computes the next states and outputs of a stack of LSTMCells.\n *\n * Each cell output is used as input to the next cell.\n *\n * Returns `[cellState, cellOutput]`.\n *\n * Derived from tf.contrib.rn.MultiRNNCell.\n *\n * @param lstmCells Array of LSTMCell functions.\n * @param data The input to the cell.\n * @param c Array of previous cell states.\n * @param h Array of previous cell outputs.\n *\n * @doc {heading: 'Operations', subheading: 'RNN'}\n */\nfunction multiRNNCell_(lstmCells, data, c, h) {\n  const $data = convertToTensor(data, 'data', 'multiRNNCell');\n  const $c = convertToTensorArray(c, 'c', 'multiRNNCell');\n  const $h = convertToTensorArray(h, 'h', 'multiRNNCell');\n  let input = $data;\n  const newStates = [];\n  for (let i = 0; i < lstmCells.length; i++) {\n    const output = lstmCells[i](input, $c[i], $h[i]);\n    newStates.push(output[0]);\n    newStates.push(output[1]);\n    input = output[1];\n  }\n  const newC = [];\n  const newH = [];\n  for (let i = 0; i < newStates.length; i += 2) {\n    newC.push(newStates[i]);\n    newH.push(newStates[i + 1]);\n  }\n  return [newC, newH];\n}\nexport const multiRNNCell = /* @__PURE__ */op({\n  multiRNNCell_\n});","map":{"version":3,"names":["convertToTensor","convertToTensorArray","op","multiRNNCell_","lstmCells","data","c","h","$data","$c","$h","input","newStates","i","length","output","push","newC","newH","multiRNNCell"],"sources":["/Users/jonchen/Documents/HackPSU/tfjs-core/src/ops/multi_rnn_cell.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {Tensor2D} from '../tensor';\nimport {convertToTensor, convertToTensorArray} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport {op} from './operation';\n\n/**\n * @docalias (data: Tensor2D, c: Tensor2D, h: Tensor2D): [Tensor2D, Tensor2D]\n */\nexport type LSTMCellFunc = {\n  (data: Tensor2D, c: Tensor2D, h: Tensor2D): [Tensor2D, Tensor2D];\n};\n\n/**\n * Computes the next states and outputs of a stack of LSTMCells.\n *\n * Each cell output is used as input to the next cell.\n *\n * Returns `[cellState, cellOutput]`.\n *\n * Derived from tf.contrib.rn.MultiRNNCell.\n *\n * @param lstmCells Array of LSTMCell functions.\n * @param data The input to the cell.\n * @param c Array of previous cell states.\n * @param h Array of previous cell outputs.\n *\n * @doc {heading: 'Operations', subheading: 'RNN'}\n */\nfunction multiRNNCell_(\n    lstmCells: LSTMCellFunc[], data: Tensor2D|TensorLike,\n    c: Array<Tensor2D|TensorLike>,\n    h: Array<Tensor2D|TensorLike>): [Tensor2D[], Tensor2D[]] {\n  const $data = convertToTensor(data, 'data', 'multiRNNCell');\n  const $c = convertToTensorArray(c, 'c', 'multiRNNCell');\n  const $h = convertToTensorArray(h, 'h', 'multiRNNCell');\n\n  let input = $data;\n  const newStates = [];\n  for (let i = 0; i < lstmCells.length; i++) {\n    const output = lstmCells[i](input, $c[i], $h[i]);\n    newStates.push(output[0]);\n    newStates.push(output[1]);\n    input = output[1];\n  }\n  const newC: Tensor2D[] = [];\n  const newH: Tensor2D[] = [];\n  for (let i = 0; i < newStates.length; i += 2) {\n    newC.push(newStates[i]);\n    newH.push(newStates[i + 1]);\n  }\n  return [newC, newH];\n}\nexport const multiRNNCell = /* @__PURE__ */ op({multiRNNCell_});\n"],"mappings":"AAiBA,SAAQA,eAAe,EAAEC,oBAAoB,QAAO,oBAAoB;AAExE,SAAQC,EAAE,QAAO,aAAa;AAS9B;;;;;;;;;;;;;;;;AAgBA,SAASC,aAAaA,CAClBC,SAAyB,EAAEC,IAAyB,EACpDC,CAA6B,EAC7BC,CAA6B;EAC/B,MAAMC,KAAK,GAAGR,eAAe,CAACK,IAAI,EAAE,MAAM,EAAE,cAAc,CAAC;EAC3D,MAAMI,EAAE,GAAGR,oBAAoB,CAACK,CAAC,EAAE,GAAG,EAAE,cAAc,CAAC;EACvD,MAAMI,EAAE,GAAGT,oBAAoB,CAACM,CAAC,EAAE,GAAG,EAAE,cAAc,CAAC;EAEvD,IAAII,KAAK,GAAGH,KAAK;EACjB,MAAMI,SAAS,GAAG,EAAE;EACpB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGT,SAAS,CAACU,MAAM,EAAED,CAAC,EAAE,EAAE;IACzC,MAAME,MAAM,GAAGX,SAAS,CAACS,CAAC,CAAC,CAACF,KAAK,EAAEF,EAAE,CAACI,CAAC,CAAC,EAAEH,EAAE,CAACG,CAAC,CAAC,CAAC;IAChDD,SAAS,CAACI,IAAI,CAACD,MAAM,CAAC,CAAC,CAAC,CAAC;IACzBH,SAAS,CAACI,IAAI,CAACD,MAAM,CAAC,CAAC,CAAC,CAAC;IACzBJ,KAAK,GAAGI,MAAM,CAAC,CAAC,CAAC;;EAEnB,MAAME,IAAI,GAAe,EAAE;EAC3B,MAAMC,IAAI,GAAe,EAAE;EAC3B,KAAK,IAAIL,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,SAAS,CAACE,MAAM,EAAED,CAAC,IAAI,CAAC,EAAE;IAC5CI,IAAI,CAACD,IAAI,CAACJ,SAAS,CAACC,CAAC,CAAC,CAAC;IACvBK,IAAI,CAACF,IAAI,CAACJ,SAAS,CAACC,CAAC,GAAG,CAAC,CAAC,CAAC;;EAE7B,OAAO,CAACI,IAAI,EAAEC,IAAI,CAAC;AACrB;AACA,OAAO,MAAMC,YAAY,GAAG,eAAgBjB,EAAE,CAAC;EAACC;AAAa,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}