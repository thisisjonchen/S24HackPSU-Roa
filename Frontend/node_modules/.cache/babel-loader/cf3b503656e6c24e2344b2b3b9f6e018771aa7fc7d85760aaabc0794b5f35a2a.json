{"ast":null,"code":"/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, util } from '@tensorflow/tfjs-core';\nexport function sparseReshapeImpl(inputIndices, inputIndicesShape, inputDType, inputShape, targetShape) {\n  const denseSize = util.sizeFromShape(inputShape);\n  const nnz = inputIndicesShape[0];\n  const outputRank = targetShape.length;\n  // Compute the output shape. Determine product of specified dimensions, and\n  // find the index of the unspecified one.\n  const outputShape = [];\n  let product = 1;\n  let unknownIndex = -1;\n  for (let d = 0; d < outputRank; ++d) {\n    const size = targetShape[d];\n    if (size === -1) {\n      if (unknownIndex !== -1) {\n        throw new Error(backend_util.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(unknownIndex, d));\n      }\n      unknownIndex = d;\n      outputShape.push(1);\n    } else {\n      if (size < 0) {\n        throw new Error(backend_util.getSparseReshapeNegativeOutputDimErrorMessage(d, size));\n      }\n      product *= size;\n      outputShape.push(size);\n    }\n  }\n  if (unknownIndex !== -1) {\n    if (product <= 0) {\n      throw new Error(backend_util.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());\n    }\n    const missing = Math.trunc(denseSize / product);\n    if (product * missing !== denseSize) {\n      throw new Error(backend_util.getSparseReshapeInputOutputMultipleErrorMessage(inputShape, outputShape));\n    }\n    outputShape[unknownIndex] = missing;\n  }\n  const outputSize = util.sizeFromShape(outputShape);\n  if (outputSize !== denseSize) {\n    throw new Error(backend_util.getSparseReshapeInputOutputMismatchErrorMessage(inputShape, outputShape));\n  }\n  const inputRank = inputShape.length;\n  const inputStrides = [];\n  if (inputRank > 0) {\n    inputStrides[inputRank - 1] = 1;\n    for (let d = inputRank - 2; d >= 0; --d) {\n      inputStrides[d] = inputStrides[d + 1] * inputShape[d + 1];\n    }\n  }\n  const outputStrides = [];\n  if (outputRank > 0) {\n    outputStrides[outputRank - 1] = 1;\n    for (let d = outputRank - 2; d >= 0; --d) {\n      outputStrides[d] = outputStrides[d + 1] * outputShape[d + 1];\n    }\n  }\n  const newIndices = util.getArrayFromDType(inputDType, nnz * outputRank);\n  for (let i = 0; i < nnz; ++i) {\n    let id = 0;\n    for (let j = 0; j < inputRank; ++j) {\n      // inputIndices is a 2d tensor with shape of [nnz, inputRank]\n      id += inputIndices[i * inputRank + j] * inputStrides[j];\n    }\n    for (let j = 0; j < outputRank; ++j) {\n      // newIndices is a 2d tensor with shape of [nnz, outputRank]\n      newIndices[i * outputRank + j] = Math.trunc(id / outputStrides[j]);\n      id %= outputStrides[j];\n    }\n  }\n  return [newIndices, [nnz, outputRank], outputShape];\n}","map":{"version":3,"names":["backend_util","util","sparseReshapeImpl","inputIndices","inputIndicesShape","inputDType","inputShape","targetShape","denseSize","sizeFromShape","nnz","outputRank","length","outputShape","product","unknownIndex","d","size","Error","getSparseReshapeMultipleNegativeOneOutputDimErrorMessage","push","getSparseReshapeNegativeOutputDimErrorMessage","getSparseReshapeEmptyTensorZeroOutputDimErrorMessage","missing","Math","trunc","getSparseReshapeInputOutputMultipleErrorMessage","outputSize","getSparseReshapeInputOutputMismatchErrorMessage","inputRank","inputStrides","outputStrides","newIndices","getArrayFromDType","i","id","j"],"sources":["/Users/jonchen/Documents/HackPSU/tfjs-backend-cpu/src/kernels/SparseReshape_impl.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, DataType, TypedArray, util} from '@tensorflow/tfjs-core';\n\nexport function sparseReshapeImpl(\n    inputIndices: TypedArray, inputIndicesShape: number[], inputDType: DataType,\n    inputShape: number[],\n    targetShape: number[]): [TypedArray, number[], number[]] {\n  const denseSize = util.sizeFromShape(inputShape);\n  const nnz = inputIndicesShape[0];\n  const outputRank = targetShape.length;\n\n  // Compute the output shape. Determine product of specified dimensions, and\n  // find the index of the unspecified one.\n  const outputShape: number[] = [];\n  let product = 1;\n  let unknownIndex = -1;\n  for (let d = 0; d < outputRank; ++d) {\n    const size = targetShape[d];\n    if (size === -1) {\n      if (unknownIndex !== -1) {\n        throw new Error(\n            backend_util\n                .getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(\n                    unknownIndex, d));\n      }\n      unknownIndex = d;\n      outputShape.push(1);\n    } else {\n      if (size < 0) {\n        throw new Error(\n            backend_util.getSparseReshapeNegativeOutputDimErrorMessage(\n                d, size));\n      }\n      product *= size;\n      outputShape.push(size);\n    }\n  }\n  if (unknownIndex !== -1) {\n    if (product <= 0) {\n      throw new Error(\n          backend_util.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());\n    }\n    const missing = Math.trunc(denseSize / product);\n    if (product * missing !== denseSize) {\n      throw new Error(\n          backend_util.getSparseReshapeInputOutputMultipleErrorMessage(\n              inputShape, outputShape));\n    }\n\n    outputShape[unknownIndex] = missing;\n  }\n  const outputSize = util.sizeFromShape(outputShape);\n  if (outputSize !== denseSize) {\n    throw new Error(\n        backend_util.getSparseReshapeInputOutputMismatchErrorMessage(\n            inputShape, outputShape));\n  }\n\n  const inputRank = inputShape.length;\n  const inputStrides: number[] = [];\n  if (inputRank > 0) {\n    inputStrides[inputRank - 1] = 1;\n    for (let d = inputRank - 2; d >= 0; --d) {\n      inputStrides[d] = inputStrides[d + 1] * inputShape[d + 1];\n    }\n  }\n\n  const outputStrides: number[] = [];\n  if (outputRank > 0) {\n    outputStrides[outputRank - 1] = 1;\n    for (let d = outputRank - 2; d >= 0; --d) {\n      outputStrides[d] = outputStrides[d + 1] * outputShape[d + 1];\n    }\n  }\n\n  const newIndices =\n      util.getArrayFromDType(inputDType, nnz * outputRank) as TypedArray;\n  for (let i = 0; i < nnz; ++i) {\n    let id = 0;\n    for (let j = 0; j < inputRank; ++j) {\n      // inputIndices is a 2d tensor with shape of [nnz, inputRank]\n      id += inputIndices[i * inputRank + j] * inputStrides[j];\n    }\n    for (let j = 0; j < outputRank; ++j) {\n      // newIndices is a 2d tensor with shape of [nnz, outputRank]\n      newIndices[i * outputRank + j] = Math.trunc(id / outputStrides[j]);\n      id %= outputStrides[j];\n    }\n  }\n  return [newIndices, [nnz, outputRank], outputShape];\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}