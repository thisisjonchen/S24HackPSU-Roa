{"ast":null,"code":"/**\n * @license\n * Copyright 2023 CodeSmith LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nimport { image, serialization, tidy } from '@tensorflow/tfjs-core';\nimport { getExactlyOneTensor, getExactlyOneShape } from '../../utils/types_utils';\nimport { ValueError } from '../../errors';\nimport { BaseRandomLayer } from '../../engine/base_random_layer';\nimport { randomUniform } from '@tensorflow/tfjs-core';\nconst INTERPOLATION_KEYS = ['bilinear', 'nearest'];\nexport const INTERPOLATION_METHODS = new Set(INTERPOLATION_KEYS);\n/**\n * Preprocessing Layer with randomly varies image during training\n *\n * This layer randomly adjusts the width of a batch of images of a\n * batch of images by a random factor.\n *\n * The input should be a 3D (unbatched) or\n * 4D (batched) tensor in the `\"channels_last\"` image data format. Input pixel\n * values can be of any range (e.g. `[0., 1.)` or `[0, 255]`) and of interger\n * or floating point dtype. By default, the layer will output floats.\n *\n * tf methods implemented in tfjs: 'bilinear', 'nearest',\n * tf methods unimplemented in tfjs: 'bicubic', 'area', 'lanczos3', 'lanczos5',\n *                                   'gaussian', 'mitchellcubic'\n *\n */\nclass RandomWidth extends BaseRandomLayer {\n  constructor(args) {\n    super(args);\n    const {\n      factor,\n      interpolation = 'bilinear'\n    } = args;\n    this.factor = factor;\n    if (Array.isArray(this.factor) && this.factor.length === 2) {\n      this.widthLower = this.factor[0];\n      this.widthUpper = this.factor[1];\n    } else if (!Array.isArray(this.factor) && this.factor > 0) {\n      this.widthLower = -this.factor;\n      this.widthUpper = this.factor;\n    } else {\n      throw new ValueError(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);\n    }\n    if (this.widthLower < -1.0 || this.widthUpper < -1.0) {\n      throw new ValueError(`factor must have values larger than -1. Got: ${this.factor}`);\n    }\n    if (this.widthUpper < this.widthLower) {\n      throw new ValueError(`factor cannot have upper bound less than lower bound.\n        Got upper bound: ${this.widthUpper}.\n        Got lower bound: ${this.widthLower}\n      `);\n    }\n    if (interpolation) {\n      if (INTERPOLATION_METHODS.has(interpolation)) {\n        this.interpolation = interpolation;\n      } else {\n        throw new ValueError(`Invalid interpolation parameter: ${interpolation} is not implemented`);\n      }\n    }\n  }\n  getConfig() {\n    const config = {\n      'factor': this.factor,\n      'interpolation': this.interpolation\n    };\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n  computeOutputShape(inputShape) {\n    inputShape = getExactlyOneShape(inputShape);\n    const numChannels = inputShape[2];\n    return [this.imgHeight, -1, numChannels];\n  }\n  call(inputs, kwargs) {\n    return tidy(() => {\n      const input = getExactlyOneTensor(inputs);\n      this.imgHeight = input.shape[input.shape.length - 3];\n      const imgWidth = input.shape[input.shape.length - 2];\n      this.widthFactor = randomUniform([1], 1.0 + this.widthLower, 1.0 + this.widthUpper, 'float32', this.randomGenerator.next());\n      let adjustedWidth = this.widthFactor.dataSync()[0] * imgWidth;\n      adjustedWidth = Math.round(adjustedWidth);\n      const size = [this.imgHeight, adjustedWidth];\n      switch (this.interpolation) {\n        case 'bilinear':\n          return image.resizeBilinear(inputs, size);\n        case 'nearest':\n          return image.resizeNearestNeighbor(inputs, size);\n        default:\n          throw new Error(`Interpolation is ${this.interpolation}\n          but only ${[...INTERPOLATION_METHODS]} are supported`);\n      }\n    });\n  }\n}\n/** @nocollapse */\nRandomWidth.className = 'RandomWidth';\nexport { RandomWidth };\nserialization.registerClass(RandomWidth);","map":{"version":3,"names":["image","serialization","tidy","getExactlyOneTensor","getExactlyOneShape","ValueError","BaseRandomLayer","randomUniform","INTERPOLATION_KEYS","INTERPOLATION_METHODS","Set","RandomWidth","constructor","args","factor","interpolation","Array","isArray","length","widthLower","widthUpper","has","getConfig","config","baseConfig","Object","assign","computeOutputShape","inputShape","numChannels","imgHeight","call","inputs","kwargs","input","shape","imgWidth","widthFactor","randomGenerator","next","adjustedWidth","dataSync","Math","round","size","resizeBilinear","resizeNearestNeighbor","Error","className","registerClass"],"sources":["/Users/jonchen/Documents/HackPSU/tfjs-layers/src/layers/preprocessing/random_width.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2023 CodeSmith LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\nimport { image, Rank, serialization, Tensor, tidy } from '@tensorflow/tfjs-core';\nimport { getExactlyOneTensor, getExactlyOneShape } from '../../utils/types_utils';\nimport { Shape } from '../../keras_format/common';\nimport { Kwargs } from '../../types';\nimport { ValueError } from '../../errors';\nimport { BaseRandomLayerArgs, BaseRandomLayer } from '../../engine/base_random_layer';\nimport { randomUniform } from '@tensorflow/tfjs-core';\n\nexport declare interface RandomWidthArgs extends BaseRandomLayerArgs {\n   factor: number | [number, number];\n   interpolation?: InterpolationType; // default = 'bilinear';\n   seed?: number; // default = null;\n   autoVectorize?: boolean;\n}\n\nconst INTERPOLATION_KEYS = ['bilinear', 'nearest'] as const;\nexport const INTERPOLATION_METHODS = new Set(INTERPOLATION_KEYS);\ntype InterpolationType = typeof INTERPOLATION_KEYS[number];\n\n/**\n * Preprocessing Layer with randomly varies image during training\n *\n * This layer randomly adjusts the width of a batch of images of a\n * batch of images by a random factor.\n *\n * The input should be a 3D (unbatched) or\n * 4D (batched) tensor in the `\"channels_last\"` image data format. Input pixel\n * values can be of any range (e.g. `[0., 1.)` or `[0, 255]`) and of interger\n * or floating point dtype. By default, the layer will output floats.\n *\n * tf methods implemented in tfjs: 'bilinear', 'nearest',\n * tf methods unimplemented in tfjs: 'bicubic', 'area', 'lanczos3', 'lanczos5',\n *                                   'gaussian', 'mitchellcubic'\n *\n */\n\nexport class RandomWidth extends BaseRandomLayer {\n  /** @nocollapse */\n  static override className = 'RandomWidth';\n  private readonly factor: number | [number, number];\n  private readonly interpolation?: InterpolationType;  // defualt = 'bilinear\n  private widthLower: number;\n  private widthUpper: number;\n  private imgHeight: number;\n  private widthFactor: Tensor<Rank.R1>;\n\n  constructor(args: RandomWidthArgs) {\n    super(args);\n    const {factor, interpolation = 'bilinear'} = args;\n\n    this.factor = factor;\n\n    if (Array.isArray(this.factor) && this.factor.length === 2) {\n      this.widthLower = this.factor[0];\n      this.widthUpper = this.factor[1];\n    } else if (!Array.isArray(this.factor) && this.factor > 0){\n      this.widthLower = -this.factor;\n      this.widthUpper = this.factor;\n    } else {\n      throw new ValueError(\n        `Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`\n      );\n    }\n    if (this.widthLower < -1.0 || this.widthUpper < -1.0) {\n      throw new ValueError(\n        `factor must have values larger than -1. Got: ${this.factor}`\n      );\n    }\n\n    if (this.widthUpper < this.widthLower) {\n      throw new ValueError(\n        `factor cannot have upper bound less than lower bound.\n        Got upper bound: ${this.widthUpper}.\n        Got lower bound: ${this.widthLower}\n      `);\n    }\n\n    if (interpolation) {\n      if (INTERPOLATION_METHODS.has(interpolation)) {\n        this.interpolation = interpolation;\n      } else {\n        throw new ValueError(`Invalid interpolation parameter: ${\n            interpolation} is not implemented`);\n      }\n    } \n  }\n\n  override getConfig(): serialization.ConfigDict {\n    const config: serialization.ConfigDict = {\n      'factor': this.factor,\n      'interpolation': this.interpolation,\n    };\n\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n\n  override computeOutputShape(inputShape: Shape|Shape[]): Shape|Shape[] {\n    inputShape = getExactlyOneShape(inputShape);\n    const numChannels = inputShape[2];\n    return [this.imgHeight, -1, numChannels];\n  }\n\n  override call(inputs: Tensor<Rank.R3>|Tensor<Rank.R4>,\n    kwargs: Kwargs): Tensor[]|Tensor {\n\n    return tidy(() => {\n      const input = getExactlyOneTensor(inputs);\n      this.imgHeight = input.shape[input.shape.length - 3];\n      const imgWidth = input.shape[input.shape.length - 2];\n\n      this.widthFactor = randomUniform([1],\n        (1.0 + this.widthLower), (1.0 + this.widthUpper),\n        'float32', this.randomGenerator.next()\n      );\n\n      let adjustedWidth = this.widthFactor.dataSync()[0] * imgWidth;\n      adjustedWidth = Math.round(adjustedWidth);\n\n      const size:[number, number] = [this.imgHeight, adjustedWidth];\n\n      switch (this.interpolation) {\n        case 'bilinear':\n          return image.resizeBilinear(inputs, size);\n        case 'nearest':\n          return image.resizeNearestNeighbor(inputs, size);\n        default:\n          throw new Error(`Interpolation is ${this.interpolation}\n          but only ${[...INTERPOLATION_METHODS]} are supported`);\n      }\n    });\n  }\n}\n\nserialization.registerClass(RandomWidth);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}