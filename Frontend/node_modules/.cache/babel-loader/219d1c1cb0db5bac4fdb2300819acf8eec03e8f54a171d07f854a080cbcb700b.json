{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/* Original source keras/models.py */\nimport { dispose, io, serialization, util } from '@tensorflow/tfjs-core';\nimport { getUid } from './backend/state';\nimport { Input } from './engine/input_layer';\nimport { getSourceInputs, Node } from './engine/topology';\nimport { LayersModel } from './engine/training';\nimport { NotImplementedError, RuntimeError, ValueError } from './errors';\nimport { deserialize } from './layers/serialization';\nimport * as generic_utils from './utils/generic_utils';\nimport { convertPythonicToTs } from './utils/serialization_utils';\nimport { getExactlyOneShape } from './utils/types_utils';\n/**\n * Parses a JSON model configuration file and returns a model instance.\n *\n * ```js\n * // This example shows how to serialize a model using `toJSON()` and\n * // deserialize it as another model using `tf.models.modelFromJSON()`.\n * // Note: this example serializes and deserializes only the topology\n * // of the model; the weights of the loaded model will be different\n * // from those of the the original model, due to random weight\n * // initialization.\n * // To load the topology and weights of a model, use `tf.loadLayersModel()`.\n * const model1 = tf.sequential();\n * model1.add(tf.layers.repeatVector({inputShape: [2], n: 4}));\n * // Serialize `model1` as a JSON object.\n * const model1JSON = model1.toJSON(null, false);\n * model1.summary();\n *\n * const model2 = await tf.models.modelFromJSON(model1JSON);\n * model2.summary();\n * ```\n *\n *  @param modelAndWeightsConfig JSON object or string encoding a model and\n *       weights configuration. It can also be only the topology JSON of the\n *       model, in which case the weights will not be loaded.\n *  @param custom_objects Optional dictionary mapping names\n *       (strings) to custom classes or functions to be\n *       considered during deserialization.\n * @returns A TensorFlow.js Layers `tf.LayersModel` instance (uncompiled).\n */\nexport async function modelFromJSON(modelAndWeightsConfig, customObjects) {\n  if (!('modelTopology' in modelAndWeightsConfig)) {\n    modelAndWeightsConfig = {\n      modelTopology: modelAndWeightsConfig\n    };\n  }\n  modelAndWeightsConfig = modelAndWeightsConfig;\n  let modelTopology = modelAndWeightsConfig.modelTopology;\n  if (modelTopology['model_config'] != null) {\n    // If the model-topology JSON contains a 'model_config' field, then it is\n    // a full model JSON (e.g., from `keras.Model.save()`), which contains\n    // not only the model's architecture in its 'model_config' field, but\n    // additional information such as the model's optimizer. We use only the\n    // 'model_config' field currently.\n    modelTopology = modelTopology['model_config'];\n  }\n  const tsConfig = convertPythonicToTs(modelTopology);\n  const model = deserialize(tsConfig, customObjects);\n  if (modelAndWeightsConfig.weightsManifest != null) {\n    // Load the weight values keyed by the original tensor names in the model\n    // file that was loaded.  These should match the keys of the weight\n    // manifest.\n    const weightValues = await io.loadWeights(modelAndWeightsConfig.weightsManifest, modelAndWeightsConfig.pathPrefix, model.weights.map(weight => weight.originalName));\n    // Map the weights to the unique tensor names generated during model loading\n    const uniqueWeightValues = {};\n    for (const weight of model.weights) {\n      uniqueWeightValues[weight.originalName] = weightValues[weight.originalName];\n    }\n    model.loadWeights(uniqueWeightValues);\n    // Dispose temporary weight values.\n    dispose(weightValues);\n  }\n  return model;\n}\n/**\n * Load a model composed of Layer objects, including its topology and optionally\n * weights. See the Tutorial named \"How to import a Keras Model\" for usage\n * examples.\n *\n * This method is applicable to:\n *\n * 1. Models created with the `tf.layers.*`, `tf.sequential`, and\n * `tf.model` APIs of TensorFlow.js and later saved with the\n * `tf.LayersModel.save` method.\n * 2. Models converted from Keras or TensorFlow tf.keras using the\n * [tensorflowjs_converter](https://github.com/tensorflow/tfjs/tree/master/tfjs-converter).\n *\n * This mode is *not* applicable to TensorFlow `SavedModel`s or their converted\n * forms. For those models, use `tf.loadGraphModel`.\n *\n * Example 1. Load a model from an HTTP server.\n *\n * ```js\n * const model = await tf.loadLayersModel(\n *     'https://storage.googleapis.com/tfjs-models/tfjs/iris_v1/model.json');\n * model.summary();\n * ```\n *\n * Example 2: Save `model`'s topology and weights to browser [local\n * storage](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage);\n * then load it back.\n *\n * ```js\n * const model = tf.sequential(\n *     {layers: [tf.layers.dense({units: 1, inputShape: [3]})]});\n * console.log('Prediction from original model:');\n * model.predict(tf.ones([1, 3])).print();\n *\n * const saveResults = await model.save('localstorage://my-model-1');\n *\n * const loadedModel = await tf.loadLayersModel('localstorage://my-model-1');\n * console.log('Prediction from loaded model:');\n * loadedModel.predict(tf.ones([1, 3])).print();\n * ```\n *\n * Example 3. Saving `model`'s topology and weights to browser\n * [IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API);\n * then load it back.\n *\n * ```js\n * const model = tf.sequential(\n *     {layers: [tf.layers.dense({units: 1, inputShape: [3]})]});\n * console.log('Prediction from original model:');\n * model.predict(tf.ones([1, 3])).print();\n *\n * const saveResults = await model.save('indexeddb://my-model-1');\n *\n * const loadedModel = await tf.loadLayersModel('indexeddb://my-model-1');\n * console.log('Prediction from loaded model:');\n * loadedModel.predict(tf.ones([1, 3])).print();\n * ```\n *\n * Example 4. Load a model from user-selected files from HTML\n * [file input\n * elements](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file).\n *\n * ```js\n * // Note: this code snippet will not work without the HTML elements in the\n * //   page\n * const jsonUpload = document.getElementById('json-upload');\n * const weightsUpload = document.getElementById('weights-upload');\n *\n * const model = await tf.loadLayersModel(\n *     tf.io.browserFiles([jsonUpload.files[0], weightsUpload.files[0]]));\n * ```\n *\n * @param pathOrIOHandler Can be either of the two formats\n *   1. A string path to the `ModelAndWeightsConfig` JSON describing\n *      the model in the canonical TensorFlow.js format. For file://\n *      (tfjs-node-only), http:// and https:// schemas, the path can be\n *      either absolute or relative. The content of the JSON file is assumed to\n *      be a JSON object with the following fields and values:\n *      - 'modelTopology': A JSON object that can be either of:\n *        1. a model architecture JSON consistent with the format of the return\n *            value of `keras.Model.to_json()`\n *        2. a full model JSON in the format of `keras.models.save_model()`.\n *      - 'weightsManifest': A TensorFlow.js weights manifest.\n *      See the Python converter function `save_model()` for more details.\n *      It is also assumed that model weights can be accessed from relative\n *      paths described by the `paths` fields in weights manifest.\n *   2. A `tf.io.IOHandler` object that loads model artifacts with its `load`\n *      method.\n * @param options Optional configuration arguments for the model loading,\n *   including:\n *   - `strict`: Require that the provided weights exactly match those required\n *     by the layers.  Default true.  Passing false means that both extra\n *     weights and missing weights will be silently ignored.\n *   - `onProgress`: A progress callback of the form:\n *     `(fraction: number) => void`. This callback can be used to monitor the\n *     model-loading process.\n * @returns A `Promise` of `tf.LayersModel`, with the topology and weights\n *     loaded.\n *\n * @doc {heading: 'Models', subheading: 'Loading'}\n */\nexport async function loadLayersModel(pathOrIOHandler, options) {\n  if (options == null) {\n    options = {};\n  }\n  if (typeof pathOrIOHandler === 'string') {\n    const handlers = io.getLoadHandlers(pathOrIOHandler, options);\n    if (handlers.length === 0) {\n      // For backward compatibility: if no load handler can be found,\n      // assume it is a relative http path.\n      // TODO(cais): Reformat the args into a single `LoadOptions` once the core\n      // is refactored.\n      handlers.push(io.browserHTTPRequest(pathOrIOHandler, options));\n    } else if (handlers.length > 1) {\n      throw new ValueError(`Found more than one (${handlers.length}) load handlers for ` + `URL '${pathOrIOHandler}'`);\n    }\n    pathOrIOHandler = handlers[0];\n  }\n  return loadLayersModelFromIOHandler(pathOrIOHandler, undefined, options);\n}\n/**\n * Load a model and optionally its weights, using an IOHandler object.\n *\n * @param handler The instance of `IOHandler` to be used during the model\n *   loading.\n * @param customObjects Any optional custom objects to be used during model\n *   loading.\n * @param strict Whether the weight loading will be done in strict mode.\n *   Default: `true`.\n */\nexport async function loadLayersModelFromIOHandler(handler, customObjects, options) {\n  if (options == null) {\n    options = {};\n  }\n  if (handler.load == null) {\n    throw new ValueError('Cannot proceed with model loading because the IOHandler provided ' + 'does not have the `load` method implemented.');\n  }\n  const artifacts = await handler.load();\n  let modelTopology = artifacts.modelTopology;\n  if (modelTopology['model_config'] != null) {\n    modelTopology = modelTopology['model_config'];\n  }\n  const strict = options.strict == null ? true : options.strict;\n  // If weights are provided and the weight-loading mode is strict, use\n  // fast weight initialization. This skips costly initializers such as\n  // 'orthogonal' and saves unnecessary computation in cases where\n  // the initialized weight values will immediately be overwritten by\n  // loaded weight values.\n  const fastWeightInit = artifacts.weightData != null && artifacts.weightSpecs != null && strict;\n  const model = deserialize(convertPythonicToTs(modelTopology), customObjects, fastWeightInit);\n  const trainingConfig = artifacts.trainingConfig;\n  if (trainingConfig != null) {\n    model.loadTrainingConfig(trainingConfig);\n  }\n  if (artifacts.userDefinedMetadata != null) {\n    model.setUserDefinedMetadata(artifacts.userDefinedMetadata);\n  }\n  // If weightData is present, load the weights into the model.\n  if (artifacts.weightData != null) {\n    // Loading weights requires weightSpecs.\n    if (artifacts.weightSpecs == null) {\n      throw new ValueError('LayersModel artifacts contains weight data, but not weight specs. ' + 'Therefore loading of weights cannot proceed.');\n    }\n    const {\n      modelWeights,\n      optimizerWeights\n    } = decodeModelAndOptimizerWeights(artifacts.weightData, artifacts.weightSpecs);\n    model.loadWeights(modelWeights, strict);\n    if (model.optimizer != null && optimizerWeights.length > 0) {\n      await model.optimizer.setWeights(optimizerWeights);\n    }\n    // Dispose temporary weight values.\n    dispose(modelWeights);\n    dispose(optimizerWeights.map(w => w.tensor));\n  }\n  return model;\n}\nfunction decodeModelAndOptimizerWeights(weightData, specs) {\n  const name2Tensor = io.decodeWeights(weightData, specs);\n  const modelWeights = {};\n  const optimizerWeights = [];\n  specs.forEach(spec => {\n    if (spec.group === 'optimizer') {\n      optimizerWeights.push({\n        name: spec.name,\n        tensor: name2Tensor[spec.name]\n      });\n    } else {\n      modelWeights[spec.name] = name2Tensor[spec.name];\n    }\n  });\n  return {\n    modelWeights,\n    optimizerWeights\n  };\n}\n/**\n * A model with a stack of layers, feeding linearly from one to the next.\n *\n * `tf.sequential` is a factory function that creates an instance of\n * `tf.Sequential`.\n *\n * ```js\n *  // Define a model for linear regression.\n *  const model = tf.sequential();\n *  model.add(tf.layers.dense({units: 1, inputShape: [1]}));\n *\n *  // Prepare the model for training: Specify the loss and the optimizer.\n *  model.compile({loss: 'meanSquaredError', optimizer: 'sgd'});\n *\n *  // Generate some synthetic data for training.\n *  const xs = tf.tensor2d([1, 2, 3, 4], [4, 1]);\n *  const ys = tf.tensor2d([1, 3, 5, 7], [4, 1]);\n *\n *  // Train the model using the data then do inference on a data point the\n *  // model hasn't seen:\n *  await model.fit(xs, ys);\n *  model.predict(tf.tensor2d([5], [1, 1])).print();\n * ```\n *\n * @doc {heading: 'Models', subheading: 'Classes'}\n */\nclass Sequential extends LayersModel {\n  constructor(args) {\n    super({\n      inputs: [],\n      outputs: []\n    });\n    args = args || {};\n    this.trainable = true;\n    this.built = false;\n    // Set model name.\n    this.name = args.name != null ? args.name : getUid('sequential_');\n    // Add to the model any layers passed to the constructor.\n    if (args.layers != null) {\n      for (const layer of args.layers) {\n        this.add(layer);\n      }\n    }\n  }\n  // Helper function to Sequential.add  Throws if the new output shape will be\n  // invalid.\n  checkShape(layer) {\n    const shape = layer.inboundNodes[0].outputTensors[0].shape;\n    if (shape.some(x => x < 0)) {\n      throw new ValueError('Negative dimension size caused by adding layer ' + `${layer.name} with input shape [` + `${layer.inboundNodes[0].inputTensors[0].shape}]`);\n    }\n  }\n  /**\n   * Adds a layer instance on top of the layer stack.\n   *\n   * ```js\n   *  const model = tf.sequential();\n   *  model.add(tf.layers.dense({units: 8, inputShape: [1]}));\n   *  model.add(tf.layers.dense({units: 4, activation: 'relu6'}));\n   *  model.add(tf.layers.dense({units: 1, activation: 'relu6'}));\n   *  // Note that the untrained model is random at this point.\n   *  model.predict(tf.randomNormal([10, 1])).print();\n   * ```\n   * @param layer Layer instance.\n   *\n   * @exception ValueError In case the `layer` argument does not know its\n   * input shape.\n   * @exception ValueError In case the `layer` argument has multiple output\n   *   tensors, or is already connected somewhere else (forbidden in\n   *   `Sequential` models).\n   *\n   * @doc {heading: 'Models', subheading: 'Classes'}\n   */\n  add(layer) {\n    const isLayerModelInstance = layer instanceof Sequential || layer instanceof LayersModel;\n    let modelLayer;\n    if (isLayerModelInstance) {\n      modelLayer = layer;\n      if (modelLayer.outputs.length !== 1) {\n        throw new ValueError('All layers in a Sequential model ' + 'should have a single output tensor. ' + 'For multi-output layers, ' + 'use the functional API.');\n      }\n      if (modelLayer.inputs.length !== 1) {\n        throw new ValueError('All layers in a Sequential model ' + 'should have a single input tensor. ' + 'For multi-input layers, ' + 'use the functional API.');\n      }\n    }\n    if (this.outputs.length === 0) {\n      // first layer in model: check that it is an input layer\n      if (layer.inboundNodes.length === 0) {\n        // create an input layer\n        if (layer.batchInputShape == null) {\n          throw new ValueError('The first layer in a Sequential model must ' + 'get an `inputShape` or `batchInputShape` argument.');\n        }\n        // Instantiate the input layer.\n        const x = Input({\n          batchShape: layer.batchInputShape,\n          dtype: layer.dtype,\n          name: layer.name + '_input'\n        });\n        // This will build the current layer and create the node connecting\n        // the current layer to the input layer we just created.\n        layer.apply(x);\n      }\n      if (isLayerModelInstance) {\n        this.outputs = modelLayer.outputs;\n        this.inputs = modelLayer.inputs;\n      } else {\n        if (layer.inboundNodes.length !== 1) {\n          throw new ValueError('A layer added to a Sequential model must not already be ' + `connected somewhere else. LayersModel received layer ${layer.name} ` + `which has ${layer.inboundNodes.length} pre-existing inbound ` + 'connections.');\n        }\n        if (layer.inboundNodes[0].outputTensors.length !== 1) {\n          throw new ValueError('All layers in a Sequential model ' + 'should have a single output tensor. ' + 'For multi-output layers, ' + 'use the functional API.');\n        }\n        this.checkShape(layer);\n        this.outputs = [layer.inboundNodes[0].outputTensors[0]];\n        this.inputs = getSourceInputs(this.outputs[0]);\n      }\n      this.inboundNodes = [];\n      // We create an input node, which we will keep updated\n      // as we add more layers.\n      // (This call has side effects.)\n      // tslint:disable-next-line:no-unused-expression\n      new Node({\n        outboundLayer: this,\n        inboundLayers: [],\n        nodeIndices: [],\n        tensorIndices: [],\n        inputTensors: this.inputs,\n        outputTensors: this.outputs,\n        // no model-level masking for now\n        inputMasks: generic_utils.pyListRepeat(null, this.inputs.length),\n        outputMasks: [null],\n        inputShapes: this.inputs.map(x => x.shape),\n        outputShapes: this.outputs[0].shape\n      });\n    } else {\n      const outputTensor = layer.apply(this.outputs[0]);\n      if (Array.isArray(outputTensor)) {\n        throw new TypeError('All layers in a Sequential model ' + 'should have a single output tensor. ' + 'For multi-output layers, ' + 'use the functional API.');\n      }\n      this.checkShape(layer);\n      this.outputs = [outputTensor];\n      // update self.inbound_nodes\n      this.inboundNodes[0].outputTensors = this.outputs;\n      this.inboundNodes[0].outputShapes = [this.outputs[0].shape];\n    }\n    this.layers.push(layer);\n    this.built = false;\n  }\n  /**\n   * Removes the last layer in the model.\n   *\n   * @exception TypeError if there are no layers in the model.\n   */\n  pop() {\n    if (this.layers.length === 0) {\n      throw new TypeError('There are no layers in the model.');\n    }\n    this.layers.pop();\n    if (this.layers.length === 0) {\n      this.outputs = [];\n      this.inboundNodes = [];\n      this.outboundNodes = [];\n    } else {\n      const lastLayerIndex = this.layers.length - 1;\n      this.layers[lastLayerIndex].outboundNodes = [];\n      this.outputs = [this.layers[lastLayerIndex].output];\n      // update self.inbound_nodes\n      this.inboundNodes[0].outputTensors = this.outputs;\n      this.inboundNodes[0].outputShapes = [this.outputs[0].shape];\n    }\n  }\n  call(inputs, kwargs) {\n    if (this.model == null) {\n      this.build();\n    }\n    return this.model.call(inputs, kwargs);\n  }\n  build(inputShape) {\n    // Call `getExactlyOneShape` without using its return value,\n    // to verify that exactly one input shape is provided.\n    getExactlyOneShape(inputShape);\n    if (this.inputs.length === 0 || this.outputs.length === 0) {\n      throw new TypeError('Sequential model cannot be built: model is empty.' + ' Add some layers first.');\n    }\n    // actually create the model\n    this.model = new LayersModel({\n      inputs: this.inputs,\n      outputs: this.outputs[0],\n      name: this.name + '_model'\n    });\n    this.model.trainable = this.trainable;\n    // mirror model attributes\n    this.supportsMasking = this.model.supportsMasking;\n    // TODO(michaelterry): Add caches\n    this.inputLayers = this.model.inputLayers;\n    this.inputLayersNodeIndices = this.model.inputLayersNodeIndices;\n    this.inputLayersTensorIndices = this.model.inputLayersTensorIndices;\n    this.outputLayers = this.model.outputLayers;\n    this.outputLayersNodeIndices = this.model.outputLayersNodeIndices;\n    this.outputLayersTensorIndices = this.model.outputLayersTensorIndices;\n    this.nodesByDepth = this.model.nodesByDepth;\n    this.containerNodes = this.model.containerNodes;\n    this.outputNames = this.model.outputNames;\n    this.inputNames = this.model.inputNames;\n    // TODO(michaelterry): Add feedInputNames, feedInputs, if needed.\n    // TODO(michaelterry): Add callbackModel if needed.\n    this.built = true;\n  }\n  countParams() {\n    if (!this.built) {\n      this.build();\n    }\n    return super.countParams();\n  }\n  /**\n   * Print a text summary of the Sequential model's layers.\n   *\n   * The summary includes\n   * - Name and type of all layers that comprise the model.\n   * - Output shape(s) of the layers\n   * - Number of weight parameters of each layer\n   * - The total number of trainable and non-trainable parameters of the\n   * model.\n   *\n   * ```js\n   * const model = tf.sequential();\n   * model.add(\n   *     tf.layers.dense({units: 100, inputShape: [10], activation: 'relu'}));\n   * model.add(tf.layers.dense({units: 1, activation: 'sigmoid'}));\n   *\n   * model.summary();\n   * ```\n   *\n   * @param lineLength Custom line length, in number of characters.\n   * @param positions Custom widths of each of the columns, as either\n   *   fractions of `lineLength` (e.g., `[0.5, 0.75, 1]`) or absolute number\n   *   of characters (e.g., `[30, 50, 65]`). Each number corresponds to\n   *   right-most (i.e., ending) position of a column.\n   * @param printFn Custom print function. Can be used to replace the default\n   *   `console.log`. For example, you can use `x => {}` to mute the printed\n   *   messages in the console.\n   *\n   * @doc {heading: 'Models', subheading: 'Classes'}\n   */\n  summary(lineLength, positions, printFn = console.log) {\n    if (!this.built) {\n      this.build();\n    }\n    super.summary(lineLength, positions, printFn);\n  }\n  /**\n   * Sets the weights of the model.\n   *\n   * @param weights Should be a list of Tensors with shapes and types matching\n   *   the output of `model.getWeights()`.\n   */\n  setWeights(weights) {\n    if (this.model == null) {\n      this.build();\n    }\n    this.model.setWeights(weights);\n  }\n  /**\n   * Returns the loss value & metrics values for the model in test mode.\n   *\n   * Loss and metrics are specified during `compile()`, which needs to happen\n   * before calls to `evaluate()`.\n   *\n   * Computation is done in batches.\n   *\n   * ```js\n   * const model = tf.sequential({\n   *   layers: [tf.layers.dense({units: 1, inputShape: [10]})]\n   * });\n   * model.compile({optimizer: 'sgd', loss: 'meanSquaredError'});\n   * const result = model.evaluate(tf.ones([8, 10]), tf.ones([8, 1]), {\n   *   batchSize: 4,\n   * });\n   * result.print();\n   * ```\n   *\n   * @param x `tf.Tensor` of test data, or an `Array` of `tf.Tensor`s if the\n   * model has multiple inputs.\n   * @param y `tf.Tensor` of target data, or an `Array` of `tf.Tensor`s if the\n   * model has multiple outputs.\n   * @param args A `ModelEvaluateConfig`, containing optional fields.\n   *\n   * @return `Scalar` test loss (if the model has a single output and no\n   *   metrics) or `Array` of `Scalar`s (if the model has multiple outputs\n   *   and/or metrics). The attribute `model.metricsNames`\n   *   will give you the display labels for the scalar outputs.\n   *\n   * @doc {heading: 'Models', subheading: 'Classes'}\n   */\n  evaluate(x, y, args = {}) {\n    if (!this.built) {\n      throw new RuntimeError('The model needs to be compiled before being used.');\n    }\n    return this.model.evaluate(x, y, args);\n  }\n  // TODO(cais): Add code snippet below once real dataset objects are\n  //   available.\n  /**\n   * Evaluate model using a dataset object.\n   *\n   * Note: Unlike `evaluate()`, this method is asynchronous (`async`).\n   *\n   * @param dataset A dataset object. Its `iterator()` method is expected\n   *   to generate a dataset iterator object, the `next()` method of which\n   *   is expected to produce data batches for evaluation. The return value\n   *   of the `next()` call ought to contain a boolean `done` field and a\n   *   `value` field. The `value` field is expected to be an array of two\n   *   `tf.Tensor`s or an array of two nested `tf.Tensor` structures. The former\n   *   case is for models with exactly one input and one output (e.g.\n   *   a sequential model). The latter case is for models with multiple\n   *   inputs and/or multiple outputs. Of the two items in the array, the\n   *   first is the input feature(s) and the second is the output target(s).\n   * @param args A configuration object for the dataset-based evaluation.\n   * @returns Loss and metric values as an Array of `Scalar` objects.\n   *\n   * @doc {heading: 'Models', subheading: 'Classes'}\n   */\n  async evaluateDataset(dataset, args) {\n    if (!this.built) {\n      throw new RuntimeError('The model needs to be compiled before being used.');\n    }\n    return this.model.evaluateDataset(dataset, args);\n  }\n  /**\n   * Generates output predictions for the input samples.\n   *\n   * Computation is done in batches.\n   *\n   * Note: the \"step\" mode of predict() is currently not supported.\n   *   This is because the TensorFlow.js core backend is imperative only.\n   *\n   * ```js\n   * const model = tf.sequential({\n   *   layers: [tf.layers.dense({units: 1, inputShape: [10]})]\n   * });\n   * model.predict(tf.ones([2, 10])).print();\n   * ```\n   *\n   * @param x The input data, as a Tensor, or an `Array` of `tf.Tensor`s if\n   *   the model has multiple inputs.\n   * @param conifg A `ModelPredictConfig` object containing optional fields.\n   *\n   * @return `tf.Tensor`(s) of predictions.\n   *\n   * @exception ValueError In case of mismatch between the provided input data\n   *   and the model's expectations, or in case a stateful model receives a\n   *   number of samples that is not a multiple of the batch size.\n   *\n   * @doc {heading: 'Models', subheading: 'Classes'}\n   */\n  predict(x, args = {}) {\n    if (this.model == null) {\n      this.build();\n    }\n    return this.model.predict(x, args);\n  }\n  /**\n   * Returns predictions for a single batch of samples.\n   *\n   * @param x: Input samples, as a Tensor, or list of Tensors (if the model\n   *   has multiple inputs).\n   * @return Tensor(s) of predictions\n   */\n  predictOnBatch(x) {\n    if (this.model == null) {\n      this.build();\n    }\n    return this.model.predictOnBatch(x);\n  }\n  /**\n   * See `LayersModel.compile`.\n   *\n   * @param args\n   */\n  compile(args) {\n    this.build();\n    this.model.compile(args);\n    this.optimizer_ = this.model.optimizer;\n    // tslint:disable-next-line:no-any\n    this.isOptimizerOwned = this.model.isOptimizerOwned;\n    this.loss = this.model.loss;\n    this.metrics = this.model.metrics;\n    // TODO(cais): Add this.lossWeights, this.sampleWeightMode,\n    //   this.weightedMetrics, this.targets.\n    this.metricsTensors = this.model.metricsTensors;\n    this.metricsNames = this.model.metricsNames;\n    // TODO(cais): Add sampleWeights.\n  }\n  get optimizer() {\n    return this.model == null ? undefined : this.model.optimizer;\n  }\n  set optimizer(optimizer) {\n    this.model.optimizer = optimizer;\n  }\n  /**\n   * Trains the model for a fixed number of epochs (iterations on a dataset).\n   *\n   * ```js\n   * const model = tf.sequential({\n   *   layers: [tf.layers.dense({units: 1, inputShape: [10]})]\n   * });\n   * model.compile({optimizer: 'sgd', loss: 'meanSquaredError'});\n   * const history = await model.fit(tf.ones([8, 10]), tf.ones([8, 1]), {\n   *   batchSize: 4,\n   *   epochs: 3\n   * });\n   * console.log(history.history.loss[0]);\n   * ```\n   *\n   * @param x `tf.Tensor` of training data, or an array of `tf.Tensor`s if the\n   * model has multiple inputs. If all inputs in the model are named, you can\n   * also pass a dictionary mapping input names to `tf.Tensor`s.\n   * @param y `tf.Tensor` of target (label) data, or an array of `tf.Tensor`s if\n   * the model has multiple outputs. If all outputs in the model are named, you\n   *  can also pass a dictionary mapping output names to `tf.Tensor`s.\n   * @param args  A `ModelFitConfig`, containing optional fields.\n   *\n   * @return A `History` instance. Its `history` attribute contains all\n   *   information collected during training.\n   *\n   * @exception ValueError In case of mismatch between the provided input data\n   *   and what the model expects.\n   *\n   * @doc {heading: 'Models', subheading: 'Classes'}\n   */\n  async fit(x, y, args = {}) {\n    if (!this.built) {\n      throw new RuntimeError('The model needs to be compiled before ' + 'being used.');\n    }\n    return this.model.fit(x, y, args);\n  }\n  /**\n   * Trains the model using a dataset object.\n   *\n   * ```js\n   * const xArray = [\n   *   [1, 1, 1, 1, 1, 1, 1, 1, 1],\n   *   [1, 1, 1, 1, 1, 1, 1, 1, 1],\n   *   [1, 1, 1, 1, 1, 1, 1, 1, 1],\n   *   [1, 1, 1, 1, 1, 1, 1, 1, 1],\n   * ];\n   * const yArray = [1, 1, 1, 1];\n   * // Create a dataset from the JavaScript array.\n   * const xDataset = tf.data.array(xArray);\n   * const yDataset = tf.data.array(yArray);\n   * // Zip combines the `x` and `y` Datasets into a single Dataset, the\n   * // iterator of which will return an object containing of two tensors,\n   * // corresponding to `x` and `y`.  The call to `batch(4)` will bundle\n   * // four such samples into a single object, with the same keys now pointing\n   * // to tensors that hold 4 examples, organized along the batch dimension.\n   * // The call to `shuffle(4)` causes each iteration through the dataset to\n   * // happen in a different order.  The size of the shuffle window is 4.\n   * const xyDataset = tf.data.zip({xs: xDataset, ys: yDataset})\n   *     .batch(4)\n   *     .shuffle(4);\n   * const model = tf.sequential({\n   *   layers: [tf.layers.dense({units: 1, inputShape: [9]})]\n   * });\n   * model.compile({optimizer: 'sgd', loss: 'meanSquaredError'});\n   * const history = await model.fitDataset(xyDataset, {\n   *   epochs: 4,\n   *   callbacks: {onEpochEnd: (epoch, logs) => console.log(logs.loss)}\n   * });\n   * ```\n   *\n   * @param dataset A dataset object. Its `iterator()` method is expected to\n   *   generate a dataset iterator object, the `next()` method of which is\n   *   expected to produce data batches for evaluation. The return value of the\n   *   `next()` call ought to contain a boolean `done` field and a `value`\n   *   field.\n   *\n   *   The `value` field is expected to be an object of with fields\n   *   `xs` and `ys`, which point to the feature tensor and the target tensor,\n   *   respectively. This case is for models with exactly one input and one\n   *   output (e.g. a sequential model). For example:\n   *   ```js\n   *   {value: {xs: xsTensor, ys: ysTensor}, done: false}\n   *   ```\n   *\n   *   If the model has multiple inputs, the `xs` field of `value` should\n   *   be an object mapping input names to their respective feature tensors.\n   *   For example:\n   *   ```js\n   *   {\n   *     value: {\n   *       xs: {\n   *         input_1: xsTensor1,\n   *         input_2: xsTensor2\n   *       },\n   *       ys: ysTensor\n   *     },\n   *     done: false\n   *   }\n   *   ```\n   *   If the model has multiple outputs, the `ys` field of `value` should\n   *   be an object mapping output names to their respective target tensors.\n   *   For example:\n   *   ```js\n   *   {\n   *     value: {\n   *       xs: xsTensor,\n   *       ys: {\n   *         output_1: ysTensor1,\n   *         output_2: ysTensor2\n   *       },\n   *     },\n   *     done: false\n   *   }\n   *   ```\n   * @param args A `ModelFitDatasetArgs`, containing optional fields.\n   *\n   * @return A `History` instance. Its `history` attribute contains all\n   *   information collected during training.\n   *\n   * @doc {heading: 'Models', subheading: 'Classes', ignoreCI: true}\n   */\n  async fitDataset(dataset, args) {\n    if (!this.built) {\n      throw new RuntimeError('The model needs to be compiled before ' + 'being used.');\n    }\n    return this.model.fitDataset(dataset, args);\n  }\n  /**\n   * Runs a single gradient update on a single batch of data.\n   *\n   * This method differs from `fit()` and `fitDataset()` in the following\n   * regards:\n   *   - It operates on exactly one batch of data.\n   *   - It returns only the loss and metric values, instead of\n   *     returning the batch-by-batch loss and metric values.\n   *   - It doesn't support fine-grained options such as verbosity and\n   *     callbacks.\n   *\n   * @param x Input data. It could be one of the following:\n   *   - A `tf.Tensor`, or an Array of `tf.Tensor`s (in case the model has\n   *     multiple inputs).\n   *   - An Object mapping input names to corresponding `tf.Tensor` (if the\n   *     model has named inputs).\n   * @param y Target data. It could be either a `tf.Tensor` or multiple\n   *   `tf.Tensor`s. It should be consistent with `x`.\n   * @returns Training loss or losses (in case the model has\n   *   multiple outputs), along with metrics (if any), as numbers.\n   *\n   * @doc {heading: 'Models', subheading: 'Classes'}\n   */\n  async trainOnBatch(x, y) {\n    return this.model.trainOnBatch(x, y);\n  }\n  /* See parent class for JsDoc */\n  /** @nocollapse */\n  static fromConfig(cls, config, customObjects = {}, fastWeightInit = false) {\n    let configArray;\n    let extraModelConfig = {};\n    if (config instanceof Array) {\n      if (!(config[0].className != null) || config[0]['className'] === 'Merge') {\n        throw new ValueError('Legacy serialization format not supported yet.');\n      }\n      configArray = config;\n    } else {\n      util.assert(config['layers'] != null, () => `When the config data for a Sequential model is not an Array, ` + `it must be an Object that contains the 'layers' field.`);\n      configArray = config['layers'];\n      delete config['layers'];\n      extraModelConfig = config;\n    }\n    const model = new cls(extraModelConfig);\n    if (!(model instanceof Sequential)) {\n      throw new NotImplementedError(`Sequential.fromConfig called on non-Sequential input: ${model}`);\n    }\n    for (const conf of configArray) {\n      const customObjects = undefined;\n      const layer = deserialize(conf, customObjects, fastWeightInit);\n      if (fastWeightInit) {\n        layer.setFastWeightInitDuringBuild(true);\n      }\n      model.add(layer);\n    }\n    return model;\n  }\n  /**\n   * Setter used for force stopping of LayersModel.fit() (i.e., training).\n   *\n   * Example:\n   *\n   * ```js\n   * const model = tf.sequential();\n   * model.add(tf.layers.dense({units: 1, inputShape: [10]}));\n   * model.compile({loss: 'meanSquaredError', optimizer: 'sgd'});\n   * const xs = tf.ones([8, 10]);\n   * const ys = tf.zeros([8, 1]);\n   *\n   * const history = await model.fit(xs, ys, {\n   *   epochs: 10,\n   *   callbacks: {\n   *     onEpochEnd: async (epoch, logs) => {\n   *       if (epoch === 2) {\n   *         model.stopTraining = true;\n   *       }\n   *     }\n   *   }\n   * });\n   *\n   * // There should be only 3 values in the loss array, instead of 10 values,\n   * // due to the stopping after 3 epochs.\n   * console.log(history.history.loss);\n   * ```\n   */\n  set stopTraining(stop) {\n    // TODO(cais): When refactoring to remove the composition pattern happens,\n    // remove this method overriding.\n    if (this.model == null) {\n      throw new ValueError('Cannot set the stopTraining property of a sequential model before ' + 'it is compiled.');\n    }\n    this.model.stopTraining = stop;\n  }\n  get stopTraining() {\n    if (this.model == null) {\n      throw new ValueError('Cannot get the stopTraining property of a sequential model before ' + 'it is compiled.');\n    }\n    return this.model.stopTraining;\n  }\n  // TODO(cais): Override get trainableWeights() here\n  // tslint:disable-next-line:no-any\n  getConfig() {\n    // NOTE(cais): We override the return type of getConfig() to `any` here,\n    //   because the `Sequential` class is a special case among `Container`\n    //   subtypes in that its getConfig() method returns an Array (not a\n    //   dict).\n    const layers = [];\n    for (const layer of this.layers) {\n      const dict = {};\n      dict['className'] = layer.getClassName();\n      dict['config'] = layer.getConfig();\n      layers.push(dict);\n    }\n    return {\n      name: this.name,\n      layers\n    };\n  }\n}\n/** @nocollapse */\nSequential.className = 'Sequential';\nexport { Sequential };\nserialization.registerClass(Sequential);","map":{"version":3,"names":["dispose","io","serialization","util","getUid","Input","getSourceInputs","Node","LayersModel","NotImplementedError","RuntimeError","ValueError","deserialize","generic_utils","convertPythonicToTs","getExactlyOneShape","modelFromJSON","modelAndWeightsConfig","customObjects","modelTopology","tsConfig","model","weightsManifest","weightValues","loadWeights","pathPrefix","weights","map","weight","originalName","uniqueWeightValues","loadLayersModel","pathOrIOHandler","options","handlers","getLoadHandlers","length","push","browserHTTPRequest","loadLayersModelFromIOHandler","undefined","handler","load","artifacts","strict","fastWeightInit","weightData","weightSpecs","trainingConfig","loadTrainingConfig","userDefinedMetadata","setUserDefinedMetadata","modelWeights","optimizerWeights","decodeModelAndOptimizerWeights","optimizer","setWeights","w","tensor","specs","name2Tensor","decodeWeights","forEach","spec","group","name","Sequential","constructor","args","inputs","outputs","trainable","built","layers","layer","add","checkShape","shape","inboundNodes","outputTensors","some","x","inputTensors","isLayerModelInstance","modelLayer","batchInputShape","batchShape","dtype","apply","outboundLayer","inboundLayers","nodeIndices","tensorIndices","inputMasks","pyListRepeat","outputMasks","inputShapes","outputShapes","outputTensor","Array","isArray","TypeError","pop","outboundNodes","lastLayerIndex","output","call","kwargs","build","inputShape","supportsMasking","inputLayers","inputLayersNodeIndices","inputLayersTensorIndices","outputLayers","outputLayersNodeIndices","outputLayersTensorIndices","nodesByDepth","containerNodes","outputNames","inputNames","countParams","summary","lineLength","positions","printFn","console","log","evaluate","y","evaluateDataset","dataset","predict","predictOnBatch","compile","optimizer_","isOptimizerOwned","loss","metrics","metricsTensors","metricsNames","fit","fitDataset","trainOnBatch","fromConfig","cls","config","configArray","extraModelConfig","className","assert","conf","setFastWeightInitDuringBuild","stopTraining","stop","getConfig","dict","getClassName","registerClass"],"sources":["/Users/jonchen/Documents/HackPSU/tfjs-layers/src/models.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\n/* Original source keras/models.py */\n\nimport {dispose, io, NamedTensorMap, Optimizer, Scalar, serialization, Tensor, util} from '@tensorflow/tfjs-core';\n\nimport {getUid} from './backend/state';\nimport {History} from './base_callbacks';\nimport {Dataset} from './engine/dataset_stub';\nimport {Input} from './engine/input_layer';\nimport {getSourceInputs, Layer, Node, SymbolicTensor} from './engine/topology';\nimport {LayersModel, ModelCompileArgs, ModelEvaluateArgs} from './engine/training';\nimport {ModelEvaluateDatasetArgs, ModelFitDatasetArgs} from './engine/training_dataset';\nimport {ModelFitArgs} from './engine/training_tensors';\nimport {NotImplementedError, RuntimeError, ValueError} from './errors';\nimport {Shape} from './keras_format/common';\nimport {TrainingConfig} from './keras_format/training_config';\nimport {PyJsonDict} from './keras_format/types';\nimport {deserialize} from './layers/serialization';\nimport {Kwargs, NamedTensor} from './types';\nimport * as generic_utils from './utils/generic_utils';\nimport {convertPythonicToTs} from './utils/serialization_utils';\nimport {getExactlyOneShape} from './utils/types_utils';\n\n/**\n * Parses a JSON model configuration file and returns a model instance.\n *\n * ```js\n * // This example shows how to serialize a model using `toJSON()` and\n * // deserialize it as another model using `tf.models.modelFromJSON()`.\n * // Note: this example serializes and deserializes only the topology\n * // of the model; the weights of the loaded model will be different\n * // from those of the the original model, due to random weight\n * // initialization.\n * // To load the topology and weights of a model, use `tf.loadLayersModel()`.\n * const model1 = tf.sequential();\n * model1.add(tf.layers.repeatVector({inputShape: [2], n: 4}));\n * // Serialize `model1` as a JSON object.\n * const model1JSON = model1.toJSON(null, false);\n * model1.summary();\n *\n * const model2 = await tf.models.modelFromJSON(model1JSON);\n * model2.summary();\n * ```\n *\n *  @param modelAndWeightsConfig JSON object or string encoding a model and\n *       weights configuration. It can also be only the topology JSON of the\n *       model, in which case the weights will not be loaded.\n *  @param custom_objects Optional dictionary mapping names\n *       (strings) to custom classes or functions to be\n *       considered during deserialization.\n * @returns A TensorFlow.js Layers `tf.LayersModel` instance (uncompiled).\n */\nexport async function modelFromJSON(\n    modelAndWeightsConfig: ModelAndWeightsConfig|PyJsonDict,\n    customObjects?: serialization.ConfigDict): Promise<LayersModel> {\n  if (!('modelTopology' in modelAndWeightsConfig)) {\n    modelAndWeightsConfig = {modelTopology: modelAndWeightsConfig};\n  }\n  modelAndWeightsConfig = modelAndWeightsConfig as ModelAndWeightsConfig;\n\n  let modelTopology = modelAndWeightsConfig.modelTopology;\n  if (modelTopology['model_config'] != null) {\n    // If the model-topology JSON contains a 'model_config' field, then it is\n    // a full model JSON (e.g., from `keras.Model.save()`), which contains\n    // not only the model's architecture in its 'model_config' field, but\n    // additional information such as the model's optimizer. We use only the\n    // 'model_config' field currently.\n    modelTopology = modelTopology['model_config'] as PyJsonDict;\n  }\n  const tsConfig =\n      convertPythonicToTs(modelTopology) as serialization.ConfigDict;\n  const model = deserialize(tsConfig, customObjects) as LayersModel;\n\n  if (modelAndWeightsConfig.weightsManifest != null) {\n    // Load the weight values keyed by the original tensor names in the model\n    // file that was loaded.  These should match the keys of the weight\n    // manifest.\n    const weightValues = await io.loadWeights(\n        modelAndWeightsConfig.weightsManifest, modelAndWeightsConfig.pathPrefix,\n        model.weights.map(weight => weight.originalName));\n\n    // Map the weights to the unique tensor names generated during model loading\n    const uniqueWeightValues: NamedTensorMap = {};\n    for (const weight of model.weights) {\n      uniqueWeightValues[weight.originalName] =\n          weightValues[weight.originalName];\n    }\n\n    model.loadWeights(uniqueWeightValues);\n    // Dispose temporary weight values.\n    dispose(weightValues);\n  }\n  return model;\n}\n\n/**\n * Options for loading a saved mode in TensorFlow.js format.\n */\nexport interface ModelAndWeightsConfig {\n  /**\n   * A JSON object or JSON string containing the model config.\n   *\n   * This can be either of the following two formats:\n   *   - A model archiecture-only config,  i.e., a format consistent with the\n   *     return value of`keras.Model.to_json()`.\n   *   - A full model config, containing not only model architecture, but also\n   *     training options and state, i.e., a format consistent with the return\n   *     value of `keras.models.save_model()`.\n   */\n  modelTopology: PyJsonDict;\n\n  /**\n   * A weights manifest in TensorFlow.js format.\n   */\n  weightsManifest?: io.WeightsManifestConfig;\n\n  /**\n   * Path to prepend to the paths in `weightManifest` before fetching.\n   *\n   * The path may optionally end in a slash ('/').\n   */\n  pathPrefix?: string;\n}\n\n// TODO(nielsene): Remove after: https://github.com/tensorflow/tfjs/issues/400\nexport interface ModelPredictArgs {\n  /**\n   * Optional. Batch size (Integer). If unspecified, it will default to 32.\n   */\n  batchSize?: number;\n\n  /**\n   * Optional. Verbosity mode. Defaults to false.\n   */\n  verbose?: boolean;\n}\n\n/**\n * Load a model composed of Layer objects, including its topology and optionally\n * weights. See the Tutorial named \"How to import a Keras Model\" for usage\n * examples.\n *\n * This method is applicable to:\n *\n * 1. Models created with the `tf.layers.*`, `tf.sequential`, and\n * `tf.model` APIs of TensorFlow.js and later saved with the\n * `tf.LayersModel.save` method.\n * 2. Models converted from Keras or TensorFlow tf.keras using the\n * [tensorflowjs_converter](https://github.com/tensorflow/tfjs/tree/master/tfjs-converter).\n *\n * This mode is *not* applicable to TensorFlow `SavedModel`s or their converted\n * forms. For those models, use `tf.loadGraphModel`.\n *\n * Example 1. Load a model from an HTTP server.\n *\n * ```js\n * const model = await tf.loadLayersModel(\n *     'https://storage.googleapis.com/tfjs-models/tfjs/iris_v1/model.json');\n * model.summary();\n * ```\n *\n * Example 2: Save `model`'s topology and weights to browser [local\n * storage](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage);\n * then load it back.\n *\n * ```js\n * const model = tf.sequential(\n *     {layers: [tf.layers.dense({units: 1, inputShape: [3]})]});\n * console.log('Prediction from original model:');\n * model.predict(tf.ones([1, 3])).print();\n *\n * const saveResults = await model.save('localstorage://my-model-1');\n *\n * const loadedModel = await tf.loadLayersModel('localstorage://my-model-1');\n * console.log('Prediction from loaded model:');\n * loadedModel.predict(tf.ones([1, 3])).print();\n * ```\n *\n * Example 3. Saving `model`'s topology and weights to browser\n * [IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API);\n * then load it back.\n *\n * ```js\n * const model = tf.sequential(\n *     {layers: [tf.layers.dense({units: 1, inputShape: [3]})]});\n * console.log('Prediction from original model:');\n * model.predict(tf.ones([1, 3])).print();\n *\n * const saveResults = await model.save('indexeddb://my-model-1');\n *\n * const loadedModel = await tf.loadLayersModel('indexeddb://my-model-1');\n * console.log('Prediction from loaded model:');\n * loadedModel.predict(tf.ones([1, 3])).print();\n * ```\n *\n * Example 4. Load a model from user-selected files from HTML\n * [file input\n * elements](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file).\n *\n * ```js\n * // Note: this code snippet will not work without the HTML elements in the\n * //   page\n * const jsonUpload = document.getElementById('json-upload');\n * const weightsUpload = document.getElementById('weights-upload');\n *\n * const model = await tf.loadLayersModel(\n *     tf.io.browserFiles([jsonUpload.files[0], weightsUpload.files[0]]));\n * ```\n *\n * @param pathOrIOHandler Can be either of the two formats\n *   1. A string path to the `ModelAndWeightsConfig` JSON describing\n *      the model in the canonical TensorFlow.js format. For file://\n *      (tfjs-node-only), http:// and https:// schemas, the path can be\n *      either absolute or relative. The content of the JSON file is assumed to\n *      be a JSON object with the following fields and values:\n *      - 'modelTopology': A JSON object that can be either of:\n *        1. a model architecture JSON consistent with the format of the return\n *            value of `keras.Model.to_json()`\n *        2. a full model JSON in the format of `keras.models.save_model()`.\n *      - 'weightsManifest': A TensorFlow.js weights manifest.\n *      See the Python converter function `save_model()` for more details.\n *      It is also assumed that model weights can be accessed from relative\n *      paths described by the `paths` fields in weights manifest.\n *   2. A `tf.io.IOHandler` object that loads model artifacts with its `load`\n *      method.\n * @param options Optional configuration arguments for the model loading,\n *   including:\n *   - `strict`: Require that the provided weights exactly match those required\n *     by the layers.  Default true.  Passing false means that both extra\n *     weights and missing weights will be silently ignored.\n *   - `onProgress`: A progress callback of the form:\n *     `(fraction: number) => void`. This callback can be used to monitor the\n *     model-loading process.\n * @returns A `Promise` of `tf.LayersModel`, with the topology and weights\n *     loaded.\n *\n * @doc {heading: 'Models', subheading: 'Loading'}\n */\nexport async function loadLayersModel(\n    pathOrIOHandler: string|io.IOHandler,\n    options?: io.LoadOptions): Promise<LayersModel> {\n  if (options == null) {\n    options = {};\n  }\n  if (typeof pathOrIOHandler === 'string') {\n    const handlers = io.getLoadHandlers(pathOrIOHandler, options);\n    if (handlers.length === 0) {\n      // For backward compatibility: if no load handler can be found,\n      // assume it is a relative http path.\n      // TODO(cais): Reformat the args into a single `LoadOptions` once the core\n      // is refactored.\n      handlers.push(io.browserHTTPRequest(pathOrIOHandler, options));\n    } else if (handlers.length > 1) {\n      throw new ValueError(\n          `Found more than one (${handlers.length}) load handlers for ` +\n          `URL '${pathOrIOHandler}'`);\n    }\n    pathOrIOHandler = handlers[0];\n  }\n  return loadLayersModelFromIOHandler(pathOrIOHandler, undefined, options);\n}\n\n/**\n * Load a model and optionally its weights, using an IOHandler object.\n *\n * @param handler The instance of `IOHandler` to be used during the model\n *   loading.\n * @param customObjects Any optional custom objects to be used during model\n *   loading.\n * @param strict Whether the weight loading will be done in strict mode.\n *   Default: `true`.\n */\nexport async function loadLayersModelFromIOHandler(\n    handler: io.IOHandler, customObjects?: serialization.ConfigDict,\n    options?: io.LoadOptions): Promise<LayersModel> {\n  if (options == null) {\n    options = {};\n  }\n  if (handler.load == null) {\n    throw new ValueError(\n        'Cannot proceed with model loading because the IOHandler provided ' +\n        'does not have the `load` method implemented.');\n  }\n  const artifacts = await handler.load();\n  let modelTopology = artifacts.modelTopology as PyJsonDict;\n  if (modelTopology['model_config'] != null) {\n    modelTopology = modelTopology['model_config'] as PyJsonDict;\n  }\n\n  const strict = options.strict == null ? true : options.strict;\n  // If weights are provided and the weight-loading mode is strict, use\n  // fast weight initialization. This skips costly initializers such as\n  // 'orthogonal' and saves unnecessary computation in cases where\n  // the initialized weight values will immediately be overwritten by\n  // loaded weight values.\n  const fastWeightInit =\n      artifacts.weightData != null && artifacts.weightSpecs != null && strict;\n  const model =\n      deserialize(\n          convertPythonicToTs(modelTopology) as serialization.ConfigDict,\n          customObjects, fastWeightInit) as LayersModel;\n\n  const trainingConfig = artifacts.trainingConfig as TrainingConfig;\n  if (trainingConfig != null) {\n    model.loadTrainingConfig(trainingConfig);\n  }\n  if (artifacts.userDefinedMetadata != null) {\n    model.setUserDefinedMetadata(artifacts.userDefinedMetadata);\n  }\n\n  // If weightData is present, load the weights into the model.\n  if (artifacts.weightData != null) {\n    // Loading weights requires weightSpecs.\n    if (artifacts.weightSpecs == null) {\n      throw new ValueError(\n          'LayersModel artifacts contains weight data, but not weight specs. ' +\n          'Therefore loading of weights cannot proceed.');\n    }\n\n    const {modelWeights, optimizerWeights} = decodeModelAndOptimizerWeights(\n        artifacts.weightData, artifacts.weightSpecs);\n    model.loadWeights(modelWeights, strict);\n\n    if (model.optimizer != null && optimizerWeights.length > 0) {\n      await model.optimizer.setWeights(optimizerWeights);\n    }\n\n    // Dispose temporary weight values.\n    dispose(modelWeights);\n    dispose(optimizerWeights.map(w => w.tensor));\n  }\n  return model;\n}\n\nfunction decodeModelAndOptimizerWeights(\n    weightData: io.WeightData, specs: io.WeightsManifestEntry[]):\n    {modelWeights: NamedTensorMap, optimizerWeights: NamedTensor[]} {\n  const name2Tensor = io.decodeWeights(weightData, specs);\n  const modelWeights: NamedTensorMap = {};\n  const optimizerWeights: NamedTensor[] = [];\n  specs.forEach(spec => {\n    if (spec.group === 'optimizer') {\n      optimizerWeights.push({name: spec.name, tensor: name2Tensor[spec.name]});\n    } else {\n      modelWeights[spec.name] = name2Tensor[spec.name];\n    }\n  });\n  return {modelWeights, optimizerWeights};\n}\n\n/**\n * Configuration for a Sequential model.\n */\nexport interface SequentialArgs {\n  /** Stack of layers for the model. */\n  layers?: Layer[];\n\n  /** The name of this model. */\n  name?: string;\n}\n\n/**\n * A model with a stack of layers, feeding linearly from one to the next.\n *\n * `tf.sequential` is a factory function that creates an instance of\n * `tf.Sequential`.\n *\n * ```js\n *  // Define a model for linear regression.\n *  const model = tf.sequential();\n *  model.add(tf.layers.dense({units: 1, inputShape: [1]}));\n *\n *  // Prepare the model for training: Specify the loss and the optimizer.\n *  model.compile({loss: 'meanSquaredError', optimizer: 'sgd'});\n *\n *  // Generate some synthetic data for training.\n *  const xs = tf.tensor2d([1, 2, 3, 4], [4, 1]);\n *  const ys = tf.tensor2d([1, 3, 5, 7], [4, 1]);\n *\n *  // Train the model using the data then do inference on a data point the\n *  // model hasn't seen:\n *  await model.fit(xs, ys);\n *  model.predict(tf.tensor2d([5], [1, 1])).print();\n * ```\n *\n * @doc {heading: 'Models', subheading: 'Classes'}\n */\nexport class Sequential extends LayersModel {\n  /** @nocollapse */\n  static override className = 'Sequential';\n  private model: LayersModel;\n  constructor(args?: SequentialArgs) {\n    super({inputs: [], outputs: []});\n    args = args || {};\n\n    this.trainable = true;\n    this.built = false;\n\n    // Set model name.\n    this.name = (args.name != null) ? args.name : getUid('sequential_');\n\n    // Add to the model any layers passed to the constructor.\n    if (args.layers != null) {\n      for (const layer of args.layers) {\n        this.add(layer);\n      }\n    }\n  }\n\n  // Helper function to Sequential.add  Throws if the new output shape will be\n  // invalid.\n  private checkShape(layer: Layer) {\n    const shape = layer.inboundNodes[0].outputTensors[0].shape;\n    if (shape.some(x => x < 0)) {\n      throw new ValueError(\n          'Negative dimension size caused by adding layer ' +\n          `${layer.name} with input shape [` +\n          `${layer.inboundNodes[0].inputTensors[0].shape}]`);\n    }\n  }\n\n  /**\n   * Adds a layer instance on top of the layer stack.\n   *\n   * ```js\n   *  const model = tf.sequential();\n   *  model.add(tf.layers.dense({units: 8, inputShape: [1]}));\n   *  model.add(tf.layers.dense({units: 4, activation: 'relu6'}));\n   *  model.add(tf.layers.dense({units: 1, activation: 'relu6'}));\n   *  // Note that the untrained model is random at this point.\n   *  model.predict(tf.randomNormal([10, 1])).print();\n   * ```\n   * @param layer Layer instance.\n   *\n   * @exception ValueError In case the `layer` argument does not know its\n   * input shape.\n   * @exception ValueError In case the `layer` argument has multiple output\n   *   tensors, or is already connected somewhere else (forbidden in\n   *   `Sequential` models).\n   *\n   * @doc {heading: 'Models', subheading: 'Classes'}\n   */\n  add(layer: Layer): void {\n    const isLayerModelInstance =\n        layer instanceof Sequential || layer instanceof LayersModel;\n    let modelLayer: LayersModel;\n    if (isLayerModelInstance) {\n      modelLayer = layer as LayersModel;\n      if (modelLayer.outputs.length !== 1) {\n        throw new ValueError(\n            'All layers in a Sequential model ' +\n            'should have a single output tensor. ' +\n            'For multi-output layers, ' +\n            'use the functional API.');\n      }\n      if (modelLayer.inputs.length !== 1) {\n        throw new ValueError(\n            'All layers in a Sequential model ' +\n            'should have a single input tensor. ' +\n            'For multi-input layers, ' +\n            'use the functional API.');\n      }\n    }\n\n    if (this.outputs.length === 0) {\n      // first layer in model: check that it is an input layer\n      if (layer.inboundNodes.length === 0) {\n        // create an input layer\n        if (layer.batchInputShape == null) {\n          throw new ValueError(\n              'The first layer in a Sequential model must ' +\n              'get an `inputShape` or `batchInputShape` argument.');\n        }\n        // Instantiate the input layer.\n        const x = Input({\n          batchShape: layer.batchInputShape,\n          dtype: layer.dtype,\n          name: layer.name + '_input'\n        });\n        // This will build the current layer and create the node connecting\n        // the current layer to the input layer we just created.\n        layer.apply(x);\n      }\n\n      if (isLayerModelInstance) {\n        this.outputs = modelLayer.outputs;\n        this.inputs = modelLayer.inputs;\n      } else {\n        if (layer.inboundNodes.length !== 1) {\n          throw new ValueError(\n              'A layer added to a Sequential model must not already be ' +\n              `connected somewhere else. LayersModel received layer ${\n                  layer.name} ` +\n              `which has ${layer.inboundNodes.length} pre-existing inbound ` +\n              'connections.');\n        }\n\n        if (layer.inboundNodes[0].outputTensors.length !== 1) {\n          throw new ValueError(\n              'All layers in a Sequential model ' +\n              'should have a single output tensor. ' +\n              'For multi-output layers, ' +\n              'use the functional API.');\n        }\n        this.checkShape(layer);\n        this.outputs = [layer.inboundNodes[0].outputTensors[0]];\n        this.inputs = getSourceInputs(this.outputs[0]);\n      }\n\n      this.inboundNodes = [];\n      // We create an input node, which we will keep updated\n      // as we add more layers.\n      // (This call has side effects.)\n      // tslint:disable-next-line:no-unused-expression\n      new Node({\n        outboundLayer: this,\n        inboundLayers: [],\n        nodeIndices: [],\n        tensorIndices: [],\n        inputTensors: this.inputs,\n        outputTensors: this.outputs,\n        // no model-level masking for now\n        inputMasks: generic_utils.pyListRepeat(null, this.inputs.length),\n        outputMasks: [null],\n        inputShapes: this.inputs.map(x => x.shape),\n        outputShapes: this.outputs[0].shape\n      });\n    } else {\n      const outputTensor = layer.apply(this.outputs[0]);\n      if (Array.isArray(outputTensor)) {\n        throw new TypeError(\n            'All layers in a Sequential model ' +\n            'should have a single output tensor. ' +\n            'For multi-output layers, ' +\n            'use the functional API.');\n      }\n      this.checkShape(layer);\n      this.outputs = [outputTensor as SymbolicTensor];\n      // update self.inbound_nodes\n      this.inboundNodes[0].outputTensors = this.outputs;\n      this.inboundNodes[0].outputShapes = [this.outputs[0].shape];\n    }\n\n    this.layers.push(layer);\n    this.built = false;\n  }\n\n  /**\n   * Removes the last layer in the model.\n   *\n   * @exception TypeError if there are no layers in the model.\n   */\n  pop(): void {\n    if (this.layers.length === 0) {\n      throw new TypeError('There are no layers in the model.');\n    }\n\n    this.layers.pop();\n    if (this.layers.length === 0) {\n      this.outputs = [];\n      this.inboundNodes = [];\n      this.outboundNodes = [];\n    } else {\n      const lastLayerIndex = this.layers.length - 1;\n      this.layers[lastLayerIndex].outboundNodes = [];\n      this.outputs = [this.layers[lastLayerIndex].output as SymbolicTensor];\n      // update self.inbound_nodes\n      this.inboundNodes[0].outputTensors = this.outputs;\n      this.inboundNodes[0].outputShapes = [this.outputs[0].shape];\n    }\n  }\n\n  override call(inputs: Tensor|Tensor[], kwargs: Kwargs): Tensor|Tensor[] {\n    if (this.model == null) {\n      this.build();\n    }\n    return this.model.call(inputs, kwargs);\n  }\n\n  override build(inputShape?: Shape|Shape[]) {\n    // Call `getExactlyOneShape` without using its return value,\n    // to verify that exactly one input shape is provided.\n    getExactlyOneShape(inputShape);\n\n    if (this.inputs.length === 0 || this.outputs.length === 0) {\n      throw new TypeError(\n          'Sequential model cannot be built: model is empty.' +\n          ' Add some layers first.');\n    }\n    // actually create the model\n    this.model = new LayersModel({\n      inputs: this.inputs,\n      outputs: this.outputs[0],\n      name: this.name + '_model'\n    });\n    this.model.trainable = this.trainable;\n\n    // mirror model attributes\n    this.supportsMasking = this.model.supportsMasking;\n    // TODO(michaelterry): Add caches\n    this.inputLayers = this.model.inputLayers;\n    this.inputLayersNodeIndices = this.model.inputLayersNodeIndices;\n    this.inputLayersTensorIndices = this.model.inputLayersTensorIndices;\n    this.outputLayers = this.model.outputLayers;\n    this.outputLayersNodeIndices = this.model.outputLayersNodeIndices;\n    this.outputLayersTensorIndices = this.model.outputLayersTensorIndices;\n    this.nodesByDepth = this.model.nodesByDepth;\n    this.containerNodes = this.model.containerNodes;\n    this.outputNames = this.model.outputNames;\n    this.inputNames = this.model.inputNames;\n    // TODO(michaelterry): Add feedInputNames, feedInputs, if needed.\n    // TODO(michaelterry): Add callbackModel if needed.\n    this.built = true;\n  }\n\n  override countParams(): number {\n    if (!this.built) {\n      this.build();\n    }\n    return super.countParams();\n  }\n\n  /**\n   * Print a text summary of the Sequential model's layers.\n   *\n   * The summary includes\n   * - Name and type of all layers that comprise the model.\n   * - Output shape(s) of the layers\n   * - Number of weight parameters of each layer\n   * - The total number of trainable and non-trainable parameters of the\n   * model.\n   *\n   * ```js\n   * const model = tf.sequential();\n   * model.add(\n   *     tf.layers.dense({units: 100, inputShape: [10], activation: 'relu'}));\n   * model.add(tf.layers.dense({units: 1, activation: 'sigmoid'}));\n   *\n   * model.summary();\n   * ```\n   *\n   * @param lineLength Custom line length, in number of characters.\n   * @param positions Custom widths of each of the columns, as either\n   *   fractions of `lineLength` (e.g., `[0.5, 0.75, 1]`) or absolute number\n   *   of characters (e.g., `[30, 50, 65]`). Each number corresponds to\n   *   right-most (i.e., ending) position of a column.\n   * @param printFn Custom print function. Can be used to replace the default\n   *   `console.log`. For example, you can use `x => {}` to mute the printed\n   *   messages in the console.\n   *\n   * @doc {heading: 'Models', subheading: 'Classes'}\n   */\n  override summary(\n      lineLength?: number, positions?: number[],\n      printFn:\n          // tslint:disable-next-line:no-any\n      (message?: any, ...optionalParams: any[]) => void = console.log) {\n    if (!this.built) {\n      this.build();\n    }\n    super.summary(lineLength, positions, printFn);\n  }\n\n  /**\n   * Sets the weights of the model.\n   *\n   * @param weights Should be a list of Tensors with shapes and types matching\n   *   the output of `model.getWeights()`.\n   */\n  override setWeights(weights: Tensor[]): void {\n    if (this.model == null) {\n      this.build();\n    }\n    this.model.setWeights(weights);\n  }\n\n  /**\n   * Returns the loss value & metrics values for the model in test mode.\n   *\n   * Loss and metrics are specified during `compile()`, which needs to happen\n   * before calls to `evaluate()`.\n   *\n   * Computation is done in batches.\n   *\n   * ```js\n   * const model = tf.sequential({\n   *   layers: [tf.layers.dense({units: 1, inputShape: [10]})]\n   * });\n   * model.compile({optimizer: 'sgd', loss: 'meanSquaredError'});\n   * const result = model.evaluate(tf.ones([8, 10]), tf.ones([8, 1]), {\n   *   batchSize: 4,\n   * });\n   * result.print();\n   * ```\n   *\n   * @param x `tf.Tensor` of test data, or an `Array` of `tf.Tensor`s if the\n   * model has multiple inputs.\n   * @param y `tf.Tensor` of target data, or an `Array` of `tf.Tensor`s if the\n   * model has multiple outputs.\n   * @param args A `ModelEvaluateConfig`, containing optional fields.\n   *\n   * @return `Scalar` test loss (if the model has a single output and no\n   *   metrics) or `Array` of `Scalar`s (if the model has multiple outputs\n   *   and/or metrics). The attribute `model.metricsNames`\n   *   will give you the display labels for the scalar outputs.\n   *\n   * @doc {heading: 'Models', subheading: 'Classes'}\n   */\n  override evaluate(\n      x: Tensor|Tensor[], y: Tensor|Tensor[],\n      args: ModelEvaluateArgs = {}): Scalar|Scalar[] {\n    if (!this.built) {\n      throw new RuntimeError(\n          'The model needs to be compiled before being used.');\n    }\n    return this.model.evaluate(x, y, args);\n  }\n\n  // TODO(cais): Add code snippet below once real dataset objects are\n  //   available.\n  /**\n   * Evaluate model using a dataset object.\n   *\n   * Note: Unlike `evaluate()`, this method is asynchronous (`async`).\n   *\n   * @param dataset A dataset object. Its `iterator()` method is expected\n   *   to generate a dataset iterator object, the `next()` method of which\n   *   is expected to produce data batches for evaluation. The return value\n   *   of the `next()` call ought to contain a boolean `done` field and a\n   *   `value` field. The `value` field is expected to be an array of two\n   *   `tf.Tensor`s or an array of two nested `tf.Tensor` structures. The former\n   *   case is for models with exactly one input and one output (e.g.\n   *   a sequential model). The latter case is for models with multiple\n   *   inputs and/or multiple outputs. Of the two items in the array, the\n   *   first is the input feature(s) and the second is the output target(s).\n   * @param args A configuration object for the dataset-based evaluation.\n   * @returns Loss and metric values as an Array of `Scalar` objects.\n   *\n   * @doc {heading: 'Models', subheading: 'Classes'}\n   */\n  override async evaluateDataset(dataset: Dataset<{}>,\n      args: ModelEvaluateDatasetArgs): Promise<Scalar|Scalar[]> {\n    if (!this.built) {\n      throw new RuntimeError(\n          'The model needs to be compiled before being used.');\n    }\n    return this.model.evaluateDataset(dataset, args);\n  }\n\n  /**\n   * Generates output predictions for the input samples.\n   *\n   * Computation is done in batches.\n   *\n   * Note: the \"step\" mode of predict() is currently not supported.\n   *   This is because the TensorFlow.js core backend is imperative only.\n   *\n   * ```js\n   * const model = tf.sequential({\n   *   layers: [tf.layers.dense({units: 1, inputShape: [10]})]\n   * });\n   * model.predict(tf.ones([2, 10])).print();\n   * ```\n   *\n   * @param x The input data, as a Tensor, or an `Array` of `tf.Tensor`s if\n   *   the model has multiple inputs.\n   * @param conifg A `ModelPredictConfig` object containing optional fields.\n   *\n   * @return `tf.Tensor`(s) of predictions.\n   *\n   * @exception ValueError In case of mismatch between the provided input data\n   *   and the model's expectations, or in case a stateful model receives a\n   *   number of samples that is not a multiple of the batch size.\n   *\n   * @doc {heading: 'Models', subheading: 'Classes'}\n   */\n  override predict(x: Tensor|Tensor[], args: ModelPredictArgs = {}):\n      Tensor|Tensor[] {\n    if (this.model == null) {\n      this.build();\n    }\n    return this.model.predict(x, args);\n  }\n\n  /**\n   * Returns predictions for a single batch of samples.\n   *\n   * @param x: Input samples, as a Tensor, or list of Tensors (if the model\n   *   has multiple inputs).\n   * @return Tensor(s) of predictions\n   */\n  override predictOnBatch(x: Tensor): Tensor|Tensor[] {\n    if (this.model == null) {\n      this.build();\n    }\n    return this.model.predictOnBatch(x);\n  }\n\n  /**\n   * See `LayersModel.compile`.\n   *\n   * @param args\n   */\n  override compile(args: ModelCompileArgs): void {\n    this.build();\n    this.model.compile(args);\n    this.optimizer_ = this.model.optimizer;\n    // tslint:disable-next-line:no-any\n    this.isOptimizerOwned = (this.model as any).isOptimizerOwned;\n    this.loss = this.model.loss;\n    this.metrics = this.model.metrics;\n    // TODO(cais): Add this.lossWeights, this.sampleWeightMode,\n    //   this.weightedMetrics, this.targets.\n    this.metricsTensors = this.model.metricsTensors;\n    this.metricsNames = this.model.metricsNames;\n    // TODO(cais): Add sampleWeights.\n  }\n\n  override get optimizer(): Optimizer {\n    return this.model == null ? undefined : this.model.optimizer;\n  }\n\n  override set optimizer(optimizer: Optimizer) {\n    this.model.optimizer = optimizer;\n  }\n\n  /**\n   * Trains the model for a fixed number of epochs (iterations on a dataset).\n   *\n   * ```js\n   * const model = tf.sequential({\n   *   layers: [tf.layers.dense({units: 1, inputShape: [10]})]\n   * });\n   * model.compile({optimizer: 'sgd', loss: 'meanSquaredError'});\n   * const history = await model.fit(tf.ones([8, 10]), tf.ones([8, 1]), {\n   *   batchSize: 4,\n   *   epochs: 3\n   * });\n   * console.log(history.history.loss[0]);\n   * ```\n   *\n   * @param x `tf.Tensor` of training data, or an array of `tf.Tensor`s if the\n   * model has multiple inputs. If all inputs in the model are named, you can\n   * also pass a dictionary mapping input names to `tf.Tensor`s.\n   * @param y `tf.Tensor` of target (label) data, or an array of `tf.Tensor`s if\n   * the model has multiple outputs. If all outputs in the model are named, you\n   *  can also pass a dictionary mapping output names to `tf.Tensor`s.\n   * @param args  A `ModelFitConfig`, containing optional fields.\n   *\n   * @return A `History` instance. Its `history` attribute contains all\n   *   information collected during training.\n   *\n   * @exception ValueError In case of mismatch between the provided input data\n   *   and what the model expects.\n   *\n   * @doc {heading: 'Models', subheading: 'Classes'}\n   */\n  override async fit(\n      x: Tensor|Tensor[]|{[inputName: string]: Tensor},\n      y: Tensor|Tensor[]|{[inputName: string]: Tensor},\n      args: ModelFitArgs = {}): Promise<History> {\n    if (!this.built) {\n      throw new RuntimeError(\n          'The model needs to be compiled before ' +\n          'being used.');\n    }\n    return this.model.fit(x, y, args);\n  }\n\n  /**\n   * Trains the model using a dataset object.\n   *\n   * ```js\n   * const xArray = [\n   *   [1, 1, 1, 1, 1, 1, 1, 1, 1],\n   *   [1, 1, 1, 1, 1, 1, 1, 1, 1],\n   *   [1, 1, 1, 1, 1, 1, 1, 1, 1],\n   *   [1, 1, 1, 1, 1, 1, 1, 1, 1],\n   * ];\n   * const yArray = [1, 1, 1, 1];\n   * // Create a dataset from the JavaScript array.\n   * const xDataset = tf.data.array(xArray);\n   * const yDataset = tf.data.array(yArray);\n   * // Zip combines the `x` and `y` Datasets into a single Dataset, the\n   * // iterator of which will return an object containing of two tensors,\n   * // corresponding to `x` and `y`.  The call to `batch(4)` will bundle\n   * // four such samples into a single object, with the same keys now pointing\n   * // to tensors that hold 4 examples, organized along the batch dimension.\n   * // The call to `shuffle(4)` causes each iteration through the dataset to\n   * // happen in a different order.  The size of the shuffle window is 4.\n   * const xyDataset = tf.data.zip({xs: xDataset, ys: yDataset})\n   *     .batch(4)\n   *     .shuffle(4);\n   * const model = tf.sequential({\n   *   layers: [tf.layers.dense({units: 1, inputShape: [9]})]\n   * });\n   * model.compile({optimizer: 'sgd', loss: 'meanSquaredError'});\n   * const history = await model.fitDataset(xyDataset, {\n   *   epochs: 4,\n   *   callbacks: {onEpochEnd: (epoch, logs) => console.log(logs.loss)}\n   * });\n   * ```\n   *\n   * @param dataset A dataset object. Its `iterator()` method is expected to\n   *   generate a dataset iterator object, the `next()` method of which is\n   *   expected to produce data batches for evaluation. The return value of the\n   *   `next()` call ought to contain a boolean `done` field and a `value`\n   *   field.\n   *\n   *   The `value` field is expected to be an object of with fields\n   *   `xs` and `ys`, which point to the feature tensor and the target tensor,\n   *   respectively. This case is for models with exactly one input and one\n   *   output (e.g. a sequential model). For example:\n   *   ```js\n   *   {value: {xs: xsTensor, ys: ysTensor}, done: false}\n   *   ```\n   *\n   *   If the model has multiple inputs, the `xs` field of `value` should\n   *   be an object mapping input names to their respective feature tensors.\n   *   For example:\n   *   ```js\n   *   {\n   *     value: {\n   *       xs: {\n   *         input_1: xsTensor1,\n   *         input_2: xsTensor2\n   *       },\n   *       ys: ysTensor\n   *     },\n   *     done: false\n   *   }\n   *   ```\n   *   If the model has multiple outputs, the `ys` field of `value` should\n   *   be an object mapping output names to their respective target tensors.\n   *   For example:\n   *   ```js\n   *   {\n   *     value: {\n   *       xs: xsTensor,\n   *       ys: {\n   *         output_1: ysTensor1,\n   *         output_2: ysTensor2\n   *       },\n   *     },\n   *     done: false\n   *   }\n   *   ```\n   * @param args A `ModelFitDatasetArgs`, containing optional fields.\n   *\n   * @return A `History` instance. Its `history` attribute contains all\n   *   information collected during training.\n   *\n   * @doc {heading: 'Models', subheading: 'Classes', ignoreCI: true}\n   */\n  override async fitDataset<T>(dataset: Dataset<T>,\n      args: ModelFitDatasetArgs<T>): Promise<History> {\n    if (!this.built) {\n      throw new RuntimeError(\n          'The model needs to be compiled before ' +\n          'being used.');\n    }\n    return this.model.fitDataset(dataset, args);\n  }\n\n  /**\n   * Runs a single gradient update on a single batch of data.\n   *\n   * This method differs from `fit()` and `fitDataset()` in the following\n   * regards:\n   *   - It operates on exactly one batch of data.\n   *   - It returns only the loss and metric values, instead of\n   *     returning the batch-by-batch loss and metric values.\n   *   - It doesn't support fine-grained options such as verbosity and\n   *     callbacks.\n   *\n   * @param x Input data. It could be one of the following:\n   *   - A `tf.Tensor`, or an Array of `tf.Tensor`s (in case the model has\n   *     multiple inputs).\n   *   - An Object mapping input names to corresponding `tf.Tensor` (if the\n   *     model has named inputs).\n   * @param y Target data. It could be either a `tf.Tensor` or multiple\n   *   `tf.Tensor`s. It should be consistent with `x`.\n   * @returns Training loss or losses (in case the model has\n   *   multiple outputs), along with metrics (if any), as numbers.\n   *\n   * @doc {heading: 'Models', subheading: 'Classes'}\n   */\n  override async trainOnBatch(\n      x: Tensor|Tensor[]|{[inputName: string]: Tensor},\n      y: Tensor|Tensor[]|\n      {[inputName: string]: Tensor}): Promise<number|number[]> {\n    return this.model.trainOnBatch(x, y);\n  }\n\n  /* See parent class for JsDoc */\n  /** @nocollapse */\n  static override fromConfig<T extends serialization.Serializable>(\n      cls: serialization.SerializableConstructor<T>,\n      config: serialization.ConfigDict,\n      customObjects = {} as serialization.ConfigDict,\n      fastWeightInit = false): T {\n    let configArray: serialization.ConfigDictArray;\n    let extraModelConfig: serialization.ConfigDict = {};\n    if (config instanceof Array) {\n      if (!(config[0].className != null) ||\n          config[0]['className'] === 'Merge') {\n        throw new ValueError('Legacy serialization format not supported yet.');\n      }\n      configArray = config;\n    } else {\n      util.assert(\n          config['layers'] != null,\n          () =>\n              `When the config data for a Sequential model is not an Array, ` +\n              `it must be an Object that contains the 'layers' field.`);\n      configArray = config['layers'] as serialization.ConfigDictArray;\n      delete config['layers'];\n      extraModelConfig = config;\n    }\n\n    const model = new cls(extraModelConfig);\n    if (!(model instanceof Sequential)) {\n      throw new NotImplementedError(\n          `Sequential.fromConfig called on non-Sequential input: ${model}`);\n    }\n    for (const conf of configArray) {\n      const customObjects: serialization.ConfigDict = undefined;\n      const layer = deserialize(\n                        conf as serialization.ConfigDict, customObjects,\n                        fastWeightInit) as Layer;\n      if (fastWeightInit) {\n        layer.setFastWeightInitDuringBuild(true);\n      }\n      model.add(layer);\n    }\n    return model;\n  }\n\n  /**\n   * Setter used for force stopping of LayersModel.fit() (i.e., training).\n   *\n   * Example:\n   *\n   * ```js\n   * const model = tf.sequential();\n   * model.add(tf.layers.dense({units: 1, inputShape: [10]}));\n   * model.compile({loss: 'meanSquaredError', optimizer: 'sgd'});\n   * const xs = tf.ones([8, 10]);\n   * const ys = tf.zeros([8, 1]);\n   *\n   * const history = await model.fit(xs, ys, {\n   *   epochs: 10,\n   *   callbacks: {\n   *     onEpochEnd: async (epoch, logs) => {\n   *       if (epoch === 2) {\n   *         model.stopTraining = true;\n   *       }\n   *     }\n   *   }\n   * });\n   *\n   * // There should be only 3 values in the loss array, instead of 10 values,\n   * // due to the stopping after 3 epochs.\n   * console.log(history.history.loss);\n   * ```\n   */\n  override set stopTraining(stop: boolean) {\n    // TODO(cais): When refactoring to remove the composition pattern happens,\n    // remove this method overriding.\n    if (this.model == null) {\n      throw new ValueError(\n          'Cannot set the stopTraining property of a sequential model before ' +\n          'it is compiled.');\n    }\n    this.model.stopTraining = stop;\n  }\n\n  override get stopTraining(): boolean {\n    if (this.model == null) {\n      throw new ValueError(\n          'Cannot get the stopTraining property of a sequential model before ' +\n          'it is compiled.');\n    }\n    return this.model.stopTraining;\n  }\n\n  // TODO(cais): Override get trainableWeights() here\n\n  // tslint:disable-next-line:no-any\n  override getConfig(): any {\n    // NOTE(cais): We override the return type of getConfig() to `any` here,\n    //   because the `Sequential` class is a special case among `Container`\n    //   subtypes in that its getConfig() method returns an Array (not a\n    //   dict).\n    const layers: serialization.ConfigDict[] = [];\n    for (const layer of this.layers) {\n      const dict: serialization.ConfigDict = {};\n      dict['className'] = layer.getClassName();\n      dict['config'] = layer.getConfig();\n      layers.push(dict);\n    }\n    return {name: this.name, layers};\n  }\n}\nserialization.registerClass(Sequential);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}