{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, sumOutType, UnsortedSegmentSum, util } from '@tensorflow/tfjs-core';\nimport { SegmentOpProgram } from '../segment_gpu';\nimport { range } from './Range';\nimport { reshape } from './Reshape';\nimport { tile } from './Tile';\nimport { transpose } from './Transpose';\nexport function unsortedSegmentSum(args) {\n  const {\n    inputs,\n    backend,\n    attrs\n  } = args;\n  const {\n    x,\n    segmentIds\n  } = inputs;\n  const {\n    numSegments\n  } = attrs;\n  const xRank = x.shape.length;\n  const toDispose = [];\n  let axis = 0;\n  const permutation = backend_util.getAxesPermutation([axis], xRank);\n  let permutedX = x;\n  if (permutation != null) {\n    permutedX = transpose({\n      inputs: {\n        x\n      },\n      backend,\n      attrs: {\n        perm: permutation\n      }\n    });\n    toDispose.push(permutedX);\n    axis = backend_util.getInnerMostAxes(1, xRank)[0];\n  }\n  const outShape = backend_util.segment_util.computeOutShape(permutedX.shape, axis, numSegments);\n  const inSize = util.sizeFromShape([permutedX.shape[axis]]);\n  const a2D = reshape({\n    inputs: {\n      x: permutedX\n    },\n    backend,\n    attrs: {\n      shape: [-1, inSize]\n    }\n  });\n  toDispose.push(a2D);\n  const outputDType = sumOutType(x.dtype);\n  const segOpCompute = (x, segOpType, segmentIds, dtype, numSegments) => {\n    const batchSize = x.shape[0];\n    const inSize = x.shape[1];\n    const windowSize = backend_util.segment_util.segOpComputeOptimalWindowSize(inSize, numSegments);\n    const segOpInfo = {\n      windowSize,\n      inSize,\n      batchSize,\n      numSegments\n    };\n    const program = new SegmentOpProgram(segOpInfo, segOpType);\n    const output = backend.compileAndRun(program, [x, segmentIds], dtype);\n    toDispose.push(output);\n    // No need to run another GPGPU program.\n    if (output.shape[1] === numSegments) {\n      return output;\n    }\n    const rangeInfo = range({\n      backend,\n      attrs: {\n        start: 0,\n        stop: numSegments,\n        step: 1,\n        dtype: 'float32'\n      }\n    });\n    const tileInfo = tile({\n      inputs: {\n        x: rangeInfo\n      },\n      backend,\n      attrs: {\n        reps: [inSize / windowSize]\n      }\n    });\n    toDispose.push(rangeInfo);\n    toDispose.push(tileInfo);\n    const result = segOpCompute(output, segOpType, tileInfo, dtype, numSegments);\n    return result;\n  };\n  const segOpResult = segOpCompute(a2D, 'unsortedSegmentSum', segmentIds, outputDType, numSegments);\n  const reshaped = reshape({\n    inputs: {\n      x: segOpResult\n    },\n    backend,\n    attrs: {\n      shape: outShape\n    }\n  });\n  let result = reshaped;\n  if (permutation != null) {\n    toDispose.push(reshaped);\n    const perm = backend_util.getUndoAxesPermutation(permutation);\n    result = transpose({\n      inputs: {\n        x: result\n      },\n      backend,\n      attrs: {\n        perm\n      }\n    });\n  }\n  toDispose.forEach(t => backend.disposeIntermediateTensorInfo(t));\n  return result;\n}\nexport const unsortedSegmentSumConfig = {\n  kernelName: UnsortedSegmentSum,\n  backendName: 'webgl',\n  kernelFunc: unsortedSegmentSum\n};","map":{"version":3,"names":["backend_util","sumOutType","UnsortedSegmentSum","util","SegmentOpProgram","range","reshape","tile","transpose","unsortedSegmentSum","args","inputs","backend","attrs","x","segmentIds","numSegments","xRank","shape","length","toDispose","axis","permutation","getAxesPermutation","permutedX","perm","push","getInnerMostAxes","outShape","segment_util","computeOutShape","inSize","sizeFromShape","a2D","outputDType","dtype","segOpCompute","segOpType","batchSize","windowSize","segOpComputeOptimalWindowSize","segOpInfo","program","output","compileAndRun","rangeInfo","start","stop","step","tileInfo","reps","result","segOpResult","reshaped","getUndoAxesPermutation","forEach","t","disposeIntermediateTensorInfo","unsortedSegmentSumConfig","kernelName","backendName","kernelFunc"],"sources":["/Users/jonchen/Documents/HackPSU/tfjs-backend-webgl/src/kernels/UnsortedSegmentSum.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, DataType, KernelConfig, KernelFunc, sumOutType, TensorInfo, UnsortedSegmentSum, UnsortedSegmentSumAttrs, UnsortedSegmentSumInputs, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {SegmentOpProgram} from '../segment_gpu';\n\nimport {range} from './Range';\nimport {reshape} from './Reshape';\nimport {tile} from './Tile';\nimport {transpose} from './Transpose';\n\nexport function unsortedSegmentSum(args: {\n  inputs: UnsortedSegmentSumInputs,\n  backend: MathBackendWebGL,\n  attrs: UnsortedSegmentSumAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x, segmentIds} = inputs;\n  const {numSegments} = attrs;\n\n  const xRank = x.shape.length;\n\n  const toDispose = [];\n\n  let axis = 0;\n  const permutation = backend_util.getAxesPermutation([axis], xRank);\n  let permutedX = x;\n  if (permutation != null) {\n    permutedX = transpose({inputs: {x}, backend, attrs: {perm: permutation}});\n    toDispose.push(permutedX);\n    axis = backend_util.getInnerMostAxes(1, xRank)[0];\n  }\n\n  const outShape = backend_util.segment_util.computeOutShape(\n      permutedX.shape, axis, numSegments);\n  const inSize = util.sizeFromShape([permutedX.shape[axis]]);\n  const a2D =\n      reshape({inputs: {x: permutedX}, backend, attrs: {shape: [-1, inSize]}});\n  toDispose.push(a2D);\n\n  const outputDType = sumOutType(x.dtype);\n\n  const segOpCompute =\n      (x: TensorInfo, segOpType: 'unsortedSegmentSum', segmentIds: TensorInfo,\n       dtype: DataType, numSegments: number): TensorInfo => {\n        const batchSize = x.shape[0];\n        const inSize = x.shape[1];\n        const windowSize =\n            backend_util.segment_util.segOpComputeOptimalWindowSize(\n                inSize, numSegments);\n        const segOpInfo = {windowSize, inSize, batchSize, numSegments};\n        const program = new SegmentOpProgram(segOpInfo, segOpType);\n        const output = backend.compileAndRun(program, [x, segmentIds], dtype);\n        toDispose.push(output);\n        // No need to run another GPGPU program.\n        if (output.shape[1] === numSegments) {\n          return output;\n        }\n        const rangeInfo = range({\n          backend,\n          attrs: {start: 0, stop: numSegments, step: 1, dtype: 'float32'}\n        });\n        const tileInfo = tile({\n          inputs: {x: rangeInfo},\n          backend,\n          attrs: {reps: [inSize / windowSize]}\n        });\n\n        toDispose.push(rangeInfo);\n        toDispose.push(tileInfo);\n\n        const result =\n            segOpCompute(output, segOpType, tileInfo, dtype, numSegments);\n        return result;\n      };\n\n  const segOpResult = segOpCompute(\n      a2D, 'unsortedSegmentSum', segmentIds, outputDType, numSegments);\n\n  const reshaped =\n      reshape({inputs: {x: segOpResult}, backend, attrs: {shape: outShape}});\n\n  let result = reshaped;\n  if (permutation != null) {\n    toDispose.push(reshaped);\n    const perm = backend_util.getUndoAxesPermutation(permutation);\n    result = transpose({inputs: {x: result}, backend, attrs: {perm}});\n  }\n\n  toDispose.forEach(t => backend.disposeIntermediateTensorInfo(t));\n  return result;\n}\n\nexport const unsortedSegmentSumConfig: KernelConfig = {\n  kernelName: UnsortedSegmentSum,\n  backendName: 'webgl',\n  kernelFunc: unsortedSegmentSum as unknown as KernelFunc\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}