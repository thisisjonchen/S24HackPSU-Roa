{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, Dilation2D, util } from '@tensorflow/tfjs-core';\nexport const dilation2DConfig = {\n  kernelName: Dilation2D,\n  backendName: 'cpu',\n  kernelFunc: ({\n    inputs,\n    backend,\n    attrs\n  }) => {\n    const {\n      x,\n      filter\n    } = inputs;\n    const {\n      strides,\n      pad,\n      dilations\n    } = attrs;\n    const cpuBackend = backend;\n    const xVals = cpuBackend.data.get(x.dataId).values;\n    const xRank = x.shape.length;\n    const filterVals = cpuBackend.data.get(filter.dataId).values;\n    const filterRank = filter.shape.length;\n    const {\n      batchSize,\n      inHeight,\n      inWidth,\n      inChannels,\n      outHeight,\n      outWidth,\n      padInfo,\n      strideHeight,\n      strideWidth,\n      filterHeight,\n      filterWidth,\n      dilationHeight,\n      dilationWidth,\n      outShape\n    } = backend_util.computeDilation2DInfo(x.shape, filter.shape, strides, pad, 'NHWC' /* dataFormat */, dilations);\n    const outSize = util.sizeFromShape(outShape);\n    const outRank = outShape.length;\n    const outputVals = util.getArrayFromDType(x.dtype, outSize);\n    // Upsampling the input by fill in `dilation size - 1` values between each\n    // input value.\n    // This implementation follows the TF c++ implementation:\n    // https://github.com/tensorflow/tensorflow/blob/d9a3a849edc198e90172bc58eb293de457f9d986/tensorflow/core/kernels/dilation_ops.cc\n    for (let b = 0; b < batchSize; ++b) {\n      for (let hOut = 0; hOut < outHeight; ++hOut) {\n        const hBeg = hOut * strideHeight - padInfo.top;\n        for (let wOut = 0; wOut < outWidth; ++wOut) {\n          const wBeg = wOut * strideWidth - padInfo.left;\n          for (let d = 0; d < inChannels; ++d) {\n            let curVal = Number.MIN_SAFE_INTEGER;\n            for (let h = 0; h < filterHeight; ++h) {\n              const hIn = hBeg + h * dilationHeight;\n              if (hIn >= 0 && hIn < inHeight) {\n                for (let w = 0; w < filterWidth; ++w) {\n                  const wIn = wBeg + w * dilationWidth;\n                  if (wIn >= 0 && wIn < inWidth) {\n                    const xIndex = util.locToIndex([b, hIn, wIn, d], xRank, util.computeStrides(x.shape));\n                    const filterIndex = util.locToIndex([h, w, d], filterRank, util.computeStrides(filter.shape));\n                    const val = xVals[xIndex] + filterVals[filterIndex];\n                    if (val > curVal) {\n                      curVal = val;\n                    }\n                  }\n                }\n              }\n            }\n            const outputIndex = util.locToIndex([b, hOut, wOut, d], outRank, util.computeStrides(outShape));\n            outputVals[outputIndex] = curVal;\n          }\n        }\n      }\n    }\n    const dataId = cpuBackend.write(util.toTypedArray(outputVals, x.dtype), outShape, x.dtype);\n    return {\n      dataId,\n      shape: outShape,\n      dtype: x.dtype\n    };\n  }\n};","map":{"version":3,"names":["backend_util","Dilation2D","util","dilation2DConfig","kernelName","backendName","kernelFunc","inputs","backend","attrs","x","filter","strides","pad","dilations","cpuBackend","xVals","data","get","dataId","values","xRank","shape","length","filterVals","filterRank","batchSize","inHeight","inWidth","inChannels","outHeight","outWidth","padInfo","strideHeight","strideWidth","filterHeight","filterWidth","dilationHeight","dilationWidth","outShape","computeDilation2DInfo","outSize","sizeFromShape","outRank","outputVals","getArrayFromDType","dtype","b","hOut","hBeg","top","wOut","wBeg","left","d","curVal","Number","MIN_SAFE_INTEGER","h","hIn","w","wIn","xIndex","locToIndex","computeStrides","filterIndex","val","outputIndex","write","toTypedArray"],"sources":["/Users/jonchen/Documents/HackPSU/tfjs-backend-cpu/src/kernels/Dilation2D.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, Dilation2D, Dilation2DAttrs, Dilation2DInputs, KernelConfig, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendCPU} from '../backend_cpu';\n\nexport const dilation2DConfig: KernelConfig = {\n  kernelName: Dilation2D,\n  backendName: 'cpu',\n  kernelFunc: ({inputs, backend, attrs}) => {\n    const {x, filter} = inputs as Dilation2DInputs;\n    const {strides, pad, dilations} = attrs as unknown as Dilation2DAttrs;\n    const cpuBackend = backend as MathBackendCPU;\n\n    const xVals = cpuBackend.data.get(x.dataId).values as TypedArray;\n    const xRank = x.shape.length;\n\n    const filterVals = cpuBackend.data.get(filter.dataId).values as TypedArray;\n    const filterRank = filter.shape.length;\n\n    const {\n      batchSize,\n      inHeight,\n      inWidth,\n      inChannels,\n      outHeight,\n      outWidth,\n      padInfo,\n      strideHeight,\n      strideWidth,\n      filterHeight,\n      filterWidth,\n      dilationHeight,\n      dilationWidth,\n      outShape\n    } =\n        backend_util.computeDilation2DInfo(\n            x.shape as [number, number, number, number],\n            filter.shape as [number, number, number], strides, pad,\n            'NHWC' /* dataFormat */, dilations);\n\n    const outSize = util.sizeFromShape(outShape);\n    const outRank = outShape.length;\n    const outputVals = util.getArrayFromDType(x.dtype, outSize);\n\n    // Upsampling the input by fill in `dilation size - 1` values between each\n    // input value.\n    // This implementation follows the TF c++ implementation:\n    // https://github.com/tensorflow/tensorflow/blob/d9a3a849edc198e90172bc58eb293de457f9d986/tensorflow/core/kernels/dilation_ops.cc\n    for (let b = 0; b < batchSize; ++b) {\n      for (let hOut = 0; hOut < outHeight; ++hOut) {\n        const hBeg = hOut * strideHeight - padInfo.top;\n        for (let wOut = 0; wOut < outWidth; ++wOut) {\n          const wBeg = wOut * strideWidth - padInfo.left;\n          for (let d = 0; d < inChannels; ++d) {\n            let curVal = Number.MIN_SAFE_INTEGER;\n            for (let h = 0; h < filterHeight; ++h) {\n              const hIn = hBeg + h * dilationHeight;\n              if (hIn >= 0 && hIn < inHeight) {\n                for (let w = 0; w < filterWidth; ++w) {\n                  const wIn = wBeg + w * dilationWidth;\n                  if (wIn >= 0 && wIn < inWidth) {\n                    const xIndex = util.locToIndex(\n                        [b, hIn, wIn, d], xRank, util.computeStrides(x.shape));\n                    const filterIndex = util.locToIndex(\n                        [h, w, d], filterRank,\n                        util.computeStrides(filter.shape));\n                    const val = xVals[xIndex] + filterVals[filterIndex];\n                    if (val > curVal) {\n                      curVal = val;\n                    }\n                  }\n                }\n              }\n            }\n            const outputIndex = util.locToIndex(\n                [b, hOut, wOut, d], outRank, util.computeStrides(outShape));\n            outputVals[outputIndex] = curVal;\n          }\n        }\n      }\n    }\n\n    const dataId = cpuBackend.write(\n        util.toTypedArray(outputVals, x.dtype), outShape, x.dtype);\n\n    return {dataId, shape: outShape, dtype: x.dtype};\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}