{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { assertTypesMatch } from '../tensor_util';\nimport { convertToTensor } from '../tensor_util_env';\nimport * as util from '../util';\nimport { add } from './add';\nimport { div } from './div';\nimport { mul } from './mul';\nimport { op } from './operation';\nimport { pow } from './pow';\nimport { scalar } from './scalar';\nimport { sub } from './sub';\n/**\n * Compute the moving average of a variable.\n *\n * Without zeroDebias, the moving average operation is defined by:\n *   `v += delta`\n * where\n *   `delta = (1 - decay) * (x - v)`\n *\n * With zeroDebias (default), the `delta` term is scaled to debias the\n * effect of the (assumed) zero-initialization of `v`.\n *   `delta /= (1 - decay ^ step)`\n *\n * For more details on the zero-debiasing algorithm, see:\n *   https://arxiv.org/abs/1412.6980\n *\n * Note that this function is completely stateless and does not keep track of\n * step count. The step count needs to be maintained by the caller and passed\n * in as `step`.\n *\n * @param v The current moving average value.\n * @param x New input value, must have the same shape and dtype as `v`.\n * @param decay The decay factor. Typical values are 0.95 and 0.99.\n * @param step Step count.\n * @param zeroDebias: Whether zeroDebias is to be performed (default: `true`).\n * @returns The new moving average value.\n *\n * @doc {heading: 'Operations', subheading: 'Moving Average'}\n */\nfunction movingAverage_(v, x, decay, step, zeroDebias = true) {\n  const $v = convertToTensor(v, 'v', 'movingAverage');\n  const $x = convertToTensor(x, 'x', 'movingAverage');\n  const $decay = convertToTensor(decay, 'decay', 'movingAverage');\n  assertTypesMatch($v, $x);\n  util.assert(util.arraysEqual($v.shape, $x.shape), () => 'Shape mismatch in v and x');\n  const one = scalar(1);\n  const oneMinusDecay = sub(one, $decay);\n  let update = mul(sub($x, $v), oneMinusDecay);\n  if (zeroDebias) {\n    util.assert(step != null, () => 'When using zeroDebias: true, step is required.');\n    const $step = convertToTensor(step, 'step', 'movingAverage');\n    update = div(update, sub(one, pow($decay, $step)));\n  }\n  return add($v, update);\n}\nexport const movingAverage = /* @__PURE__ */op({\n  movingAverage_\n});","map":{"version":3,"names":["assertTypesMatch","convertToTensor","util","add","div","mul","op","pow","scalar","sub","movingAverage_","v","x","decay","step","zeroDebias","$v","$x","$decay","assert","arraysEqual","shape","one","oneMinusDecay","update","$step","movingAverage"],"sources":["/Users/jonchen/Documents/HackPSU/tfjs-core/src/ops/moving_average.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Scalar, Tensor} from '../tensor';\nimport {assertTypesMatch} from '../tensor_util';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport * as util from '../util';\n\nimport {add} from './add';\nimport {div} from './div';\nimport {mul} from './mul';\nimport {op} from './operation';\nimport {pow} from './pow';\nimport {scalar} from './scalar';\nimport {sub} from './sub';\n\n/**\n * Compute the moving average of a variable.\n *\n * Without zeroDebias, the moving average operation is defined by:\n *   `v += delta`\n * where\n *   `delta = (1 - decay) * (x - v)`\n *\n * With zeroDebias (default), the `delta` term is scaled to debias the\n * effect of the (assumed) zero-initialization of `v`.\n *   `delta /= (1 - decay ^ step)`\n *\n * For more details on the zero-debiasing algorithm, see:\n *   https://arxiv.org/abs/1412.6980\n *\n * Note that this function is completely stateless and does not keep track of\n * step count. The step count needs to be maintained by the caller and passed\n * in as `step`.\n *\n * @param v The current moving average value.\n * @param x New input value, must have the same shape and dtype as `v`.\n * @param decay The decay factor. Typical values are 0.95 and 0.99.\n * @param step Step count.\n * @param zeroDebias: Whether zeroDebias is to be performed (default: `true`).\n * @returns The new moving average value.\n *\n * @doc {heading: 'Operations', subheading: 'Moving Average'}\n */\nfunction movingAverage_<T extends Tensor>(\n    v: T|TensorLike, x: T|TensorLike, decay: number|Scalar,\n    step?: number|Scalar, zeroDebias = true): T {\n  const $v = convertToTensor(v, 'v', 'movingAverage');\n  const $x = convertToTensor(x, 'x', 'movingAverage');\n  const $decay = convertToTensor(decay, 'decay', 'movingAverage');\n\n  assertTypesMatch($v, $x);\n  util.assert(\n      util.arraysEqual($v.shape, $x.shape), () => 'Shape mismatch in v and x');\n\n  const one = scalar(1);\n  const oneMinusDecay = sub(one, $decay);\n\n  let update = mul(sub($x, $v), oneMinusDecay);\n  if (zeroDebias) {\n    util.assert(\n        step != null, () => 'When using zeroDebias: true, step is required.');\n    const $step = convertToTensor(step, 'step', 'movingAverage');\n    update = div(update, sub(one, pow($decay, $step)));\n  }\n  return add($v, update);\n}\n\nexport const movingAverage = /* @__PURE__ */ op({movingAverage_});\n"],"mappings":"AAAA;;;;;;;;;;;;;;;;AAkBA,SAAQA,gBAAgB,QAAO,gBAAgB;AAC/C,SAAQC,eAAe,QAAO,oBAAoB;AAElD,OAAO,KAAKC,IAAI,MAAM,SAAS;AAE/B,SAAQC,GAAG,QAAO,OAAO;AACzB,SAAQC,GAAG,QAAO,OAAO;AACzB,SAAQC,GAAG,QAAO,OAAO;AACzB,SAAQC,EAAE,QAAO,aAAa;AAC9B,SAAQC,GAAG,QAAO,OAAO;AACzB,SAAQC,MAAM,QAAO,UAAU;AAC/B,SAAQC,GAAG,QAAO,OAAO;AAEzB;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BA,SAASC,cAAcA,CACnBC,CAAe,EAAEC,CAAe,EAAEC,KAAoB,EACtDC,IAAoB,EAAEC,UAAU,GAAG,IAAI;EACzC,MAAMC,EAAE,GAAGf,eAAe,CAACU,CAAC,EAAE,GAAG,EAAE,eAAe,CAAC;EACnD,MAAMM,EAAE,GAAGhB,eAAe,CAACW,CAAC,EAAE,GAAG,EAAE,eAAe,CAAC;EACnD,MAAMM,MAAM,GAAGjB,eAAe,CAACY,KAAK,EAAE,OAAO,EAAE,eAAe,CAAC;EAE/Db,gBAAgB,CAACgB,EAAE,EAAEC,EAAE,CAAC;EACxBf,IAAI,CAACiB,MAAM,CACPjB,IAAI,CAACkB,WAAW,CAACJ,EAAE,CAACK,KAAK,EAAEJ,EAAE,CAACI,KAAK,CAAC,EAAE,MAAM,2BAA2B,CAAC;EAE5E,MAAMC,GAAG,GAAGd,MAAM,CAAC,CAAC,CAAC;EACrB,MAAMe,aAAa,GAAGd,GAAG,CAACa,GAAG,EAAEJ,MAAM,CAAC;EAEtC,IAAIM,MAAM,GAAGnB,GAAG,CAACI,GAAG,CAACQ,EAAE,EAAED,EAAE,CAAC,EAAEO,aAAa,CAAC;EAC5C,IAAIR,UAAU,EAAE;IACdb,IAAI,CAACiB,MAAM,CACPL,IAAI,IAAI,IAAI,EAAE,MAAM,gDAAgD,CAAC;IACzE,MAAMW,KAAK,GAAGxB,eAAe,CAACa,IAAI,EAAE,MAAM,EAAE,eAAe,CAAC;IAC5DU,MAAM,GAAGpB,GAAG,CAACoB,MAAM,EAAEf,GAAG,CAACa,GAAG,EAAEf,GAAG,CAACW,MAAM,EAAEO,KAAK,CAAC,CAAC,CAAC;;EAEpD,OAAOtB,GAAG,CAACa,EAAE,EAAEQ,MAAM,CAAC;AACxB;AAEA,OAAO,MAAME,aAAa,GAAG,eAAgBpB,EAAE,CAAC;EAACI;AAAc,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}