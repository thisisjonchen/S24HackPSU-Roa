{"ast":null,"code":"/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nfunction lowerBound(array, value) {\n  let left = 0;\n  let right = array.length;\n  let mid = 0;\n  while (left < right) {\n    mid = Math.floor((left + right) / 2);\n    if (array[mid] < value) {\n      left = mid + 1;\n    } else {\n      right = mid;\n    }\n  }\n  return right;\n}\nfunction upperBound(array, value) {\n  let left = 0;\n  let right = array.length;\n  let mid = 0;\n  while (left < right) {\n    mid = Math.floor((left + right) / 2);\n    if (array[mid] <= value) {\n      left = mid + 1;\n    } else {\n      right = mid;\n    }\n  }\n  return right;\n}\nexport function searchSortedImpl(sortedInputs, values, batchSize, numInputs, numValues, side) {\n  const output = util.getArrayFromDType('int32', batchSize * numValues);\n  for (let b = 0; b < batchSize; ++b) {\n    const sortedInputsSlice = sortedInputs.slice(b * numInputs, (b + 1) * numInputs);\n    const outputOffset = b * numValues;\n    for (let i = 0; i < numValues; ++i) {\n      output[outputOffset + i] = side === 'left' ? lowerBound(sortedInputsSlice, values[i + outputOffset]) : upperBound(sortedInputsSlice, values[i + outputOffset]);\n    }\n  }\n  return output;\n}","map":{"version":3,"names":["util","lowerBound","array","value","left","right","length","mid","Math","floor","upperBound","searchSortedImpl","sortedInputs","values","batchSize","numInputs","numValues","side","output","getArrayFromDType","b","sortedInputsSlice","slice","outputOffset","i"],"sources":["/Users/jonchen/Documents/HackPSU/tfjs-backend-cpu/src/kernels/SearchSorted_impl.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {TypedArray, util} from '@tensorflow/tfjs-core';\n\nfunction lowerBound(array: TypedArray, value: number) {\n  let left = 0;\n  let right = array.length;\n  let mid = 0;\n  while (left < right) {\n    mid = Math.floor((left + right) / 2);\n    if (array[mid] < value) {\n      left = mid + 1;\n    } else {\n      right = mid;\n    }\n  }\n  return right;\n}\n\nfunction upperBound(array: TypedArray, value: number) {\n  let left = 0;\n  let right = array.length;\n  let mid = 0;\n  while (left < right) {\n    mid = Math.floor((left + right) / 2);\n    if (array[mid] <= value) {\n      left = mid + 1;\n    } else {\n      right = mid;\n    }\n  }\n  return right;\n}\n\nexport function searchSortedImpl(\n    sortedInputs: TypedArray, values: TypedArray, batchSize: number,\n    numInputs: number, numValues: number, side: 'left'|'right'): TypedArray {\n  const output =\n      util.getArrayFromDType('int32', batchSize * numValues) as TypedArray;\n  for (let b = 0; b < batchSize; ++b) {\n    const sortedInputsSlice =\n        sortedInputs.slice(b * numInputs, (b + 1) * numInputs);\n    const outputOffset = b * numValues;\n    for (let i = 0; i < numValues; ++i) {\n      output[outputOffset + i] = side === 'left' ?\n          lowerBound(sortedInputsSlice, values[i + outputOffset]) :\n          upperBound(sortedInputsSlice, values[i + outputOffset]);\n    }\n  }\n  return output;\n}\n"],"mappings":"AAAA;;;;;;;;;;;;;;;;AAiBA,SAAoBA,IAAI,QAAO,uBAAuB;AAEtD,SAASC,UAAUA,CAACC,KAAiB,EAAEC,KAAa;EAClD,IAAIC,IAAI,GAAG,CAAC;EACZ,IAAIC,KAAK,GAAGH,KAAK,CAACI,MAAM;EACxB,IAAIC,GAAG,GAAG,CAAC;EACX,OAAOH,IAAI,GAAGC,KAAK,EAAE;IACnBE,GAAG,GAAGC,IAAI,CAACC,KAAK,CAAC,CAACL,IAAI,GAAGC,KAAK,IAAI,CAAC,CAAC;IACpC,IAAIH,KAAK,CAACK,GAAG,CAAC,GAAGJ,KAAK,EAAE;MACtBC,IAAI,GAAGG,GAAG,GAAG,CAAC;KACf,MAAM;MACLF,KAAK,GAAGE,GAAG;;;EAGf,OAAOF,KAAK;AACd;AAEA,SAASK,UAAUA,CAACR,KAAiB,EAAEC,KAAa;EAClD,IAAIC,IAAI,GAAG,CAAC;EACZ,IAAIC,KAAK,GAAGH,KAAK,CAACI,MAAM;EACxB,IAAIC,GAAG,GAAG,CAAC;EACX,OAAOH,IAAI,GAAGC,KAAK,EAAE;IACnBE,GAAG,GAAGC,IAAI,CAACC,KAAK,CAAC,CAACL,IAAI,GAAGC,KAAK,IAAI,CAAC,CAAC;IACpC,IAAIH,KAAK,CAACK,GAAG,CAAC,IAAIJ,KAAK,EAAE;MACvBC,IAAI,GAAGG,GAAG,GAAG,CAAC;KACf,MAAM;MACLF,KAAK,GAAGE,GAAG;;;EAGf,OAAOF,KAAK;AACd;AAEA,OAAM,SAAUM,gBAAgBA,CAC5BC,YAAwB,EAAEC,MAAkB,EAAEC,SAAiB,EAC/DC,SAAiB,EAAEC,SAAiB,EAAEC,IAAoB;EAC5D,MAAMC,MAAM,GACRlB,IAAI,CAACmB,iBAAiB,CAAC,OAAO,EAAEL,SAAS,GAAGE,SAAS,CAAe;EACxE,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,SAAS,EAAE,EAAEM,CAAC,EAAE;IAClC,MAAMC,iBAAiB,GACnBT,YAAY,CAACU,KAAK,CAACF,CAAC,GAAGL,SAAS,EAAE,CAACK,CAAC,GAAG,CAAC,IAAIL,SAAS,CAAC;IAC1D,MAAMQ,YAAY,GAAGH,CAAC,GAAGJ,SAAS;IAClC,KAAK,IAAIQ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGR,SAAS,EAAE,EAAEQ,CAAC,EAAE;MAClCN,MAAM,CAACK,YAAY,GAAGC,CAAC,CAAC,GAAGP,IAAI,KAAK,MAAM,GACtChB,UAAU,CAACoB,iBAAiB,EAAER,MAAM,CAACW,CAAC,GAAGD,YAAY,CAAC,CAAC,GACvDb,UAAU,CAACW,iBAAiB,EAAER,MAAM,CAACW,CAAC,GAAGD,YAAY,CAAC,CAAC;;;EAG/D,OAAOL,MAAM;AACf","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}