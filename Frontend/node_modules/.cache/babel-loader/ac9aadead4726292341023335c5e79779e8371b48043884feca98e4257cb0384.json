{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { tidy, util } from '@tensorflow/tfjs-core';\n// tslint:disable-next-line: no-imports-from-dist\nimport * as tfOps from '@tensorflow/tfjs-core/dist/ops/ops_for_converter';\nimport { getParamValue } from './utils';\nexport const executeOp = (node, tensorMap, context, ops = tfOps) => {\n  switch (node.op) {\n    case 'ConcatV2':\n    case 'Concat':\n      {\n        const n = getParamValue('n', node, tensorMap, context);\n        const axis = getParamValue('axis', node, tensorMap, context);\n        let inputs = getParamValue('tensors', node, tensorMap, context);\n        inputs = inputs.slice(0, n);\n        return [ops.concat(inputs, axis)];\n      }\n    case 'Gather':\n      {\n        const input = getParamValue('x', node, tensorMap, context);\n        const indices = getParamValue('indices', node, tensorMap, context);\n        return [ops.gather(input, ops.cast(indices, 'int32'), 0)];\n      }\n    case 'GatherV2':\n      {\n        const axis = getParamValue('axis', node, tensorMap, context);\n        const batchDims = getParamValue('batchDims', node, tensorMap, context);\n        const input = getParamValue('x', node, tensorMap, context);\n        const indices = getParamValue('indices', node, tensorMap, context);\n        return [ops.gather(input, ops.cast(indices, 'int32'), axis, batchDims)];\n      }\n    case 'Reverse':\n      {\n        const dims = getParamValue('dims', node, tensorMap, context);\n        const axis = [];\n        for (let i = 0; i < dims.length; i++) {\n          if (dims[i]) {\n            axis.push(i);\n          }\n        }\n        const input = getParamValue('x', node, tensorMap, context);\n        return [ops.reverse(input, axis)];\n      }\n    case 'ReverseV2':\n      {\n        const axis = getParamValue('axis', node, tensorMap, context);\n        const input = getParamValue('x', node, tensorMap, context);\n        return [ops.reverse(input, axis)];\n      }\n    case 'Slice':\n      {\n        // tslint:disable-next-line:no-any\n        const begin = getParamValue('begin', node, tensorMap, context);\n        // tslint:disable-next-line:no-any\n        const size = getParamValue('size', node, tensorMap, context);\n        return [ops.slice(getParamValue('x', node, tensorMap, context), begin, size)];\n      }\n    case 'StridedSlice':\n      {\n        const begin = getParamValue('begin', node, tensorMap, context);\n        const end = getParamValue('end', node, tensorMap, context);\n        const strides = getParamValue('strides', node, tensorMap, context);\n        const beginMask = getParamValue('beginMask', node, tensorMap, context);\n        const endMask = getParamValue('endMask', node, tensorMap, context);\n        const ellipsisMask = getParamValue('ellipsisMask', node, tensorMap, context);\n        const newAxisMask = getParamValue('newAxisMask', node, tensorMap, context);\n        const shrinkAxisMask = getParamValue('shrinkAxisMask', node, tensorMap, context);\n        const tensor = getParamValue('x', node, tensorMap, context);\n        return [ops.stridedSlice(tensor, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask)];\n      }\n    case 'Pack':\n      {\n        return tidy(() => {\n          const axis = getParamValue('axis', node, tensorMap, context);\n          const tensors = getParamValue('tensors', node, tensorMap, context);\n          // Reshape the tensors to the first tensor's shape if they don't\n          // match.\n          const shape = tensors[0].shape;\n          const squeezedShape = ops.squeeze(tensors[0]).shape;\n          const mapped = tensors.map(tensor => {\n            const sameShape = util.arraysEqual(tensor.shape, shape);\n            if (!sameShape && !util.arraysEqual(ops.squeeze(tensor).shape, squeezedShape)) {\n              throw new Error('the input tensors shape does not match');\n            }\n            return sameShape ? tensor : ops.reshape(tensor, shape);\n          });\n          return [ops.stack(mapped, axis)];\n        });\n      }\n    case 'Unpack':\n      {\n        const axis = getParamValue('axis', node, tensorMap, context);\n        const tensor = getParamValue('tensor', node, tensorMap, context);\n        return ops.unstack(tensor, axis);\n      }\n    case 'Tile':\n      {\n        const reps = getParamValue('reps', node, tensorMap, context);\n        return [ops.tile(getParamValue('x', node, tensorMap, context), reps)];\n      }\n    case 'Split':\n    case 'SplitV':\n      {\n        const axis = getParamValue('axis', node, tensorMap, context);\n        const numOrSizeSplits = getParamValue('numOrSizeSplits', node, tensorMap, context);\n        const tensor = getParamValue('x', node, tensorMap, context);\n        return ops.split(tensor, numOrSizeSplits, axis);\n      }\n    case 'ScatterNd':\n      {\n        const indices = getParamValue('indices', node, tensorMap, context);\n        const values = getParamValue('values', node, tensorMap, context);\n        const shape = getParamValue('shape', node, tensorMap, context);\n        return [ops.scatterND(indices, values, shape)];\n      }\n    case 'GatherNd':\n      {\n        const x = getParamValue('x', node, tensorMap, context);\n        const indices = getParamValue('indices', node, tensorMap, context);\n        return [ops.gatherND(x, indices)];\n      }\n    case 'SparseToDense':\n      {\n        const indices = getParamValue('sparseIndices', node, tensorMap, context);\n        const shape = getParamValue('outputShape', node, tensorMap, context);\n        const sparseValues = getParamValue('sparseValues', node, tensorMap, context);\n        const defaultValue = getParamValue('defaultValue', node, tensorMap, context);\n        return [ops.sparseToDense(indices, sparseValues, shape, sparseValues.dtype === defaultValue.dtype ? defaultValue : ops.cast(defaultValue, sparseValues.dtype))];\n      }\n    case 'TensorScatterUpdate':\n      {\n        const indices = getParamValue('indices', node, tensorMap, context);\n        const values = getParamValue('values', node, tensorMap, context);\n        const tensor = getParamValue('tensor', node, tensorMap, context);\n        return [ops.tensorScatterUpdate(tensor, indices, values)];\n      }\n    default:\n      throw TypeError(`Node type ${node.op} is not implemented`);\n  }\n};\nexport const CATEGORY = 'slice_join';","map":{"version":3,"names":["tidy","util","tfOps","getParamValue","executeOp","node","tensorMap","context","ops","op","n","axis","inputs","slice","concat","input","indices","gather","cast","batchDims","dims","i","length","push","reverse","begin","size","end","strides","beginMask","endMask","ellipsisMask","newAxisMask","shrinkAxisMask","tensor","stridedSlice","tensors","shape","squeezedShape","squeeze","mapped","map","sameShape","arraysEqual","Error","reshape","stack","unstack","reps","tile","numOrSizeSplits","split","values","scatterND","x","gatherND","sparseValues","defaultValue","sparseToDense","dtype","tensorScatterUpdate","TypeError","CATEGORY"],"sources":["/Users/jonchen/Documents/HackPSU/tfjs-converter/src/operations/executors/slice_join_executor.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Scalar, Tensor, Tensor1D, tidy, util} from '@tensorflow/tfjs-core';\n// tslint:disable-next-line: no-imports-from-dist\nimport * as tfOps from '@tensorflow/tfjs-core/dist/ops/ops_for_converter';\n\nimport {NamedTensorsMap} from '../../data/types';\nimport {ExecutionContext} from '../../executor/execution_context';\nimport {InternalOpExecutor, Node} from '../types';\n\nimport {getParamValue} from './utils';\n\nexport const executeOp: InternalOpExecutor =\n    (node: Node, tensorMap: NamedTensorsMap, context: ExecutionContext,\n     ops = tfOps): Tensor[] => {\n      switch (node.op) {\n        case 'ConcatV2':\n        case 'Concat': {\n          const n = getParamValue('n', node, tensorMap, context) as number;\n          const axis =\n              getParamValue('axis', node, tensorMap, context) as number;\n          let inputs =\n              getParamValue('tensors', node, tensorMap, context) as Tensor[];\n          inputs = inputs.slice(0, n);\n          return [ops.concat(inputs, axis)];\n        }\n        case 'Gather': {\n          const input = getParamValue('x', node, tensorMap, context) as Tensor;\n          const indices =\n              getParamValue('indices', node, tensorMap, context) as Tensor1D;\n          return [ops.gather(input, ops.cast(indices, 'int32'), 0)];\n        }\n        case 'GatherV2': {\n          const axis =\n              getParamValue('axis', node, tensorMap, context) as number;\n          const batchDims =\n              getParamValue('batchDims', node, tensorMap, context) as number;\n          const input = getParamValue('x', node, tensorMap, context) as Tensor;\n          const indices =\n              getParamValue('indices', node, tensorMap, context) as Tensor1D;\n          return [ops.gather(\n              input, ops.cast(indices, 'int32'), axis, batchDims)];\n        }\n        case 'Reverse': {\n          const dims =\n              getParamValue('dims', node, tensorMap, context) as boolean[];\n          const axis = [];\n          for (let i = 0; i < dims.length; i++) {\n            if (dims[i]) {\n              axis.push(i);\n            }\n          }\n          const input = getParamValue('x', node, tensorMap, context) as Tensor;\n          return [ops.reverse(input, axis)];\n        }\n        case 'ReverseV2': {\n          const axis =\n              getParamValue('axis', node, tensorMap, context) as number[];\n          const input = getParamValue('x', node, tensorMap, context) as Tensor;\n          return [ops.reverse(input, axis)];\n        }\n        case 'Slice': {\n          // tslint:disable-next-line:no-any\n          const begin = getParamValue('begin', node, tensorMap, context) as any;\n          // tslint:disable-next-line:no-any\n          const size = getParamValue('size', node, tensorMap, context) as any;\n          return [ops.slice(\n              getParamValue('x', node, tensorMap, context) as Tensor, begin,\n              size)];\n        }\n        case 'StridedSlice': {\n          const begin =\n              getParamValue('begin', node, tensorMap, context) as number[];\n          const end =\n              getParamValue('end', node, tensorMap, context) as number[];\n          const strides =\n              getParamValue('strides', node, tensorMap, context) as number[];\n          const beginMask =\n              getParamValue('beginMask', node, tensorMap, context) as number;\n          const endMask =\n              getParamValue('endMask', node, tensorMap, context) as number;\n          const ellipsisMask =\n              getParamValue('ellipsisMask', node, tensorMap, context) as number;\n          const newAxisMask =\n              getParamValue('newAxisMask', node, tensorMap, context) as number;\n          const shrinkAxisMask =\n              getParamValue('shrinkAxisMask', node, tensorMap, context) as\n              number;\n          const tensor = getParamValue('x', node, tensorMap, context) as Tensor;\n\n          return [ops.stridedSlice(\n              tensor, begin, end, strides, beginMask, endMask, ellipsisMask,\n              newAxisMask, shrinkAxisMask)];\n        }\n        case 'Pack': {\n          return tidy(() => {\n            const axis =\n                getParamValue('axis', node, tensorMap, context) as number;\n            const tensors =\n                getParamValue('tensors', node, tensorMap, context) as Tensor[];\n            // Reshape the tensors to the first tensor's shape if they don't\n            // match.\n            const shape = tensors[0].shape;\n            const squeezedShape = ops.squeeze(tensors[0]).shape;\n            const mapped = tensors.map(tensor => {\n              const sameShape = util.arraysEqual(tensor.shape, shape);\n              if (!sameShape &&\n                  !util.arraysEqual(ops.squeeze(tensor).shape, squeezedShape)) {\n                throw new Error('the input tensors shape does not match');\n              }\n              return sameShape ? tensor : ops.reshape(tensor, shape);\n            });\n            return [ops.stack(mapped, axis)];\n          });\n        }\n        case 'Unpack': {\n          const axis =\n              getParamValue('axis', node, tensorMap, context) as number;\n          const tensor =\n              getParamValue('tensor', node, tensorMap, context) as Tensor;\n          return ops.unstack(tensor, axis);\n        }\n        case 'Tile': {\n          const reps =\n              getParamValue('reps', node, tensorMap, context) as number[];\n          return [ops.tile(\n              getParamValue('x', node, tensorMap, context) as Tensor, reps)];\n        }\n        case 'Split':\n        case 'SplitV': {\n          const axis =\n              getParamValue('axis', node, tensorMap, context) as number;\n          const numOrSizeSplits =\n              getParamValue('numOrSizeSplits', node, tensorMap, context) as\n                  number |\n              number[];\n          const tensor = getParamValue('x', node, tensorMap, context) as Tensor;\n\n          return ops.split(tensor, numOrSizeSplits, axis);\n        }\n        case 'ScatterNd': {\n          const indices =\n              getParamValue('indices', node, tensorMap, context) as Tensor;\n          const values =\n              getParamValue('values', node, tensorMap, context) as Tensor;\n          const shape =\n              getParamValue('shape', node, tensorMap, context) as number[];\n          return [ops.scatterND(indices, values, shape)];\n        }\n        case 'GatherNd': {\n          const x = getParamValue('x', node, tensorMap, context) as Tensor;\n          const indices =\n              getParamValue('indices', node, tensorMap, context) as Tensor;\n          return [ops.gatherND(x, indices)];\n        }\n        case 'SparseToDense': {\n          const indices =\n              getParamValue('sparseIndices', node, tensorMap, context) as\n              Tensor;\n          const shape =\n              getParamValue('outputShape', node, tensorMap, context) as\n              number[];\n          const sparseValues =\n              getParamValue('sparseValues', node, tensorMap, context) as Tensor;\n          const defaultValue =\n              getParamValue('defaultValue', node, tensorMap, context) as Scalar;\n          return [ops.sparseToDense(\n              indices, sparseValues, shape,\n              sparseValues.dtype === defaultValue.dtype ?\n                  defaultValue :\n                  ops.cast(defaultValue, sparseValues.dtype))];\n        }\n        case 'TensorScatterUpdate': {\n          const indices =\n              getParamValue('indices', node, tensorMap, context) as Tensor;\n          const values =\n              getParamValue('values', node, tensorMap, context) as Tensor;\n          const tensor =\n              getParamValue('tensor', node, tensorMap, context) as Tensor;\n          return [ops.tensorScatterUpdate(tensor, indices, values)];\n        }\n        default:\n          throw TypeError(`Node type ${node.op} is not implemented`);\n      }\n    };\n\nexport const CATEGORY = 'slice_join';\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}