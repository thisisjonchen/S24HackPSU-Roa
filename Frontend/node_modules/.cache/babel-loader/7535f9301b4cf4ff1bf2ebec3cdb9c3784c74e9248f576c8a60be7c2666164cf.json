{"ast":null,"code":"/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { TensorScatterUpdate } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport { op } from './operation';\nimport * as scatter_nd_util from './scatter_nd_util';\n/**\n * Creates a new tensor by applying sparse updates to individual\n * values or slices to the passed in tensor according to\n * indices. This operator is the similar to scatterNd op, except that the\n * udpates are scattered on an existing tensor (as opposed to a zero-tensor).\n *\n * If indices contains duplicates, then we pick the last update for the index.\n *\n * If an out of bound index is found on CPU, an error is returned.\n *\n * Warning: There are some GPU specific semantics for this operation.\n *  - If an out of bound index is found, the index is ignored.\n *  - The order in which updates are applied is nondeterministic, so the output\n * will be nondeterministic if indices contains duplicates.\n * ```js\n * const shape = [8];\n * const tensor = tf.ones(shape);\n * const indices = tf.tensor2d([4, 3, 1, 7], [4, 1], 'int32');\n * const updates = tf.tensor1d([9, 10, 11, 12]);\n *\n * tf.tensorScatterUpdate(tensor, indices, updates).print();\n *    //[1, 11, 1, 10, 9, 1, 1, 12]\n * ```\n *\n * @param tensor A Tensor. Tensor to copy/update.\n * @param indices The tensor contains the indices into the output tensor, must\n *     have at least 2 axes: (num_updates, index_depth).\n * @param updates The tensor contains the value for the indices.\n *\n * @doc {heading: 'Operations', subheading: 'Slicing and Joining'}\n */\nfunction tensorScatterUpdate_(tensor, indices, updates) {\n  const $tensor = convertToTensor(tensor, 'tensor', 'tensorScatterupdate');\n  const $indices = convertToTensor(indices, 'indices', 'tensorScatterupdate', 'int32');\n  const $updates = convertToTensor(updates, 'updates', 'tensorScatterupdate');\n  scatter_nd_util.validateInput($updates, $indices, $tensor.shape);\n  if ($tensor.dtype !== $updates.dtype) {\n    throw new Error(`tensor and updates must have the same dtype, instead they are ${$tensor.dtype} and ${$updates.dtype}.`);\n  }\n  const inputs = {\n    tensor: $tensor,\n    indices: $indices,\n    updates: $updates\n  };\n  const attrs = {};\n  // tslint:disable-next-line: no-unnecessary-type-assertion\n  return ENGINE.runKernel(TensorScatterUpdate, inputs, attrs);\n}\nexport const tensorScatterUpdate = op({\n  tensorScatterUpdate_\n});","map":{"version":3,"names":["ENGINE","TensorScatterUpdate","convertToTensor","op","scatter_nd_util","tensorScatterUpdate_","tensor","indices","updates","$tensor","$indices","$updates","validateInput","shape","dtype","Error","inputs","attrs","runKernel","tensorScatterUpdate"],"sources":["/Users/jonchen/Documents/HackPSU/tfjs-core/src/ops/tensor_scatter_update.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {TensorScatterUpdate, TensorScatterUpdateAttrs, TensorScatterUpdateInputs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {Rank, TensorLike} from '../types';\n\nimport {op} from './operation';\nimport * as scatter_nd_util from './scatter_nd_util';\n\n/**\n * Creates a new tensor by applying sparse updates to individual\n * values or slices to the passed in tensor according to\n * indices. This operator is the similar to scatterNd op, except that the\n * udpates are scattered on an existing tensor (as opposed to a zero-tensor).\n *\n * If indices contains duplicates, then we pick the last update for the index.\n *\n * If an out of bound index is found on CPU, an error is returned.\n *\n * Warning: There are some GPU specific semantics for this operation.\n *  - If an out of bound index is found, the index is ignored.\n *  - The order in which updates are applied is nondeterministic, so the output\n * will be nondeterministic if indices contains duplicates.\n * ```js\n * const shape = [8];\n * const tensor = tf.ones(shape);\n * const indices = tf.tensor2d([4, 3, 1, 7], [4, 1], 'int32');\n * const updates = tf.tensor1d([9, 10, 11, 12]);\n *\n * tf.tensorScatterUpdate(tensor, indices, updates).print();\n *    //[1, 11, 1, 10, 9, 1, 1, 12]\n * ```\n *\n * @param tensor A Tensor. Tensor to copy/update.\n * @param indices The tensor contains the indices into the output tensor, must\n *     have at least 2 axes: (num_updates, index_depth).\n * @param updates The tensor contains the value for the indices.\n *\n * @doc {heading: 'Operations', subheading: 'Slicing and Joining'}\n */\nfunction tensorScatterUpdate_<R extends Rank>(\n    tensor: Tensor<R>|TensorLike, indices: Tensor|TensorLike,\n    updates: Tensor|TensorLike): Tensor<R> {\n  const $tensor = convertToTensor(tensor, 'tensor', 'tensorScatterupdate');\n  const $indices =\n      convertToTensor(indices, 'indices', 'tensorScatterupdate', 'int32');\n  const $updates = convertToTensor(updates, 'updates', 'tensorScatterupdate');\n  scatter_nd_util.validateInput($updates, $indices, $tensor.shape);\n  if ($tensor.dtype !== $updates.dtype) {\n    throw new Error(\n        `tensor and updates must have the same dtype, instead they are ${\n            $tensor.dtype} and ${$updates.dtype}.`);\n  }\n\n  const inputs: TensorScatterUpdateInputs = {\n    tensor: $tensor,\n    indices: $indices,\n    updates: $updates\n  };\n  const attrs: TensorScatterUpdateAttrs = {};\n\n  // tslint:disable-next-line: no-unnecessary-type-assertion\n  return ENGINE.runKernel(\n             TensorScatterUpdate, inputs as unknown as NamedTensorMap,\n             attrs as unknown as NamedAttrMap) as Tensor<R>;\n}\n\nexport const tensorScatterUpdate = op({tensorScatterUpdate_});\n"],"mappings":"AAAA;;;;;;;;;;;;;;;;AAiBA,SAAQA,MAAM,QAAO,WAAW;AAChC,SAAQC,mBAAmB,QAA4D,iBAAiB;AAIxG,SAAQC,eAAe,QAAO,oBAAoB;AAGlD,SAAQC,EAAE,QAAO,aAAa;AAC9B,OAAO,KAAKC,eAAe,MAAM,mBAAmB;AAEpD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+BA,SAASC,oBAAoBA,CACzBC,MAA4B,EAAEC,OAA0B,EACxDC,OAA0B;EAC5B,MAAMC,OAAO,GAAGP,eAAe,CAACI,MAAM,EAAE,QAAQ,EAAE,qBAAqB,CAAC;EACxE,MAAMI,QAAQ,GACVR,eAAe,CAACK,OAAO,EAAE,SAAS,EAAE,qBAAqB,EAAE,OAAO,CAAC;EACvE,MAAMI,QAAQ,GAAGT,eAAe,CAACM,OAAO,EAAE,SAAS,EAAE,qBAAqB,CAAC;EAC3EJ,eAAe,CAACQ,aAAa,CAACD,QAAQ,EAAED,QAAQ,EAAED,OAAO,CAACI,KAAK,CAAC;EAChE,IAAIJ,OAAO,CAACK,KAAK,KAAKH,QAAQ,CAACG,KAAK,EAAE;IACpC,MAAM,IAAIC,KAAK,CACX,iEACIN,OAAO,CAACK,KAAK,QAAQH,QAAQ,CAACG,KAAK,GAAG,CAAC;;EAGjD,MAAME,MAAM,GAA8B;IACxCV,MAAM,EAAEG,OAAO;IACfF,OAAO,EAAEG,QAAQ;IACjBF,OAAO,EAAEG;GACV;EACD,MAAMM,KAAK,GAA6B,EAAE;EAE1C;EACA,OAAOjB,MAAM,CAACkB,SAAS,CACZjB,mBAAmB,EAAEe,MAAmC,EACxDC,KAAgC,CAAc;AAC3D;AAEA,OAAO,MAAME,mBAAmB,GAAGhB,EAAE,CAAC;EAACE;AAAoB,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}