{"ast":null,"code":"/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport var RowPartitionType;\n(function (RowPartitionType) {\n  RowPartitionType[RowPartitionType[\"FIRST_DIM_SIZE\"] = 0] = \"FIRST_DIM_SIZE\";\n  RowPartitionType[RowPartitionType[\"VALUE_ROWIDS\"] = 1] = \"VALUE_ROWIDS\";\n  RowPartitionType[RowPartitionType[\"ROW_LENGTHS\"] = 2] = \"ROW_LENGTHS\";\n  RowPartitionType[RowPartitionType[\"ROW_SPLITS\"] = 3] = \"ROW_SPLITS\";\n  RowPartitionType[RowPartitionType[\"ROW_LIMITS\"] = 4] = \"ROW_LIMITS\";\n  RowPartitionType[RowPartitionType[\"ROW_STARTS\"] = 5] = \"ROW_STARTS\";\n})(RowPartitionType || (RowPartitionType = {}));\nexport function combineRaggedTensorToTensorShapes(raggedRank, shape, valueShape) {\n  // Test for consistency of valueShape and shape specified.\n  // If shape is unspecified and valueShape is specified, then copy\n  // over the size from the valueShape dimension.\n  let outputShape = new Array();\n  if (valueShape == null && shape == null) {\n    return outputShape;\n  }\n  if (shape == null) {\n    // Here, value_shape must be of known size.\n    while (outputShape.length < raggedRank + valueShape.length) {\n      outputShape.push(-1);\n    }\n  } else {\n    outputShape = shape.slice();\n  }\n  if (valueShape == null) {\n    return outputShape;\n  }\n  // At this point, valueShape and output_shape have known ranks.\n  if (raggedRank + valueShape.length !== outputShape.length) {\n    throw new Error(`rt input.shape and shape=${shape} are incompatible: rt input.rank = ${raggedRank + valueShape.length}, but shape.rank = ${outputShape.length}`);\n  }\n  for (let i = 1; i < valueShape.length; ++i) {\n    const valueDim = valueShape[i];\n    const outputShapeDimIndex = outputShape[outputShape.length - valueShape.length + i];\n    const outputShapeDim = outputShape[outputShapeDimIndex];\n    if (valueDim >= 0) {\n      if (outputShapeDim >= 0) {\n        if (outputShapeDim !== valueDim) {\n          throw new Error(`rt input.shape and shape=${shape} are incompatible: rt input.shape[${i + raggedRank}] = ${valueDim} but shape[${i + raggedRank}] = ${outputShapeDim}`);\n        }\n      } else {\n        outputShape[outputShapeDimIndex] = valueDim;\n      }\n    }\n  }\n  return outputShape;\n}\nexport function getRowPartitionTypesHelper(rowPartitionTypeStrings) {\n  const stringToType = {\n    'FIRST_DIM_SIZE': RowPartitionType.FIRST_DIM_SIZE,\n    'VALUE_ROWIDS': RowPartitionType.VALUE_ROWIDS,\n    'ROW_LENGTHS': RowPartitionType.ROW_LENGTHS,\n    'ROW_SPLITS': RowPartitionType.ROW_SPLITS,\n    'ROW_LIMITS': RowPartitionType.ROW_LIMITS,\n    'ROW_STARTS': RowPartitionType.ROW_STARTS\n  };\n  const result = [];\n  for (const typeStr of rowPartitionTypeStrings) {\n    if (typeStr in stringToType) {\n      result.push(stringToType[typeStr]);\n    } else {\n      break;\n    }\n  }\n  return result;\n}\nexport function getRaggedRank(rowPartitionTypes) {\n  if (rowPartitionTypes.length === 0) {\n    return 0;\n  }\n  if (rowPartitionTypes[0] === RowPartitionType.FIRST_DIM_SIZE) {\n    return rowPartitionTypes.length - 1;\n  }\n  return rowPartitionTypes.length;\n}\nexport function validateDefaultValueShape(defaultValueShape, valueShape) {\n  if (defaultValueShape == null || valueShape == null) {\n    return;\n  }\n  const defaultNDims = defaultValueShape.length;\n  const valuesNDims = valueShape.length;\n  if (defaultNDims >= valuesNDims) {\n    throw new Error(`defaultValue.shape=${defaultValueShape} and ragged tensor flatValues.shape=${valueShape}, are incompatible: defaultValue.rank = ${defaultNDims} must be less than ragged tensor input flatValues.rank = ${valuesNDims})`);\n  }\n  for (let i = 0; i < Math.min(defaultNDims, valuesNDims - 1); ++i) {\n    const defaultDim = defaultValueShape[i];\n    const valueDim = valueShape[i + 1];\n    if (defaultDim >= 0 && valueDim >= 0 && defaultDim !== 1 && defaultDim !== valueDim) {\n      throw new Error(`defaultValue.shape=${defaultValueShape}, and ragged tensor input flatValues.shape=${valueShape} are incompatible: defaultValue.shape[${i - defaultValueShape.length}] = ${defaultDim} but ragged tensor input.flatValues.shape[${i - defaultValueShape.length}] = ${valueDim}`);\n    }\n  }\n}","map":{"version":3,"names":["RowPartitionType","combineRaggedTensorToTensorShapes","raggedRank","shape","valueShape","outputShape","Array","length","push","slice","Error","i","valueDim","outputShapeDimIndex","outputShapeDim","getRowPartitionTypesHelper","rowPartitionTypeStrings","stringToType","FIRST_DIM_SIZE","VALUE_ROWIDS","ROW_LENGTHS","ROW_SPLITS","ROW_LIMITS","ROW_STARTS","result","typeStr","getRaggedRank","rowPartitionTypes","validateDefaultValueShape","defaultValueShape","defaultNDims","valuesNDims","Math","min","defaultDim"],"sources":["/Users/jonchen/Documents/HackPSU/tfjs-core/src/ops/ragged_to_dense_util.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nexport enum RowPartitionType {\n  FIRST_DIM_SIZE,\n  VALUE_ROWIDS,\n  ROW_LENGTHS,\n  ROW_SPLITS,\n  ROW_LIMITS,\n  ROW_STARTS\n}\n\nexport function combineRaggedTensorToTensorShapes(\n    raggedRank: number, shape: number[], valueShape: number[]) {\n  // Test for consistency of valueShape and shape specified.\n  // If shape is unspecified and valueShape is specified, then copy\n  // over the size from the valueShape dimension.\n\n  let outputShape: number[] = new Array();\n  if (valueShape == null && shape == null) {\n    return outputShape;\n  }\n\n  if (shape == null) {\n    // Here, value_shape must be of known size.\n    while (outputShape.length < raggedRank + valueShape.length) {\n      outputShape.push(-1);\n    }\n  } else {\n    outputShape = shape.slice();\n  }\n  if (valueShape == null) {\n    return outputShape;\n  }\n  // At this point, valueShape and output_shape have known ranks.\n  if (raggedRank + valueShape.length !== outputShape.length) {\n    throw new Error(\n        `rt input.shape and shape=${shape} are incompatible: rt input.rank = ${\n            raggedRank +\n            valueShape.length}, but shape.rank = ${outputShape.length}`);\n  }\n\n  for (let i = 1; i < valueShape.length; ++i) {\n    const valueDim = valueShape[i];\n    const outputShapeDimIndex =\n        outputShape[outputShape.length - valueShape.length + i];\n    const outputShapeDim = outputShape[outputShapeDimIndex];\n\n    if (valueDim >= 0) {\n      if (outputShapeDim >= 0) {\n        if (outputShapeDim !== valueDim) {\n          throw new Error(`rt input.shape and shape=${\n              shape} are incompatible: rt input.shape[${i + raggedRank}] = ${\n              valueDim} but shape[${i + raggedRank}] = ${outputShapeDim}`);\n        }\n      } else {\n        outputShape[outputShapeDimIndex] = valueDim;\n      }\n    }\n  }\n  return outputShape;\n}\n\nexport function getRowPartitionTypesHelper(rowPartitionTypeStrings: string[]) {\n  const stringToType = {\n    'FIRST_DIM_SIZE': RowPartitionType.FIRST_DIM_SIZE,\n    'VALUE_ROWIDS': RowPartitionType.VALUE_ROWIDS,\n    'ROW_LENGTHS': RowPartitionType.ROW_LENGTHS,\n    'ROW_SPLITS': RowPartitionType.ROW_SPLITS,\n    'ROW_LIMITS': RowPartitionType.ROW_LIMITS,\n    'ROW_STARTS': RowPartitionType.ROW_STARTS\n  };\n\n  const result: RowPartitionType[] = [];\n  for (const typeStr of rowPartitionTypeStrings) {\n    if (typeStr in stringToType) {\n      result.push(stringToType[typeStr as keyof typeof stringToType]);\n    } else {\n      break;\n    }\n  }\n\n  return result;\n}\n\nexport function getRaggedRank(rowPartitionTypes: RowPartitionType[]) {\n  if (rowPartitionTypes.length === 0) {\n    return 0;\n  }\n  if (rowPartitionTypes[0] === RowPartitionType.FIRST_DIM_SIZE) {\n    return rowPartitionTypes.length - 1;\n  }\n  return rowPartitionTypes.length;\n}\n\nexport function validateDefaultValueShape(\n    defaultValueShape: number[], valueShape: number[]) {\n  if (defaultValueShape == null || valueShape == null) {\n    return;\n  }\n\n  const defaultNDims = defaultValueShape.length;\n  const valuesNDims = valueShape.length;\n  if (defaultNDims >= valuesNDims) {\n    throw new Error(`defaultValue.shape=${\n        defaultValueShape} and ragged tensor flatValues.shape=${\n        valueShape}, are incompatible: defaultValue.rank = ${\n        defaultNDims} must be less than ragged tensor input flatValues.rank = ${\n        valuesNDims})`);\n  }\n  for (let i = 0; i < Math.min(defaultNDims, valuesNDims - 1); ++i) {\n    const defaultDim = defaultValueShape[i];\n    const valueDim = valueShape[i + 1];\n    if (defaultDim >= 0 && valueDim >= 0 && defaultDim !== 1 &&\n        defaultDim !== valueDim) {\n      throw new Error(`defaultValue.shape=${\n          defaultValueShape}, and ragged tensor input flatValues.shape=${\n          valueShape} are incompatible: defaultValue.shape[${\n          i - defaultValueShape.length}] = ${\n          defaultDim} but ragged tensor input.flatValues.shape[${\n          i - defaultValueShape.length}] = ${valueDim}`);\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}