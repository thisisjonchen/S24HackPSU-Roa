{"ast":null,"code":"/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env } from '@tensorflow/tfjs-core';\nexport class SearchSortedProgram {\n  constructor(batchSize, numInputs, numValues, side) {\n    this.variableNames = ['sortedSequence', 'values'];\n    this.customUniforms = [{\n      name: 'numInputs',\n      type: 'int'\n    }];\n    this.outputShape = [batchSize, numValues];\n    const webGL2LoopHead = 'while (left < right) {';\n    // WebGL1 doesn't accept non constant loop conditions, so upper bound loop\n    // iterations.\n    const webGL1LoopHead = `for (int i = 0; i < ${Math.ceil(Math.log2(numInputs + 1))}; ++i) { if (left >= right) break;`;\n    const loopHead = env().getNumber('WEBGL_VERSION') === 2 ? webGL2LoopHead : webGL1LoopHead;\n    // left corresponds to lower bound and right to upper bound.\n    const boundComparator = side === 'left' ? '<' : '<=';\n    this.userCode = `\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${loopHead}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${boundComparator} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `;\n  }\n}","map":{"version":3,"names":["env","SearchSortedProgram","constructor","batchSize","numInputs","numValues","side","variableNames","customUniforms","name","type","outputShape","webGL2LoopHead","webGL1LoopHead","Math","ceil","log2","loopHead","getNumber","boundComparator","userCode"],"sources":["/Users/jonchen/Documents/HackPSU/tfjs-backend-webgl/src/search_sorted_gpu.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\nimport {UniformType} from './shader_compiler';\n\nexport class SearchSortedProgram implements GPGPUProgram {\n  variableNames = ['sortedSequence', 'values'];\n  outputShape: number[];\n  userCode: string;\n  customUniforms = [{name: 'numInputs', type: 'int' as UniformType}];\n\n  constructor(\n      batchSize: number, numInputs: number, numValues: number,\n      side: 'left'|'right') {\n    this.outputShape = [batchSize, numValues];\n\n    const webGL2LoopHead = 'while (left < right) {';\n    // WebGL1 doesn't accept non constant loop conditions, so upper bound loop\n    // iterations.\n    const webGL1LoopHead = `for (int i = 0; i < ${\n        Math.ceil(Math.log2(numInputs + 1))}; ++i) { if (left >= right) break;`;\n    const loopHead = env().getNumber('WEBGL_VERSION') === 2 ? webGL2LoopHead :\n                                                              webGL1LoopHead;\n\n    // left corresponds to lower bound and right to upper bound.\n    const boundComparator = side === 'left' ? '<' : '<=';\n    this.userCode = `\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${loopHead}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${boundComparator} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `;\n  }\n}\n"],"mappings":"AAAA;;;;;;;;;;;;;;;;AAiBA,SAAQA,GAAG,QAAO,uBAAuB;AAIzC,OAAM,MAAOC,mBAAmB;EAM9BC,YACIC,SAAiB,EAAEC,SAAiB,EAAEC,SAAiB,EACvDC,IAAoB;IAPxB,KAAAC,aAAa,GAAG,CAAC,gBAAgB,EAAE,QAAQ,CAAC;IAG5C,KAAAC,cAAc,GAAG,CAAC;MAACC,IAAI,EAAE,WAAW;MAAEC,IAAI,EAAE;IAAoB,CAAC,CAAC;IAKhE,IAAI,CAACC,WAAW,GAAG,CAACR,SAAS,EAAEE,SAAS,CAAC;IAEzC,MAAMO,cAAc,GAAG,wBAAwB;IAC/C;IACA;IACA,MAAMC,cAAc,GAAG,uBACnBC,IAAI,CAACC,IAAI,CAACD,IAAI,CAACE,IAAI,CAACZ,SAAS,GAAG,CAAC,CAAC,CAAC,oCAAoC;IAC3E,MAAMa,QAAQ,GAAGjB,GAAG,EAAE,CAACkB,SAAS,CAAC,eAAe,CAAC,KAAK,CAAC,GAAGN,cAAc,GACdC,cAAc;IAExE;IACA,MAAMM,eAAe,GAAGb,IAAI,KAAK,MAAM,GAAG,GAAG,GAAG,IAAI;IACpD,IAAI,CAACc,QAAQ,GAAG;;;;;WAKTH,QAAQ;;+CAE4BE,eAAe;;;;;;;;;;;;;;;;;;MAkBxD;EACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}