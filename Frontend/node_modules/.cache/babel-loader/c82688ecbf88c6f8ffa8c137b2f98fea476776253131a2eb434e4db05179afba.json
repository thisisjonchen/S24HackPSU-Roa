{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { sizeFromShape } from '../util';\nimport { assertNonNegativeIntegerDimensions } from '../util_base';\nimport { op } from './operation';\n/**\n * Creates a `tf.Tensor` with values sampled from a random number generator\n * function defined by the user.\n *\n * @param shape An array of integers defining the output tensor shape.\n * @param randFunction A random number generator function which is called\n * for each element in the output tensor.\n * @param dtype The data type of the output tensor. Defaults to 'float32'.\n *\n * @doc {heading: 'Tensors', subheading: 'Random'}\n */\nfunction rand_(shape, randFunction, dtype) {\n  assertNonNegativeIntegerDimensions(shape);\n  const size = sizeFromShape(shape);\n  let values = null;\n  if (dtype == null || dtype === 'float32') {\n    values = new Float32Array(size);\n  } else if (dtype === 'int32') {\n    values = new Int32Array(size);\n  } else if (dtype === 'bool') {\n    values = new Uint8Array(size);\n  } else {\n    throw new Error(`Unknown data type ${dtype}`);\n  }\n  for (let i = 0; i < size; i++) {\n    values[i] = randFunction();\n  }\n  return ENGINE.makeTensor(values, shape, dtype);\n}\nexport const rand = /* @__PURE__ */op({\n  rand_\n});","map":{"version":3,"names":["ENGINE","sizeFromShape","assertNonNegativeIntegerDimensions","op","rand_","shape","randFunction","dtype","size","values","Float32Array","Int32Array","Uint8Array","Error","i","makeTensor","rand"],"sources":["/Users/jonchen/Documents/HackPSU/tfjs-core/src/ops/rand.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Tensor} from '../tensor';\nimport {DataType, Rank, ShapeMap} from '../types';\nimport {sizeFromShape} from '../util';\nimport {assertNonNegativeIntegerDimensions} from '../util_base';\n\nimport {op} from './operation';\n\n/**\n * Creates a `tf.Tensor` with values sampled from a random number generator\n * function defined by the user.\n *\n * @param shape An array of integers defining the output tensor shape.\n * @param randFunction A random number generator function which is called\n * for each element in the output tensor.\n * @param dtype The data type of the output tensor. Defaults to 'float32'.\n *\n * @doc {heading: 'Tensors', subheading: 'Random'}\n */\nfunction rand_<R extends Rank>(\n    shape: ShapeMap[R], randFunction: () => number,\n    dtype?: DataType): Tensor<R> {\n  assertNonNegativeIntegerDimensions(shape);\n  const size = sizeFromShape(shape);\n  let values = null;\n  if (dtype == null || dtype === 'float32') {\n    values = new Float32Array(size);\n  } else if (dtype === 'int32') {\n    values = new Int32Array(size);\n  } else if (dtype === 'bool') {\n    values = new Uint8Array(size);\n  } else {\n    throw new Error(`Unknown data type ${dtype}`);\n  }\n  for (let i = 0; i < size; i++) {\n    values[i] = randFunction();\n  }\n  return ENGINE.makeTensor(values, shape, dtype) as Tensor<R>;\n}\n\nexport const rand = /* @__PURE__ */ op({rand_});\n"],"mappings":"AAAA;;;;;;;;;;;;;;;;AAiBA,SAAQA,MAAM,QAAO,WAAW;AAGhC,SAAQC,aAAa,QAAO,SAAS;AACrC,SAAQC,kCAAkC,QAAO,cAAc;AAE/D,SAAQC,EAAE,QAAO,aAAa;AAE9B;;;;;;;;;;;AAWA,SAASC,KAAKA,CACVC,KAAkB,EAAEC,YAA0B,EAC9CC,KAAgB;EAClBL,kCAAkC,CAACG,KAAK,CAAC;EACzC,MAAMG,IAAI,GAAGP,aAAa,CAACI,KAAK,CAAC;EACjC,IAAII,MAAM,GAAG,IAAI;EACjB,IAAIF,KAAK,IAAI,IAAI,IAAIA,KAAK,KAAK,SAAS,EAAE;IACxCE,MAAM,GAAG,IAAIC,YAAY,CAACF,IAAI,CAAC;GAChC,MAAM,IAAID,KAAK,KAAK,OAAO,EAAE;IAC5BE,MAAM,GAAG,IAAIE,UAAU,CAACH,IAAI,CAAC;GAC9B,MAAM,IAAID,KAAK,KAAK,MAAM,EAAE;IAC3BE,MAAM,GAAG,IAAIG,UAAU,CAACJ,IAAI,CAAC;GAC9B,MAAM;IACL,MAAM,IAAIK,KAAK,CAAC,qBAAqBN,KAAK,EAAE,CAAC;;EAE/C,KAAK,IAAIO,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,IAAI,EAAEM,CAAC,EAAE,EAAE;IAC7BL,MAAM,CAACK,CAAC,CAAC,GAAGR,YAAY,EAAE;;EAE5B,OAAON,MAAM,CAACe,UAAU,CAACN,MAAM,EAAEJ,KAAK,EAAEE,KAAK,CAAc;AAC7D;AAEA,OAAO,MAAMS,IAAI,GAAG,eAAgBb,EAAE,CAAC;EAACC;AAAK,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}