{"ast":null,"code":"/**\n * Validate sparseToDense inputs.\n *\n * @param sparseIndices A 0-D, 1-D, or 2-D Tensor of type int32.\n * sparseIndices[i] contains the complete index where sparseValues[i] will be\n * placed.\n * @param sparseValues A 0-D or 1-D Tensor. Values\n * corresponding to each row of sparseIndices, or a scalar value to be used for\n * all sparse indices.\n * @param outputShape number[]. Shape of the dense output tensor.\n * @param validateIndices boolean. indice validation is not supported, error\n * will be thrown if it is set.\n */\nexport function validateInput(sparseIndices, sparseValues, outputShape, defaultValues) {\n  if (sparseIndices.dtype !== 'int32') {\n    throw new Error('tf.sparseToDense() expects the indices to be int32 type,' + ` but the dtype was ${sparseIndices.dtype}.`);\n  }\n  if (sparseIndices.rank > 2) {\n    throw new Error('sparseIndices should be a scalar, vector, or matrix,' + ` but got shape ${sparseIndices.shape}.`);\n  }\n  const numElems = sparseIndices.rank > 0 ? sparseIndices.shape[0] : 1;\n  const numDims = sparseIndices.rank > 1 ? sparseIndices.shape[1] : 1;\n  if (outputShape.length !== numDims) {\n    throw new Error('outputShape has incorrect number of elements:,' + ` ${outputShape.length}, should be: ${numDims}.`);\n  }\n  const numValues = sparseValues.size;\n  if (!(sparseValues.rank === 0 || sparseValues.rank === 1 && numValues === numElems)) {\n    throw new Error('sparseValues has incorrect shape ' + `${sparseValues.shape}, should be [] or [${numElems}]`);\n  }\n  if (sparseValues.dtype !== defaultValues.dtype) {\n    throw new Error('sparseValues.dtype must match defaultValues.dtype');\n  }\n}","map":{"version":3,"names":["validateInput","sparseIndices","sparseValues","outputShape","defaultValues","dtype","Error","rank","shape","numElems","numDims","length","numValues","size"],"sources":["/Users/jonchen/Documents/HackPSU/tfjs-core/src/ops/sparse_to_dense_util.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {Tensor} from '../tensor';\n\n/**\n * Validate sparseToDense inputs.\n *\n * @param sparseIndices A 0-D, 1-D, or 2-D Tensor of type int32.\n * sparseIndices[i] contains the complete index where sparseValues[i] will be\n * placed.\n * @param sparseValues A 0-D or 1-D Tensor. Values\n * corresponding to each row of sparseIndices, or a scalar value to be used for\n * all sparse indices.\n * @param outputShape number[]. Shape of the dense output tensor.\n * @param validateIndices boolean. indice validation is not supported, error\n * will be thrown if it is set.\n */\nexport function validateInput(\n    sparseIndices: Tensor, sparseValues: Tensor, outputShape: number[],\n    defaultValues: Tensor) {\n  if (sparseIndices.dtype !== 'int32') {\n    throw new Error(\n        'tf.sparseToDense() expects the indices to be int32 type,' +\n        ` but the dtype was ${sparseIndices.dtype}.`);\n  }\n  if (sparseIndices.rank > 2) {\n    throw new Error(\n        'sparseIndices should be a scalar, vector, or matrix,' +\n        ` but got shape ${sparseIndices.shape}.`);\n  }\n\n  const numElems = sparseIndices.rank > 0 ? sparseIndices.shape[0] : 1;\n  const numDims = sparseIndices.rank > 1 ? sparseIndices.shape[1] : 1;\n\n  if (outputShape.length !== numDims) {\n    throw new Error(\n        'outputShape has incorrect number of elements:,' +\n        ` ${outputShape.length}, should be: ${numDims}.`);\n  }\n\n  const numValues = sparseValues.size;\n  if (!(sparseValues.rank === 0 ||\n        sparseValues.rank === 1 && numValues === numElems)) {\n    throw new Error(\n        'sparseValues has incorrect shape ' +\n        `${sparseValues.shape}, should be [] or [${numElems}]`);\n  }\n\n  if (sparseValues.dtype !== defaultValues.dtype) {\n    throw new Error('sparseValues.dtype must match defaultValues.dtype');\n  }\n}\n"],"mappings":"AAkBA;;;;;;;;;;;;;AAaA,OAAM,SAAUA,aAAaA,CACzBC,aAAqB,EAAEC,YAAoB,EAAEC,WAAqB,EAClEC,aAAqB;EACvB,IAAIH,aAAa,CAACI,KAAK,KAAK,OAAO,EAAE;IACnC,MAAM,IAAIC,KAAK,CACX,0DAA0D,GAC1D,sBAAsBL,aAAa,CAACI,KAAK,GAAG,CAAC;;EAEnD,IAAIJ,aAAa,CAACM,IAAI,GAAG,CAAC,EAAE;IAC1B,MAAM,IAAID,KAAK,CACX,sDAAsD,GACtD,kBAAkBL,aAAa,CAACO,KAAK,GAAG,CAAC;;EAG/C,MAAMC,QAAQ,GAAGR,aAAa,CAACM,IAAI,GAAG,CAAC,GAAGN,aAAa,CAACO,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC;EACpE,MAAME,OAAO,GAAGT,aAAa,CAACM,IAAI,GAAG,CAAC,GAAGN,aAAa,CAACO,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC;EAEnE,IAAIL,WAAW,CAACQ,MAAM,KAAKD,OAAO,EAAE;IAClC,MAAM,IAAIJ,KAAK,CACX,gDAAgD,GAChD,IAAIH,WAAW,CAACQ,MAAM,gBAAgBD,OAAO,GAAG,CAAC;;EAGvD,MAAME,SAAS,GAAGV,YAAY,CAACW,IAAI;EACnC,IAAI,EAAEX,YAAY,CAACK,IAAI,KAAK,CAAC,IACvBL,YAAY,CAACK,IAAI,KAAK,CAAC,IAAIK,SAAS,KAAKH,QAAQ,CAAC,EAAE;IACxD,MAAM,IAAIH,KAAK,CACX,mCAAmC,GACnC,GAAGJ,YAAY,CAACM,KAAK,sBAAsBC,QAAQ,GAAG,CAAC;;EAG7D,IAAIP,YAAY,CAACG,KAAK,KAAKD,aAAa,CAACC,KAAK,EAAE;IAC9C,MAAM,IAAIC,KAAK,CAAC,mDAAmD,CAAC;;AAExE","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}