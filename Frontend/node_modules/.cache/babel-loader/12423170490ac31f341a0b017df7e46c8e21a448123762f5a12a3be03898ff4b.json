{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/* original source: keras/regularizers.py */\nimport * as tfc from '@tensorflow/tfjs-core';\nimport { abs, add, serialization, sum, tidy, zeros } from '@tensorflow/tfjs-core';\nimport * as K from './backend/tfjs_backend';\nimport { deserializeKerasObject, serializeKerasObject } from './utils/generic_utils';\nfunction assertObjectArgs(args) {\n  if (args != null && typeof args !== 'object') {\n    throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an ` + `object, but received: ${args}`);\n  }\n}\n/**\n * Regularizer base class.\n */\nexport class Regularizer extends serialization.Serializable {}\nclass L1L2 extends Regularizer {\n  constructor(args) {\n    super();\n    assertObjectArgs(args);\n    this.l1 = args == null || args.l1 == null ? 0.01 : args.l1;\n    this.l2 = args == null || args.l2 == null ? 0.01 : args.l2;\n    this.hasL1 = this.l1 !== 0;\n    this.hasL2 = this.l2 !== 0;\n  }\n  /**\n   * Porting note: Renamed from __call__.\n   * @param x Variable of which to calculate the regularization score.\n   */\n  apply(x) {\n    return tidy(() => {\n      let regularization = zeros([1]);\n      if (this.hasL1) {\n        regularization = add(regularization, sum(tfc.mul(this.l1, abs(x))));\n      }\n      if (this.hasL2) {\n        regularization = add(regularization, sum(tfc.mul(this.l2, K.square(x))));\n      }\n      return tfc.reshape(regularization, []);\n    });\n  }\n  getConfig() {\n    return {\n      'l1': this.l1,\n      'l2': this.l2\n    };\n  }\n  /** @nocollapse */\n  static fromConfig(cls, config) {\n    return new cls({\n      l1: config['l1'],\n      l2: config['l2']\n    });\n  }\n}\n/** @nocollapse */\nL1L2.className = 'L1L2';\nexport { L1L2 };\nserialization.registerClass(L1L2);\nexport function l1(args) {\n  assertObjectArgs(args);\n  return new L1L2({\n    l1: args != null ? args.l1 : null,\n    l2: 0\n  });\n}\nexport function l2(args) {\n  assertObjectArgs(args);\n  return new L1L2({\n    l2: args != null ? args.l2 : null,\n    l1: 0\n  });\n}\n// Maps the JavaScript-like identifier keys to the corresponding keras symbols.\nexport const REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP = {\n  'l1l2': 'L1L2'\n};\nexport function serializeRegularizer(constraint) {\n  return serializeKerasObject(constraint);\n}\nexport function deserializeRegularizer(config, customObjects = {}) {\n  return deserializeKerasObject(config, serialization.SerializationMap.getMap().classNameMap, customObjects, 'regularizer');\n}\nexport function getRegularizer(identifier) {\n  if (identifier == null) {\n    return null;\n  }\n  if (typeof identifier === 'string') {\n    const className = identifier in REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP ? REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP[identifier] : identifier;\n    const config = {\n      className,\n      config: {}\n    };\n    return deserializeRegularizer(config);\n  } else if (identifier instanceof Regularizer) {\n    return identifier;\n  } else {\n    return deserializeRegularizer(identifier);\n  }\n}","map":{"version":3,"names":["tfc","abs","add","serialization","sum","tidy","zeros","K","deserializeKerasObject","serializeKerasObject","assertObjectArgs","args","Error","Regularizer","Serializable","L1L2","constructor","l1","l2","hasL1","hasL2","apply","x","regularization","mul","square","reshape","getConfig","fromConfig","cls","config","className","registerClass","REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP","serializeRegularizer","constraint","deserializeRegularizer","customObjects","SerializationMap","getMap","classNameMap","getRegularizer","identifier"],"sources":["/Users/jonchen/Documents/HackPSU/tfjs-layers/src/regularizers.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\n/* original source: keras/regularizers.py */\n\nimport * as tfc from '@tensorflow/tfjs-core';\nimport {abs, add, Scalar, serialization, sum, Tensor, tidy, zeros} from '@tensorflow/tfjs-core';\nimport * as K from './backend/tfjs_backend';\nimport {deserializeKerasObject, serializeKerasObject} from './utils/generic_utils';\n\nfunction assertObjectArgs(args: L1Args|L2Args|L1L2Args): void {\n  if (args != null && typeof args !== 'object') {\n    throw new Error(\n        `Argument to L1L2 regularizer's constructor is expected to be an ` +\n        `object, but received: ${args}`);\n  }\n}\n\n/**\n * Regularizer base class.\n */\nexport abstract class Regularizer extends serialization.Serializable {\n  abstract apply(x: Tensor): Scalar;\n}\n\nexport interface L1L2Args {\n  /** L1 regularization rate. Defaults to 0.01. */\n  l1?: number;\n  /** L2 regularization rate. Defaults to 0.01. */\n  l2?: number;\n}\n\nexport interface L1Args {\n  /** L1 regularization rate. Defaults to 0.01. */\n  l1: number;\n}\n\nexport interface L2Args {\n  /** L2 regularization rate. Defaults to 0.01. */\n  l2: number;\n}\n\nexport class L1L2 extends Regularizer {\n  /** @nocollapse */\n  static className = 'L1L2';\n\n  private readonly l1: number;\n  private readonly l2: number;\n  private readonly hasL1: boolean;\n  private readonly hasL2: boolean;\n  constructor(args?: L1L2Args) {\n    super();\n\n    assertObjectArgs(args);\n\n    this.l1 = args == null || args.l1 == null ? 0.01 : args.l1;\n    this.l2 = args == null || args.l2 == null ? 0.01 : args.l2;\n    this.hasL1 = this.l1 !== 0;\n    this.hasL2 = this.l2 !== 0;\n  }\n\n  /**\n   * Porting note: Renamed from __call__.\n   * @param x Variable of which to calculate the regularization score.\n   */\n  apply(x: Tensor): Scalar {\n    return tidy(() => {\n      let regularization: Tensor = zeros([1]);\n      if (this.hasL1) {\n        regularization = add(regularization, sum(tfc.mul(this.l1, abs(x))));\n      }\n      if (this.hasL2) {\n        regularization =\n            add(regularization, sum(tfc.mul(this.l2, K.square(x))));\n      }\n      return tfc.reshape(regularization, []);\n    });\n  }\n\n  getConfig(): serialization.ConfigDict {\n    return {'l1': this.l1, 'l2': this.l2};\n  }\n\n  /** @nocollapse */\n  static override fromConfig<T extends serialization.Serializable>(\n      cls: serialization.SerializableConstructor<T>,\n      config: serialization.ConfigDict): T {\n    return new cls({l1: config['l1'] as number, l2: config['l2'] as number});\n  }\n}\nserialization.registerClass(L1L2);\n\nexport function l1(args?: L1Args) {\n  assertObjectArgs(args);\n  return new L1L2({l1: args != null ? args.l1 : null, l2: 0});\n}\n\nexport function l2(args: L2Args) {\n  assertObjectArgs(args);\n  return new L1L2({l2: args != null ? args.l2 : null, l1: 0});\n}\n\n/** @docinline */\nexport type RegularizerIdentifier = 'l1l2'|string;\n\n// Maps the JavaScript-like identifier keys to the corresponding keras symbols.\nexport const REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP:\n    {[identifier in RegularizerIdentifier]: string} = {\n      'l1l2': 'L1L2'\n    };\n\nexport function serializeRegularizer(constraint: Regularizer):\n    serialization.ConfigDictValue {\n  return serializeKerasObject(constraint);\n}\n\nexport function deserializeRegularizer(\n    config: serialization.ConfigDict,\n    customObjects: serialization.ConfigDict = {}): Regularizer {\n  return deserializeKerasObject(\n      config, serialization.SerializationMap.getMap().classNameMap,\n      customObjects, 'regularizer');\n}\n\nexport function getRegularizer(identifier: RegularizerIdentifier|\n                               serialization.ConfigDict|\n                               Regularizer): Regularizer {\n  if (identifier == null) {\n    return null;\n  }\n  if (typeof identifier === 'string') {\n    const className = identifier in REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP ?\n        REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP[identifier] :\n        identifier;\n    const config = {className, config: {}};\n    return deserializeRegularizer(config);\n  } else if (identifier instanceof Regularizer) {\n    return identifier;\n  } else {\n    return deserializeRegularizer(identifier);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}