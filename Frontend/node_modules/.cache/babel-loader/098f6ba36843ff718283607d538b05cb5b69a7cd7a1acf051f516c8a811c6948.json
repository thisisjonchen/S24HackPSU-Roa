{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * Merges real and imaginary Float32Arrays into a single complex Float32Array.\n *\n * The memory layout is interleaved as follows:\n * real: [r0, r1, r2]\n * imag: [i0, i1, i2]\n * complex: [r0, i0, r1, i1, r2, i2]\n *\n * This is the inverse of splitRealAndImagArrays.\n *\n * @param real The real values of the complex tensor values.\n * @param imag The imag values of the complex tensor values.\n * @returns A complex tensor as a Float32Array with merged values.\n */\nexport function mergeRealAndImagArrays(real, imag) {\n  if (real.length !== imag.length) {\n    throw new Error(`Cannot merge real and imag arrays of different lengths. real:` + `${real.length}, imag: ${imag.length}.`);\n  }\n  const result = new Float32Array(real.length * 2);\n  for (let i = 0; i < result.length; i += 2) {\n    result[i] = real[i / 2];\n    result[i + 1] = imag[i / 2];\n  }\n  return result;\n}\n/**\n * Splits a complex Float32Array into real and imag parts.\n *\n * The memory layout is interleaved as follows:\n * complex: [r0, i0, r1, i1, r2, i2]\n * real: [r0, r1, r2]\n * imag: [i0, i1, i2]\n *\n * This is the inverse of mergeRealAndImagArrays.\n *\n * @param complex The complex tensor values.\n * @returns An object with real and imag Float32Array components of the complex\n *     tensor.\n */\nexport function splitRealAndImagArrays(complex) {\n  const real = new Float32Array(complex.length / 2);\n  const imag = new Float32Array(complex.length / 2);\n  for (let i = 0; i < complex.length; i += 2) {\n    real[i / 2] = complex[i];\n    imag[i / 2] = complex[i + 1];\n  }\n  return {\n    real,\n    imag\n  };\n}\n/**\n * Extracts even indexed complex values in the given array.\n * @param complex The complex tensor values\n */\nexport function complexWithEvenIndex(complex) {\n  const len = Math.ceil(complex.length / 4);\n  const real = new Float32Array(len);\n  const imag = new Float32Array(len);\n  for (let i = 0; i < complex.length; i += 4) {\n    real[Math.floor(i / 4)] = complex[i];\n    imag[Math.floor(i / 4)] = complex[i + 1];\n  }\n  return {\n    real,\n    imag\n  };\n}\n/**\n * Extracts odd indexed comple values in the given array.\n * @param complex The complex tensor values\n */\nexport function complexWithOddIndex(complex) {\n  const len = Math.floor(complex.length / 4);\n  const real = new Float32Array(len);\n  const imag = new Float32Array(len);\n  for (let i = 2; i < complex.length; i += 4) {\n    real[Math.floor(i / 4)] = complex[i];\n    imag[Math.floor(i / 4)] = complex[i + 1];\n  }\n  return {\n    real,\n    imag\n  };\n}\n/**\n * Get the map representing a complex value in the given array.\n * @param complex The complex tensor values.\n * @param index An index of the target complex value.\n */\nexport function getComplexWithIndex(complex, index) {\n  const real = complex[index * 2];\n  const imag = complex[index * 2 + 1];\n  return {\n    real,\n    imag\n  };\n}\n/**\n * Insert a given complex value into the TypedArray.\n * @param data The array in which the complex value is inserted.\n * @param c The complex value to be inserted.\n * @param index An index of the target complex value.\n */\nexport function assignToTypedArray(data, real, imag, index) {\n  data[index * 2] = real;\n  data[index * 2 + 1] = imag;\n}\n/**\n * Make the list of exponent terms used by FFT.\n */\nexport function exponents(n, inverse) {\n  const real = new Float32Array(n / 2);\n  const imag = new Float32Array(n / 2);\n  for (let i = 0; i < Math.ceil(n / 2); i++) {\n    const x = (inverse ? 2 : -2) * Math.PI * (i / n);\n    real[i] = Math.cos(x);\n    imag[i] = Math.sin(x);\n  }\n  return {\n    real,\n    imag\n  };\n}\n/**\n * Make the exponent term used by FFT.\n */\nexport function exponent(k, n, inverse) {\n  const x = (inverse ? 2 : -2) * Math.PI * (k / n);\n  const real = Math.cos(x);\n  const imag = Math.sin(x);\n  return {\n    real,\n    imag\n  };\n}","map":{"version":3,"names":["mergeRealAndImagArrays","real","imag","length","Error","result","Float32Array","i","splitRealAndImagArrays","complex","complexWithEvenIndex","len","Math","ceil","floor","complexWithOddIndex","getComplexWithIndex","index","assignToTypedArray","data","exponents","n","inverse","x","PI","cos","sin","exponent","k"],"sources":["/Users/jonchen/Documents/HackPSU/tfjs-core/src/backends/complex_util.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {TypedArray} from '../types';\n/**\n * Merges real and imaginary Float32Arrays into a single complex Float32Array.\n *\n * The memory layout is interleaved as follows:\n * real: [r0, r1, r2]\n * imag: [i0, i1, i2]\n * complex: [r0, i0, r1, i1, r2, i2]\n *\n * This is the inverse of splitRealAndImagArrays.\n *\n * @param real The real values of the complex tensor values.\n * @param imag The imag values of the complex tensor values.\n * @returns A complex tensor as a Float32Array with merged values.\n */\nexport function mergeRealAndImagArrays(\n    real: Float32Array, imag: Float32Array): Float32Array {\n  if (real.length !== imag.length) {\n    throw new Error(\n        `Cannot merge real and imag arrays of different lengths. real:` +\n        `${real.length}, imag: ${imag.length}.`);\n  }\n  const result = new Float32Array(real.length * 2);\n  for (let i = 0; i < result.length; i += 2) {\n    result[i] = real[i / 2];\n    result[i + 1] = imag[i / 2];\n  }\n  return result;\n}\n\n/**\n * Splits a complex Float32Array into real and imag parts.\n *\n * The memory layout is interleaved as follows:\n * complex: [r0, i0, r1, i1, r2, i2]\n * real: [r0, r1, r2]\n * imag: [i0, i1, i2]\n *\n * This is the inverse of mergeRealAndImagArrays.\n *\n * @param complex The complex tensor values.\n * @returns An object with real and imag Float32Array components of the complex\n *     tensor.\n */\nexport function splitRealAndImagArrays(complex: Float32Array):\n    {real: Float32Array, imag: Float32Array} {\n  const real = new Float32Array(complex.length / 2);\n  const imag = new Float32Array(complex.length / 2);\n  for (let i = 0; i < complex.length; i += 2) {\n    real[i / 2] = complex[i];\n    imag[i / 2] = complex[i + 1];\n  }\n  return {real, imag};\n}\n\n/**\n * Extracts even indexed complex values in the given array.\n * @param complex The complex tensor values\n */\nexport function complexWithEvenIndex(complex: Float32Array):\n    {real: Float32Array, imag: Float32Array} {\n  const len = Math.ceil(complex.length / 4);\n  const real = new Float32Array(len);\n  const imag = new Float32Array(len);\n  for (let i = 0; i < complex.length; i += 4) {\n    real[Math.floor(i / 4)] = complex[i];\n    imag[Math.floor(i / 4)] = complex[i + 1];\n  }\n  return {real, imag};\n}\n\n/**\n * Extracts odd indexed comple values in the given array.\n * @param complex The complex tensor values\n */\nexport function complexWithOddIndex(complex: Float32Array):\n    {real: Float32Array, imag: Float32Array} {\n  const len = Math.floor(complex.length / 4);\n  const real = new Float32Array(len);\n  const imag = new Float32Array(len);\n  for (let i = 2; i < complex.length; i += 4) {\n    real[Math.floor(i / 4)] = complex[i];\n    imag[Math.floor(i / 4)] = complex[i + 1];\n  }\n  return {real, imag};\n}\n\n/**\n * Get the map representing a complex value in the given array.\n * @param complex The complex tensor values.\n * @param index An index of the target complex value.\n */\nexport function getComplexWithIndex(\n    complex: Float32Array, index: number): {real: number, imag: number} {\n  const real = complex[index * 2];\n  const imag = complex[index * 2 + 1];\n  return {real, imag};\n}\n\n/**\n * Insert a given complex value into the TypedArray.\n * @param data The array in which the complex value is inserted.\n * @param c The complex value to be inserted.\n * @param index An index of the target complex value.\n */\nexport function assignToTypedArray(\n    data: TypedArray, real: number, imag: number, index: number) {\n  data[index * 2] = real;\n  data[index * 2 + 1] = imag;\n}\n\n/**\n * Make the list of exponent terms used by FFT.\n */\nexport function exponents(\n    n: number, inverse: boolean): {real: Float32Array, imag: Float32Array} {\n  const real = new Float32Array(n / 2);\n  const imag = new Float32Array(n / 2);\n  for (let i = 0; i < Math.ceil(n / 2); i++) {\n    const x = (inverse ? 2 : -2) * Math.PI * (i / n);\n    real[i] = Math.cos(x);\n    imag[i] = Math.sin(x);\n  }\n  return {real, imag};\n}\n\n/**\n * Make the exponent term used by FFT.\n */\nexport function exponent(\n    k: number, n: number, inverse: boolean): {real: number, imag: number} {\n  const x = (inverse ? 2 : -2) * Math.PI * (k / n);\n  const real = Math.cos(x);\n  const imag = Math.sin(x);\n  return {real, imag};\n}\n"],"mappings":"AAAA;;;;;;;;;;;;;;;;AAkBA;;;;;;;;;;;;;;AAcA,OAAM,SAAUA,sBAAsBA,CAClCC,IAAkB,EAAEC,IAAkB;EACxC,IAAID,IAAI,CAACE,MAAM,KAAKD,IAAI,CAACC,MAAM,EAAE;IAC/B,MAAM,IAAIC,KAAK,CACX,+DAA+D,GAC/D,GAAGH,IAAI,CAACE,MAAM,WAAWD,IAAI,CAACC,MAAM,GAAG,CAAC;;EAE9C,MAAME,MAAM,GAAG,IAAIC,YAAY,CAACL,IAAI,CAACE,MAAM,GAAG,CAAC,CAAC;EAChD,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,MAAM,CAACF,MAAM,EAAEI,CAAC,IAAI,CAAC,EAAE;IACzCF,MAAM,CAACE,CAAC,CAAC,GAAGN,IAAI,CAACM,CAAC,GAAG,CAAC,CAAC;IACvBF,MAAM,CAACE,CAAC,GAAG,CAAC,CAAC,GAAGL,IAAI,CAACK,CAAC,GAAG,CAAC,CAAC;;EAE7B,OAAOF,MAAM;AACf;AAEA;;;;;;;;;;;;;;AAcA,OAAM,SAAUG,sBAAsBA,CAACC,OAAqB;EAE1D,MAAMR,IAAI,GAAG,IAAIK,YAAY,CAACG,OAAO,CAACN,MAAM,GAAG,CAAC,CAAC;EACjD,MAAMD,IAAI,GAAG,IAAII,YAAY,CAACG,OAAO,CAACN,MAAM,GAAG,CAAC,CAAC;EACjD,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGE,OAAO,CAACN,MAAM,EAAEI,CAAC,IAAI,CAAC,EAAE;IAC1CN,IAAI,CAACM,CAAC,GAAG,CAAC,CAAC,GAAGE,OAAO,CAACF,CAAC,CAAC;IACxBL,IAAI,CAACK,CAAC,GAAG,CAAC,CAAC,GAAGE,OAAO,CAACF,CAAC,GAAG,CAAC,CAAC;;EAE9B,OAAO;IAACN,IAAI;IAAEC;EAAI,CAAC;AACrB;AAEA;;;;AAIA,OAAM,SAAUQ,oBAAoBA,CAACD,OAAqB;EAExD,MAAME,GAAG,GAAGC,IAAI,CAACC,IAAI,CAACJ,OAAO,CAACN,MAAM,GAAG,CAAC,CAAC;EACzC,MAAMF,IAAI,GAAG,IAAIK,YAAY,CAACK,GAAG,CAAC;EAClC,MAAMT,IAAI,GAAG,IAAII,YAAY,CAACK,GAAG,CAAC;EAClC,KAAK,IAAIJ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGE,OAAO,CAACN,MAAM,EAAEI,CAAC,IAAI,CAAC,EAAE;IAC1CN,IAAI,CAACW,IAAI,CAACE,KAAK,CAACP,CAAC,GAAG,CAAC,CAAC,CAAC,GAAGE,OAAO,CAACF,CAAC,CAAC;IACpCL,IAAI,CAACU,IAAI,CAACE,KAAK,CAACP,CAAC,GAAG,CAAC,CAAC,CAAC,GAAGE,OAAO,CAACF,CAAC,GAAG,CAAC,CAAC;;EAE1C,OAAO;IAACN,IAAI;IAAEC;EAAI,CAAC;AACrB;AAEA;;;;AAIA,OAAM,SAAUa,mBAAmBA,CAACN,OAAqB;EAEvD,MAAME,GAAG,GAAGC,IAAI,CAACE,KAAK,CAACL,OAAO,CAACN,MAAM,GAAG,CAAC,CAAC;EAC1C,MAAMF,IAAI,GAAG,IAAIK,YAAY,CAACK,GAAG,CAAC;EAClC,MAAMT,IAAI,GAAG,IAAII,YAAY,CAACK,GAAG,CAAC;EAClC,KAAK,IAAIJ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGE,OAAO,CAACN,MAAM,EAAEI,CAAC,IAAI,CAAC,EAAE;IAC1CN,IAAI,CAACW,IAAI,CAACE,KAAK,CAACP,CAAC,GAAG,CAAC,CAAC,CAAC,GAAGE,OAAO,CAACF,CAAC,CAAC;IACpCL,IAAI,CAACU,IAAI,CAACE,KAAK,CAACP,CAAC,GAAG,CAAC,CAAC,CAAC,GAAGE,OAAO,CAACF,CAAC,GAAG,CAAC,CAAC;;EAE1C,OAAO;IAACN,IAAI;IAAEC;EAAI,CAAC;AACrB;AAEA;;;;;AAKA,OAAM,SAAUc,mBAAmBA,CAC/BP,OAAqB,EAAEQ,KAAa;EACtC,MAAMhB,IAAI,GAAGQ,OAAO,CAACQ,KAAK,GAAG,CAAC,CAAC;EAC/B,MAAMf,IAAI,GAAGO,OAAO,CAACQ,KAAK,GAAG,CAAC,GAAG,CAAC,CAAC;EACnC,OAAO;IAAChB,IAAI;IAAEC;EAAI,CAAC;AACrB;AAEA;;;;;;AAMA,OAAM,SAAUgB,kBAAkBA,CAC9BC,IAAgB,EAAElB,IAAY,EAAEC,IAAY,EAAEe,KAAa;EAC7DE,IAAI,CAACF,KAAK,GAAG,CAAC,CAAC,GAAGhB,IAAI;EACtBkB,IAAI,CAACF,KAAK,GAAG,CAAC,GAAG,CAAC,CAAC,GAAGf,IAAI;AAC5B;AAEA;;;AAGA,OAAM,SAAUkB,SAASA,CACrBC,CAAS,EAAEC,OAAgB;EAC7B,MAAMrB,IAAI,GAAG,IAAIK,YAAY,CAACe,CAAC,GAAG,CAAC,CAAC;EACpC,MAAMnB,IAAI,GAAG,IAAII,YAAY,CAACe,CAAC,GAAG,CAAC,CAAC;EACpC,KAAK,IAAId,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGK,IAAI,CAACC,IAAI,CAACQ,CAAC,GAAG,CAAC,CAAC,EAAEd,CAAC,EAAE,EAAE;IACzC,MAAMgB,CAAC,GAAG,CAACD,OAAO,GAAG,CAAC,GAAG,CAAC,CAAC,IAAIV,IAAI,CAACY,EAAE,IAAIjB,CAAC,GAAGc,CAAC,CAAC;IAChDpB,IAAI,CAACM,CAAC,CAAC,GAAGK,IAAI,CAACa,GAAG,CAACF,CAAC,CAAC;IACrBrB,IAAI,CAACK,CAAC,CAAC,GAAGK,IAAI,CAACc,GAAG,CAACH,CAAC,CAAC;;EAEvB,OAAO;IAACtB,IAAI;IAAEC;EAAI,CAAC;AACrB;AAEA;;;AAGA,OAAM,SAAUyB,QAAQA,CACpBC,CAAS,EAAEP,CAAS,EAAEC,OAAgB;EACxC,MAAMC,CAAC,GAAG,CAACD,OAAO,GAAG,CAAC,GAAG,CAAC,CAAC,IAAIV,IAAI,CAACY,EAAE,IAAII,CAAC,GAAGP,CAAC,CAAC;EAChD,MAAMpB,IAAI,GAAGW,IAAI,CAACa,GAAG,CAACF,CAAC,CAAC;EACxB,MAAMrB,IAAI,GAAGU,IAAI,CAACc,GAAG,CAACH,CAAC,CAAC;EACxB,OAAO;IAACtB,IAAI;IAAEC;EAAI,CAAC;AACrB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}