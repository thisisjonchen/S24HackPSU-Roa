{"ast":null,"code":"/**\n * ExecutionContext captures the runtime environment of the node. It keeps\n * track of the current frame and iteration for the control flow ops.\n *\n * For example, typical Dynamic RNN model may contain loops, for which\n * TensorFlow will generate graphs with Enter/Exit nodes to control the\n * current execution frame, and NextIteration Nodes for iteration id increment.\n * For model with branch logic, TensorFLow will generate Switch/Merge ops.\n */\nexport class ExecutionContext {\n  constructor(weightMap = {}, tensorArrayMap = {}, tensorListMap = {}, functionMap = {}, parseNodeNameCache) {\n    this.weightMap = weightMap;\n    this.tensorArrayMap = tensorArrayMap;\n    this.tensorListMap = tensorListMap;\n    this.functionMap = functionMap;\n    this.parseNodeNameCache = parseNodeNameCache;\n    this.rootContext = {\n      id: 0,\n      frameName: '',\n      iterationId: 0\n    };\n    this.contexts = [this.rootContext];\n    this.lastId = 0;\n    this.generateCurrentContextIds();\n  }\n  newFrame(id, frameName) {\n    return {\n      id,\n      frameName,\n      iterationId: 0\n    };\n  }\n  /**\n   * Set the current context\n   * @param contexts: ExecutionContextInfo[] the current path of execution\n   * frames\n   */\n  set currentContext(contexts) {\n    if (this.contexts !== contexts) {\n      this.contexts = contexts;\n      this.generateCurrentContextIds();\n    }\n  }\n  get currentContext() {\n    return this.contexts;\n  }\n  /**\n   * Returns the current context in string format.\n   */\n  get currentContextId() {\n    return this._currentContextIds[0];\n  }\n  /**\n   * Returns the current context and all parent contexts in string format.\n   * This allow access to the nodes in the current and parent frames.\n   */\n  get currentContextIds() {\n    return this._currentContextIds;\n  }\n  generateCurrentContextIds() {\n    const names = [];\n    for (let i = 0; i < this.contexts.length - 1; i++) {\n      const contexts = this.contexts.slice(0, this.contexts.length - i);\n      names.push(this.contextIdforContexts(contexts));\n    }\n    names.push('');\n    this._currentContextIds = names;\n  }\n  contextIdforContexts(contexts) {\n    return contexts ? contexts.map(context => context.id === 0 && context.iterationId === 0 ? '' : `${context.frameName}-${context.iterationId}`).join('/') : '';\n  }\n  /**\n   * Enter a new frame, a new context is pushed on the current context list.\n   * @param frameId new frame id\n   */\n  enterFrame(frameId) {\n    if (this.contexts) {\n      this.lastId++;\n      this.contexts = this.contexts.slice();\n      this.contexts.push(this.newFrame(this.lastId, frameId));\n      this._currentContextIds.unshift(this.contextIdforContexts(this.contexts));\n    }\n  }\n  /**\n   * Exit the current frame, the last context is removed from the current\n   * context list.\n   */\n  exitFrame() {\n    if (this.contexts && this.contexts.length > 1) {\n      this.contexts = this.contexts.slice();\n      this.contexts.splice(-1);\n      this.currentContextIds.shift();\n    } else {\n      throw new Error('Cannot exit frame, the context is empty');\n    }\n  }\n  /**\n   * Enter the next iteration of a loop, the iteration id of last context is\n   * increased.\n   */\n  nextIteration() {\n    if (this.contexts && this.contexts.length > 0) {\n      this.contexts = this.contexts.slice();\n      this.lastId++;\n      const context = Object.assign({}, this.contexts[this.contexts.length - 1]);\n      context.iterationId += 1;\n      context.id = this.lastId;\n      this.contexts.splice(-1, 1, context);\n      this._currentContextIds.splice(0, 1, this.contextIdforContexts(this.contexts));\n    } else {\n      throw new Error('Cannot increase frame iteration, the context is empty');\n    }\n  }\n  getWeight(name) {\n    return this.weightMap[name];\n  }\n  addTensorArray(tensorArray) {\n    this.tensorArrayMap[tensorArray.id] = tensorArray;\n  }\n  getTensorArray(id) {\n    return this.tensorArrayMap[id];\n  }\n  addTensorList(tensorList) {\n    this.tensorListMap[tensorList.id] = tensorList;\n  }\n  getTensorList(id) {\n    return this.tensorListMap[id];\n  }\n  dispose(keepIds) {\n    for (const key in this.tensorArrayMap) {\n      this.tensorArrayMap[key].clearAndClose(keepIds);\n    }\n    for (const key in this.tensorListMap) {\n      this.tensorListMap[key].clearAndClose(keepIds);\n    }\n  }\n}","map":{"version":3,"names":["ExecutionContext","constructor","weightMap","tensorArrayMap","tensorListMap","functionMap","parseNodeNameCache","rootContext","id","frameName","iterationId","contexts","lastId","generateCurrentContextIds","newFrame","currentContext","currentContextId","_currentContextIds","currentContextIds","names","i","length","slice","push","contextIdforContexts","map","context","join","enterFrame","frameId","unshift","exitFrame","splice","shift","Error","nextIteration","Object","assign","getWeight","name","addTensorArray","tensorArray","getTensorArray","addTensorList","tensorList","getTensorList","dispose","keepIds","key","clearAndClose"],"sources":["/Users/jonchen/Documents/HackPSU/tfjs-converter/src/executor/execution_context.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {Tensor} from '@tensorflow/tfjs-core';\n\nimport {NamedTensorsMap, TensorArrayMap, TensorListMap} from '../data/types';\n\nimport {TensorArray} from './tensor_array';\nimport {TensorList} from './tensor_list';\nimport {FunctionExecutor} from './types';\n\nexport interface ExecutionContextInfo {\n  id: number;           // the unique id of the context info\n  frameName: string;    // The frame name of the loop, this comes from\n                        // the TensorFlow NodeDef.\n  iterationId: number;  // The iteration id of the loop\n}\n\n/**\n * ExecutionContext captures the runtime environment of the node. It keeps\n * track of the current frame and iteration for the control flow ops.\n *\n * For example, typical Dynamic RNN model may contain loops, for which\n * TensorFlow will generate graphs with Enter/Exit nodes to control the\n * current execution frame, and NextIteration Nodes for iteration id increment.\n * For model with branch logic, TensorFLow will generate Switch/Merge ops.\n */\nexport class ExecutionContext {\n  private rootContext = {id: 0, frameName: '', iterationId: 0};\n  private contexts: ExecutionContextInfo[] = [this.rootContext];\n  private lastId = 0;\n  private _currentContextIds: string[];\n\n  constructor(\n      readonly weightMap: NamedTensorsMap = {},\n      readonly tensorArrayMap: TensorArrayMap = {},\n      readonly tensorListMap: TensorListMap = {},\n      readonly functionMap: {[key: string]: FunctionExecutor} = {},\n      readonly parseNodeNameCache?: Map<string, [string, number, string?]>) {\n    this.generateCurrentContextIds();\n  }\n\n  private newFrame(id: number, frameName: string) {\n    return {id, frameName, iterationId: 0};\n  }\n\n  /**\n   * Set the current context\n   * @param contexts: ExecutionContextInfo[] the current path of execution\n   * frames\n   */\n  set currentContext(contexts: ExecutionContextInfo[]) {\n    if (this.contexts !== contexts) {\n      this.contexts = contexts;\n      this.generateCurrentContextIds();\n    }\n  }\n\n  get currentContext(): ExecutionContextInfo[] {\n    return this.contexts;\n  }\n\n  /**\n   * Returns the current context in string format.\n   */\n  get currentContextId(): string {\n    return this._currentContextIds[0];\n  }\n\n  /**\n   * Returns the current context and all parent contexts in string format.\n   * This allow access to the nodes in the current and parent frames.\n   */\n  get currentContextIds(): string[] {\n    return this._currentContextIds;\n  }\n\n  private generateCurrentContextIds() {\n    const names = [];\n    for (let i = 0; i < this.contexts.length - 1; i++) {\n      const contexts = this.contexts.slice(0, this.contexts.length - i);\n      names.push(this.contextIdforContexts(contexts));\n    }\n    names.push('');\n    this._currentContextIds = names;\n  }\n\n  private contextIdforContexts(contexts: ExecutionContextInfo[]) {\n    return contexts ?\n        contexts\n            .map(\n                context => (context.id === 0 && context.iterationId === 0) ?\n                    '' :\n                    `${context.frameName}-${context.iterationId}`)\n            .join('/') :\n        '';\n  }\n\n  /**\n   * Enter a new frame, a new context is pushed on the current context list.\n   * @param frameId new frame id\n   */\n  enterFrame(frameId: string) {\n    if (this.contexts) {\n      this.lastId++;\n      this.contexts = this.contexts.slice();\n      this.contexts.push(this.newFrame(this.lastId, frameId));\n      this._currentContextIds.unshift(this.contextIdforContexts(this.contexts));\n    }\n  }\n\n  /**\n   * Exit the current frame, the last context is removed from the current\n   * context list.\n   */\n  exitFrame() {\n    if (this.contexts && this.contexts.length > 1) {\n      this.contexts = this.contexts.slice();\n      this.contexts.splice(-1);\n      this.currentContextIds.shift();\n    } else {\n      throw new Error('Cannot exit frame, the context is empty');\n    }\n  }\n\n  /**\n   * Enter the next iteration of a loop, the iteration id of last context is\n   * increased.\n   */\n  nextIteration() {\n    if (this.contexts && this.contexts.length > 0) {\n      this.contexts = this.contexts.slice();\n      this.lastId++;\n      const context =\n          Object.assign({}, this.contexts[this.contexts.length - 1]);\n      context.iterationId += 1;\n      context.id = this.lastId;\n      this.contexts.splice(-1, 1, context);\n      this._currentContextIds.splice(\n          0, 1, this.contextIdforContexts(this.contexts));\n    } else {\n      throw new Error('Cannot increase frame iteration, the context is empty');\n    }\n  }\n\n  getWeight(name: string): Tensor[] {\n    return this.weightMap[name];\n  }\n\n  addTensorArray(tensorArray: TensorArray) {\n    this.tensorArrayMap[tensorArray.id] = tensorArray;\n  }\n\n  getTensorArray(id: number): TensorArray {\n    return this.tensorArrayMap[id];\n  }\n\n  addTensorList(tensorList: TensorList) {\n    this.tensorListMap[tensorList.id] = tensorList;\n  }\n\n  getTensorList(id: number): TensorList {\n    return this.tensorListMap[id];\n  }\n\n  dispose(keepIds: Set<number>) {\n    for (const key in this.tensorArrayMap) {\n      this.tensorArrayMap[key].clearAndClose(keepIds);\n    }\n\n    for (const key in this.tensorListMap) {\n      this.tensorListMap[key].clearAndClose(keepIds);\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}