{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, Prod, upcastType, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nimport { transpose } from './Transpose';\nexport function prodImpl(xShape, xDtype, xVals, reductionAxes) {\n  const [outShape, reduceShape] = backend_util.computeOutAndReduceShapes(xShape, reductionAxes);\n  const outDtype = upcastType(xDtype, 'int32');\n  const outVals = util.makeZerosTypedArray(util.sizeFromShape(outShape), outDtype);\n  const reduceSize = util.sizeFromShape(reduceShape);\n  for (let i = 0; i < outVals.length; ++i) {\n    const offset = i * reduceSize;\n    let prod = 1;\n    for (let j = 0; j < reduceSize; ++j) {\n      prod *= xVals[offset + j];\n    }\n    outVals[i] = prod;\n  }\n  return {\n    outVals,\n    outShape,\n    outDtype\n  };\n}\nexport function prod(args) {\n  const {\n    inputs,\n    backend,\n    attrs\n  } = args;\n  const {\n    x\n  } = inputs;\n  const {\n    axis,\n    keepDims\n  } = attrs;\n  assertNotComplex(x, 'prod');\n  const xRank = x.shape.length;\n  const axes = util.parseAxisParam(axis, x.shape);\n  const permutation = backend_util.getAxesPermutation(axes, xRank);\n  let reductionAxes = axes;\n  let permutedX = x;\n  const intermediateTensorInfos = [];\n  if (permutation != null) {\n    permutedX = transpose({\n      inputs: {\n        x\n      },\n      backend,\n      attrs: {\n        perm: permutation\n      }\n    });\n    intermediateTensorInfos.push(permutedX);\n    reductionAxes = backend_util.getInnerMostAxes(reductionAxes.length, xRank);\n  }\n  const xVals = backend.data.get(permutedX.dataId).values;\n  const {\n    outVals,\n    outShape,\n    outDtype\n  } = prodImpl(permutedX.shape, permutedX.dtype, xVals, reductionAxes);\n  let resultShape = outShape;\n  if (keepDims) {\n    resultShape = backend_util.expandShapeToKeepDim(outShape, axes);\n  }\n  intermediateTensorInfos.forEach(t => backend.disposeIntermediateTensorInfo(t));\n  return backend.makeTensorInfo(resultShape, outDtype, outVals);\n}\nexport const prodConfig = {\n  kernelName: Prod,\n  backendName: 'cpu',\n  kernelFunc: prod\n};","map":{"version":3,"names":["backend_util","Prod","upcastType","util","assertNotComplex","transpose","prodImpl","xShape","xDtype","xVals","reductionAxes","outShape","reduceShape","computeOutAndReduceShapes","outDtype","outVals","makeZerosTypedArray","sizeFromShape","reduceSize","i","length","offset","prod","j","args","inputs","backend","attrs","x","axis","keepDims","xRank","shape","axes","parseAxisParam","permutation","getAxesPermutation","permutedX","intermediateTensorInfos","perm","push","getInnerMostAxes","data","get","dataId","values","dtype","resultShape","expandShapeToKeepDim","forEach","t","disposeIntermediateTensorInfo","makeTensorInfo","prodConfig","kernelName","backendName","kernelFunc"],"sources":["/Users/jonchen/Documents/HackPSU/tfjs-backend-cpu/src/kernels/Prod.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, DataType, KernelConfig, KernelFunc, Prod, ProdAttrs, ProdInputs, TensorInfo, TypedArray, upcastType, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendCPU} from '../backend_cpu';\nimport {assertNotComplex} from '../cpu_util';\nimport {transpose} from './Transpose';\n\nexport function prodImpl(\n    xShape: number[], xDtype: DataType, xVals: TypedArray,\n    reductionAxes: number[]):\n    {outVals: TypedArray, outShape: number[], outDtype: DataType} {\n  const [outShape, reduceShape] =\n      backend_util.computeOutAndReduceShapes(xShape, reductionAxes);\n  const outDtype = upcastType(xDtype, 'int32');\n  const outVals = util.makeZerosTypedArray(\n                      util.sizeFromShape(outShape), outDtype) as TypedArray;\n  const reduceSize = util.sizeFromShape(reduceShape);\n\n  for (let i = 0; i < outVals.length; ++i) {\n    const offset = i * reduceSize;\n    let prod = 1;\n    for (let j = 0; j < reduceSize; ++j) {\n      prod *= xVals[offset + j];\n    }\n    outVals[i] = prod;\n  }\n\n  return {outVals, outShape, outDtype};\n}\n\nexport function prod(\n    args: {inputs: ProdInputs, backend: MathBackendCPU, attrs: ProdAttrs}):\n    TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {axis, keepDims} = attrs;\n\n  assertNotComplex(x, 'prod');\n\n  const xRank = x.shape.length;\n  const axes = util.parseAxisParam(axis, x.shape);\n\n  const permutation = backend_util.getAxesPermutation(axes, xRank);\n  let reductionAxes = axes;\n  let permutedX = x;\n  const intermediateTensorInfos = [];\n  if (permutation != null) {\n    permutedX = transpose({inputs: {x}, backend, attrs: {perm: permutation}});\n    intermediateTensorInfos.push(permutedX);\n    reductionAxes = backend_util.getInnerMostAxes(reductionAxes.length, xRank);\n  }\n\n  const xVals = backend.data.get(permutedX.dataId).values as TypedArray;\n  const {outVals, outShape, outDtype} =\n      prodImpl(permutedX.shape, permutedX.dtype, xVals, reductionAxes);\n\n  let resultShape = outShape;\n  if (keepDims) {\n    resultShape = backend_util.expandShapeToKeepDim(outShape, axes);\n  }\n\n  intermediateTensorInfos.forEach(\n      t => backend.disposeIntermediateTensorInfo(t));\n\n  return backend.makeTensorInfo(resultShape, outDtype, outVals);\n}\n\nexport const prodConfig: KernelConfig = {\n  kernelName: Prod,\n  backendName: 'cpu',\n  kernelFunc: prod as unknown as KernelFunc\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}