{"ast":null,"code":"/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../../engine';\nimport { SparseReshape } from '../../kernel_names';\nimport { convertToTensor } from '../../tensor_util_env';\nimport { op } from '../operation';\n/**\n * This operation has the same semantics as reshape on the represented dense\n * tensor. The `inputIndices` are recomputed based on the requested `newShape`.\n * If one component of `newShape` is the special value -1, the size of that\n * dimension is computed so that the total dense size remains constant. At most\n * one component of `newShape` can be -1. The number of dense elements implied\n * by `newShape` must be the same as the number of dense elements originally\n * implied by `inputShape`. Reshaping does not affect the order of values in the\n * SparseTensor. If the input tensor has rank R_in and N non-empty values, and\n * `newShape` has length R_out, then `inputIndices` has shape [N, R_in],\n * `inputShape` has length R_in, `outputIndices` has shape [N, R_out], and\n * `outputShape` has length R_out.\n *\n * ```js\n * const result = tf.sparse.sparseReshape(\n *   [[0, 0, 0], [0, 0, 1], [0, 1, 0], [1, 0, 0], [1, 2, 3]],\n *   [2, 3, 6], [9, -1]);\n * console.log(result);\n * result['outputIndices'].print(); //[[0, 0], [0, 1], [1, 2], [4, 2], [8, 1]]\n * result['outputShape'].print(); // [9, 4]\n * ```\n * @param inputIndices: 2-D. N x R_in matrix with the indices of non-empty\n * values in a SparseTensor.\n * @param inputShape: 1-D. R_in Tensor1D with the input SparseTensor's dense\n * shape.\n * @param newShape: 1-D. R_out Tensor1D with the requested new dense shape.\n * @return A map with the following properties:\n *     - outputIndices: 2-D. N x R_out matrix with the updated indices of\n *       non-empty values in the output SparseTensor.\n *     - outputShape: 1-D. R_out vector with the full dense shape of the output\n *       SparseTensor. This is the same as newShape but with any -1 dimensions\n *        filled in.\n * @doc {heading: 'Operations', subheading: 'Sparse'}\n */\nfunction sparseReshape_(inputIndices, inputShape, newShape) {\n  const $inputIndices = convertToTensor(inputIndices, 'inputIndices', 'sparseReshape', 'int32');\n  const $inputShape = convertToTensor(inputShape, 'inputShape', 'sparseReshape', 'int32');\n  const $newShape = convertToTensor(newShape, 'newShape', 'sparseReshape', 'int32');\n  if ($inputIndices.rank !== 2) {\n    throw new Error(`Input indices should be Tensor2D but received shape\n        ${$inputIndices.shape}`);\n  }\n  if ($inputShape.rank !== 1) {\n    throw new Error(`Input shape should be Tensor1D but received shape ${$inputShape.shape}`);\n  }\n  if ($newShape.rank !== 1) {\n    throw new Error(`New shape should be Tensor1D but received shape ${$newShape.shape}`);\n  }\n  const inputs = {\n    inputIndices: $inputIndices,\n    inputShape: $inputShape,\n    newShape: $newShape\n  };\n  const result = ENGINE.runKernel(SparseReshape, inputs);\n  return {\n    outputIndices: result[0],\n    outputShape: result[1]\n  };\n}\nexport const sparseReshape = /* @__PURE__ */op({\n  sparseReshape_\n});","map":{"version":3,"names":["ENGINE","SparseReshape","convertToTensor","op","sparseReshape_","inputIndices","inputShape","newShape","$inputIndices","$inputShape","$newShape","rank","Error","shape","inputs","result","runKernel","outputIndices","outputShape","sparseReshape"],"sources":["/Users/jonchen/Documents/HackPSU/tfjs-core/src/ops/sparse/sparse_reshape.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../../engine';\nimport {SparseReshape, SparseReshapeInputs} from '../../kernel_names';\nimport {Tensor, Tensor1D, Tensor2D} from '../../tensor';\nimport {NamedTensorMap} from '../../tensor_types';\nimport {convertToTensor} from '../../tensor_util_env';\nimport {TensorLike} from '../../types';\nimport {op} from '../operation';\n\n/**\n * This operation has the same semantics as reshape on the represented dense\n * tensor. The `inputIndices` are recomputed based on the requested `newShape`.\n * If one component of `newShape` is the special value -1, the size of that\n * dimension is computed so that the total dense size remains constant. At most\n * one component of `newShape` can be -1. The number of dense elements implied\n * by `newShape` must be the same as the number of dense elements originally\n * implied by `inputShape`. Reshaping does not affect the order of values in the\n * SparseTensor. If the input tensor has rank R_in and N non-empty values, and\n * `newShape` has length R_out, then `inputIndices` has shape [N, R_in],\n * `inputShape` has length R_in, `outputIndices` has shape [N, R_out], and\n * `outputShape` has length R_out.\n *\n * ```js\n * const result = tf.sparse.sparseReshape(\n *   [[0, 0, 0], [0, 0, 1], [0, 1, 0], [1, 0, 0], [1, 2, 3]],\n *   [2, 3, 6], [9, -1]);\n * console.log(result);\n * result['outputIndices'].print(); //[[0, 0], [0, 1], [1, 2], [4, 2], [8, 1]]\n * result['outputShape'].print(); // [9, 4]\n * ```\n * @param inputIndices: 2-D. N x R_in matrix with the indices of non-empty\n * values in a SparseTensor.\n * @param inputShape: 1-D. R_in Tensor1D with the input SparseTensor's dense\n * shape.\n * @param newShape: 1-D. R_out Tensor1D with the requested new dense shape.\n * @return A map with the following properties:\n *     - outputIndices: 2-D. N x R_out matrix with the updated indices of\n *       non-empty values in the output SparseTensor.\n *     - outputShape: 1-D. R_out vector with the full dense shape of the output\n *       SparseTensor. This is the same as newShape but with any -1 dimensions\n *        filled in.\n * @doc {heading: 'Operations', subheading: 'Sparse'}\n */\nfunction sparseReshape_(\n    inputIndices: Tensor2D|TensorLike, inputShape: Tensor1D|TensorLike,\n    newShape: Tensor1D|TensorLike): NamedTensorMap {\n  const $inputIndices =\n      convertToTensor(inputIndices, 'inputIndices', 'sparseReshape', 'int32');\n  const $inputShape =\n      convertToTensor(inputShape, 'inputShape', 'sparseReshape', 'int32');\n  const $newShape =\n      convertToTensor(newShape, 'newShape', 'sparseReshape', 'int32');\n\n  if ($inputIndices.rank !== 2) {\n    throw new Error(`Input indices should be Tensor2D but received shape\n        ${$inputIndices.shape}`);\n  }\n  if ($inputShape.rank !== 1) {\n    throw new Error(`Input shape should be Tensor1D but received shape ${\n        $inputShape.shape}`);\n  }\n  if ($newShape.rank !== 1) {\n    throw new Error(\n        `New shape should be Tensor1D but received shape ${$newShape.shape}`);\n  }\n\n  const inputs: SparseReshapeInputs = {\n    inputIndices: $inputIndices,\n    inputShape: $inputShape,\n    newShape: $newShape\n  };\n  const result: Tensor[] = ENGINE.runKernel(SparseReshape, inputs as {});\n  return {outputIndices: result[0], outputShape: result[1]};\n}\n\nexport const sparseReshape = /* @__PURE__ */ op({sparseReshape_});\n"],"mappings":"AAAA;;;;;;;;;;;;;;;;AAiBA,SAAQA,MAAM,QAAO,cAAc;AACnC,SAAQC,aAAa,QAA4B,oBAAoB;AAGrE,SAAQC,eAAe,QAAO,uBAAuB;AAErD,SAAQC,EAAE,QAAO,cAAc;AAE/B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkCA,SAASC,cAAcA,CACnBC,YAAiC,EAAEC,UAA+B,EAClEC,QAA6B;EAC/B,MAAMC,aAAa,GACfN,eAAe,CAACG,YAAY,EAAE,cAAc,EAAE,eAAe,EAAE,OAAO,CAAC;EAC3E,MAAMI,WAAW,GACbP,eAAe,CAACI,UAAU,EAAE,YAAY,EAAE,eAAe,EAAE,OAAO,CAAC;EACvE,MAAMI,SAAS,GACXR,eAAe,CAACK,QAAQ,EAAE,UAAU,EAAE,eAAe,EAAE,OAAO,CAAC;EAEnE,IAAIC,aAAa,CAACG,IAAI,KAAK,CAAC,EAAE;IAC5B,MAAM,IAAIC,KAAK,CAAC;UACVJ,aAAa,CAACK,KAAK,EAAE,CAAC;;EAE9B,IAAIJ,WAAW,CAACE,IAAI,KAAK,CAAC,EAAE;IAC1B,MAAM,IAAIC,KAAK,CAAC,qDACZH,WAAW,CAACI,KAAK,EAAE,CAAC;;EAE1B,IAAIH,SAAS,CAACC,IAAI,KAAK,CAAC,EAAE;IACxB,MAAM,IAAIC,KAAK,CACX,mDAAmDF,SAAS,CAACG,KAAK,EAAE,CAAC;;EAG3E,MAAMC,MAAM,GAAwB;IAClCT,YAAY,EAAEG,aAAa;IAC3BF,UAAU,EAAEG,WAAW;IACvBF,QAAQ,EAAEG;GACX;EACD,MAAMK,MAAM,GAAaf,MAAM,CAACgB,SAAS,CAACf,aAAa,EAAEa,MAAY,CAAC;EACtE,OAAO;IAACG,aAAa,EAAEF,MAAM,CAAC,CAAC,CAAC;IAAEG,WAAW,EAAEH,MAAM,CAAC,CAAC;EAAC,CAAC;AAC3D;AAEA,OAAO,MAAMI,aAAa,GAAG,eAAgBhB,EAAE,CAAC;EAACC;AAAc,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}