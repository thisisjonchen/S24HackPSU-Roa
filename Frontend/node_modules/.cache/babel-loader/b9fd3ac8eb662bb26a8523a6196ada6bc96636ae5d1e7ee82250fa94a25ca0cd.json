{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/**\n * Common functions for TensorFlow.js Layers.\n */\nimport { VALID_DATA_FORMAT_VALUES, VALID_INTERPOLATION_FORMAT_VALUES, VALID_PADDING_MODE_VALUES, VALID_POOL_MODE_VALUES } from './keras_format/common';\nimport { checkStringTypeUnionValue } from './utils/generic_utils';\n// A map from the requested scoped name of a Tensor to the number of Tensors\n// wanting that name so far.  This allows enforcing name uniqueness by appending\n// an incrementing index, e.g. scope/name, scope/name_1, scope/name_2, etc.\nconst nameMap = new Map();\nexport function checkDataFormat(value) {\n  checkStringTypeUnionValue(VALID_DATA_FORMAT_VALUES, 'DataFormat', value);\n}\nexport function checkInterpolationFormat(value) {\n  checkStringTypeUnionValue(VALID_INTERPOLATION_FORMAT_VALUES, 'InterpolationFormat', value);\n}\nexport function checkPaddingMode(value) {\n  checkStringTypeUnionValue(VALID_PADDING_MODE_VALUES, 'PaddingMode', value);\n}\nexport function checkPoolMode(value) {\n  checkStringTypeUnionValue(VALID_POOL_MODE_VALUES, 'PoolMode', value);\n}\nconst _nameScopeStack = [];\nconst _nameScopeDivider = '/';\n/**\n * Enter namescope, which can be nested.\n */\nexport function nameScope(name, fn) {\n  _nameScopeStack.push(name);\n  try {\n    const val = fn();\n    _nameScopeStack.pop();\n    return val;\n  } catch (e) {\n    _nameScopeStack.pop();\n    throw e;\n  }\n}\n/**\n * Get the current namescope as a flat, concatenated string.\n */\nfunction currentNameScopePrefix() {\n  if (_nameScopeStack.length === 0) {\n    return '';\n  } else {\n    return _nameScopeStack.join(_nameScopeDivider) + _nameScopeDivider;\n  }\n}\n/**\n * Get the name a Tensor (or Variable) would have if not uniqueified.\n * @param tensorName\n * @return Scoped name string.\n */\nexport function getScopedTensorName(tensorName) {\n  if (!isValidTensorName(tensorName)) {\n    throw new Error('Not a valid tensor name: \\'' + tensorName + '\\'');\n  }\n  return currentNameScopePrefix() + tensorName;\n}\n/**\n * Get unique names for Tensors and Variables.\n * @param scopedName The fully-qualified name of the Tensor, i.e. as produced by\n *  `getScopedTensorName()`.\n * @return A unique version of the given fully scoped name.\n *   If this is the first time that the scoped name is seen in this session,\n *   then the given `scopedName` is returned unaltered.  If the same name is\n *   seen again (producing a collision), an incrementing suffix is added to the\n *   end of the name, so it takes the form 'scope/name_1', 'scope/name_2', etc.\n */\nexport function getUniqueTensorName(scopedName) {\n  if (!isValidTensorName(scopedName)) {\n    throw new Error('Not a valid tensor name: \\'' + scopedName + '\\'');\n  }\n  if (!nameMap.has(scopedName)) {\n    nameMap.set(scopedName, 0);\n  }\n  const index = nameMap.get(scopedName);\n  nameMap.set(scopedName, nameMap.get(scopedName) + 1);\n  if (index > 0) {\n    const result = `${scopedName}_${index}`;\n    // Mark the composed name as used in case someone wants\n    // to call getUniqueTensorName(\"name_1\").\n    nameMap.set(result, 1);\n    return result;\n  } else {\n    return scopedName;\n  }\n}\nconst tensorNameRegex = new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\\._\\/]*$/);\n/**\n * Determine whether a string is a valid tensor name.\n * @param name\n * @returns A Boolean indicating whether `name` is a valid tensor name.\n */\nexport function isValidTensorName(name) {\n  return !!name.match(tensorNameRegex);\n}","map":{"version":3,"names":["VALID_DATA_FORMAT_VALUES","VALID_INTERPOLATION_FORMAT_VALUES","VALID_PADDING_MODE_VALUES","VALID_POOL_MODE_VALUES","checkStringTypeUnionValue","nameMap","Map","checkDataFormat","value","checkInterpolationFormat","checkPaddingMode","checkPoolMode","_nameScopeStack","_nameScopeDivider","nameScope","name","fn","push","val","pop","e","currentNameScopePrefix","length","join","getScopedTensorName","tensorName","isValidTensorName","Error","getUniqueTensorName","scopedName","has","set","index","get","result","tensorNameRegex","RegExp","match"],"sources":["/Users/jonchen/Documents/HackPSU/tfjs-layers/src/common.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\n/**\n * Common functions for TensorFlow.js Layers.\n */\nimport {VALID_DATA_FORMAT_VALUES, VALID_INTERPOLATION_FORMAT_VALUES, VALID_PADDING_MODE_VALUES, VALID_POOL_MODE_VALUES} from './keras_format/common';\nimport {checkStringTypeUnionValue} from './utils/generic_utils';\n\n// A map from the requested scoped name of a Tensor to the number of Tensors\n// wanting that name so far.  This allows enforcing name uniqueness by appending\n// an incrementing index, e.g. scope/name, scope/name_1, scope/name_2, etc.\nconst nameMap: Map<string, number> = new Map<string, number>();\n\nexport function checkDataFormat(value?: string): void {\n  checkStringTypeUnionValue(VALID_DATA_FORMAT_VALUES, 'DataFormat', value);\n}\n\nexport function checkInterpolationFormat(value?: string): void {\n  checkStringTypeUnionValue(\n      VALID_INTERPOLATION_FORMAT_VALUES, 'InterpolationFormat', value);\n}\n\nexport function checkPaddingMode(value?: string): void {\n  checkStringTypeUnionValue(VALID_PADDING_MODE_VALUES, 'PaddingMode', value);\n}\n\nexport function checkPoolMode(value?: string): void {\n  checkStringTypeUnionValue(VALID_POOL_MODE_VALUES, 'PoolMode', value);\n}\n\nconst _nameScopeStack: string[] = [];\nconst _nameScopeDivider = '/';\n\n/**\n * Enter namescope, which can be nested.\n */\nexport function nameScope<T>(name: string, fn: () => T): T {\n  _nameScopeStack.push(name);\n  try {\n    const val: T = fn();\n    _nameScopeStack.pop();\n    return val;\n  } catch (e) {\n    _nameScopeStack.pop();\n    throw e;\n  }\n}\n\n/**\n * Get the current namescope as a flat, concatenated string.\n */\nfunction currentNameScopePrefix(): string {\n  if (_nameScopeStack.length === 0) {\n    return '';\n  } else {\n    return _nameScopeStack.join(_nameScopeDivider) + _nameScopeDivider;\n  }\n}\n\n/**\n * Get the name a Tensor (or Variable) would have if not uniqueified.\n * @param tensorName\n * @return Scoped name string.\n */\nexport function getScopedTensorName(tensorName: string): string {\n  if (!isValidTensorName(tensorName)) {\n    throw new Error('Not a valid tensor name: \\'' + tensorName + '\\'');\n  }\n  return currentNameScopePrefix() + tensorName;\n}\n\n/**\n * Get unique names for Tensors and Variables.\n * @param scopedName The fully-qualified name of the Tensor, i.e. as produced by\n *  `getScopedTensorName()`.\n * @return A unique version of the given fully scoped name.\n *   If this is the first time that the scoped name is seen in this session,\n *   then the given `scopedName` is returned unaltered.  If the same name is\n *   seen again (producing a collision), an incrementing suffix is added to the\n *   end of the name, so it takes the form 'scope/name_1', 'scope/name_2', etc.\n */\nexport function getUniqueTensorName(scopedName: string): string {\n  if (!isValidTensorName(scopedName)) {\n    throw new Error('Not a valid tensor name: \\'' + scopedName + '\\'');\n  }\n  if (!nameMap.has(scopedName)) {\n    nameMap.set(scopedName, 0);\n  }\n  const index = nameMap.get(scopedName);\n  nameMap.set(scopedName, nameMap.get(scopedName) + 1);\n\n  if (index > 0) {\n    const result = `${scopedName}_${index}`;\n    // Mark the composed name as used in case someone wants\n    // to call getUniqueTensorName(\"name_1\").\n    nameMap.set(result, 1);\n    return result;\n  } else {\n    return scopedName;\n  }\n}\n\nconst tensorNameRegex = new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\\._\\/]*$/);\n\n/**\n * Determine whether a string is a valid tensor name.\n * @param name\n * @returns A Boolean indicating whether `name` is a valid tensor name.\n */\nexport function isValidTensorName(name: string): boolean {\n  return !!name.match(tensorNameRegex);\n}\n"],"mappings":"AAAA;;;;;;;;;AAUA;;;AAGA,SAAQA,wBAAwB,EAAEC,iCAAiC,EAAEC,yBAAyB,EAAEC,sBAAsB,QAAO,uBAAuB;AACpJ,SAAQC,yBAAyB,QAAO,uBAAuB;AAE/D;AACA;AACA;AACA,MAAMC,OAAO,GAAwB,IAAIC,GAAG,EAAkB;AAE9D,OAAM,SAAUC,eAAeA,CAACC,KAAc;EAC5CJ,yBAAyB,CAACJ,wBAAwB,EAAE,YAAY,EAAEQ,KAAK,CAAC;AAC1E;AAEA,OAAM,SAAUC,wBAAwBA,CAACD,KAAc;EACrDJ,yBAAyB,CACrBH,iCAAiC,EAAE,qBAAqB,EAAEO,KAAK,CAAC;AACtE;AAEA,OAAM,SAAUE,gBAAgBA,CAACF,KAAc;EAC7CJ,yBAAyB,CAACF,yBAAyB,EAAE,aAAa,EAAEM,KAAK,CAAC;AAC5E;AAEA,OAAM,SAAUG,aAAaA,CAACH,KAAc;EAC1CJ,yBAAyB,CAACD,sBAAsB,EAAE,UAAU,EAAEK,KAAK,CAAC;AACtE;AAEA,MAAMI,eAAe,GAAa,EAAE;AACpC,MAAMC,iBAAiB,GAAG,GAAG;AAE7B;;;AAGA,OAAM,SAAUC,SAASA,CAAIC,IAAY,EAAEC,EAAW;EACpDJ,eAAe,CAACK,IAAI,CAACF,IAAI,CAAC;EAC1B,IAAI;IACF,MAAMG,GAAG,GAAMF,EAAE,EAAE;IACnBJ,eAAe,CAACO,GAAG,EAAE;IACrB,OAAOD,GAAG;GACX,CAAC,OAAOE,CAAC,EAAE;IACVR,eAAe,CAACO,GAAG,EAAE;IACrB,MAAMC,CAAC;;AAEX;AAEA;;;AAGA,SAASC,sBAAsBA,CAAA;EAC7B,IAAIT,eAAe,CAACU,MAAM,KAAK,CAAC,EAAE;IAChC,OAAO,EAAE;GACV,MAAM;IACL,OAAOV,eAAe,CAACW,IAAI,CAACV,iBAAiB,CAAC,GAAGA,iBAAiB;;AAEtE;AAEA;;;;;AAKA,OAAM,SAAUW,mBAAmBA,CAACC,UAAkB;EACpD,IAAI,CAACC,iBAAiB,CAACD,UAAU,CAAC,EAAE;IAClC,MAAM,IAAIE,KAAK,CAAC,6BAA6B,GAAGF,UAAU,GAAG,IAAI,CAAC;;EAEpE,OAAOJ,sBAAsB,EAAE,GAAGI,UAAU;AAC9C;AAEA;;;;;;;;;;AAUA,OAAM,SAAUG,mBAAmBA,CAACC,UAAkB;EACpD,IAAI,CAACH,iBAAiB,CAACG,UAAU,CAAC,EAAE;IAClC,MAAM,IAAIF,KAAK,CAAC,6BAA6B,GAAGE,UAAU,GAAG,IAAI,CAAC;;EAEpE,IAAI,CAACxB,OAAO,CAACyB,GAAG,CAACD,UAAU,CAAC,EAAE;IAC5BxB,OAAO,CAAC0B,GAAG,CAACF,UAAU,EAAE,CAAC,CAAC;;EAE5B,MAAMG,KAAK,GAAG3B,OAAO,CAAC4B,GAAG,CAACJ,UAAU,CAAC;EACrCxB,OAAO,CAAC0B,GAAG,CAACF,UAAU,EAAExB,OAAO,CAAC4B,GAAG,CAACJ,UAAU,CAAC,GAAG,CAAC,CAAC;EAEpD,IAAIG,KAAK,GAAG,CAAC,EAAE;IACb,MAAME,MAAM,GAAG,GAAGL,UAAU,IAAIG,KAAK,EAAE;IACvC;IACA;IACA3B,OAAO,CAAC0B,GAAG,CAACG,MAAM,EAAE,CAAC,CAAC;IACtB,OAAOA,MAAM;GACd,MAAM;IACL,OAAOL,UAAU;;AAErB;AAEA,MAAMM,eAAe,GAAG,IAAIC,MAAM,CAAC,iCAAiC,CAAC;AAErE;;;;;AAKA,OAAM,SAAUV,iBAAiBA,CAACX,IAAY;EAC5C,OAAO,CAAC,CAACA,IAAI,CAACsB,KAAK,CAACF,eAAe,CAAC;AACtC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}