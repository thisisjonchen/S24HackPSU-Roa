{"ast":null,"code":"/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nfunction validateIndices(indices, indicesShape, numParams) {\n  indices.forEach((index, i) => {\n    if (index < 0 || index >= numParams) {\n      const locString = util.indexToLoc(i, indicesShape.length, util.computeStrides(indicesShape)).join(',');\n      throw new Error(`indices[${locString}] = ${index} is not in [0, ${numParams})`);\n    }\n  });\n}\nfunction validateSplits(paramsNestedSplits, numParamsDenseValues) {\n  // Validate\n  for (let dim = 0; dim < paramsNestedSplits.length; ++dim) {\n    const splits = paramsNestedSplits[dim];\n    const lastSplit = dim === paramsNestedSplits.length - 1 ? numParamsDenseValues : paramsNestedSplits[dim + 1].length;\n    if (splits.length === 0) {\n      throw new Error('Ragged splits may not be empty');\n    }\n    if (splits[0] < 0) {\n      throw new Error('Ragged splits must be non-negative');\n    }\n    if (splits[splits.length - 1] > lastSplit) {\n      throw new Error('Ragged splits must not point past values');\n    }\n    for (let i = 1; i < splits.length; ++i) {\n      if (splits[i - 1] > splits[i]) {\n        throw new Error('Ragged splits must be sorted in ascending order');\n      }\n    }\n  }\n}\n// Construct the `splits` output tensors, encoded using a nested vector.\n// Also find the slices of values that need to be copied, and store them\n// in `valueSlices`.  The total number of values that will be copied (which\n// we need for allocating the output values tensor) is stored in `numValues`.\nfunction makeSplits(indices, indicesShape, paramsNestedSplits, numParamsDenseValues) {\n  const valueSlices = [];\n  let numValues = 0;\n  const numSplits = indicesShape.length - 1 + paramsNestedSplits.length;\n  const outSplits = new Array(numSplits).fill(null).map(() => [0]);\n  validateSplits(paramsNestedSplits, numParamsDenseValues);\n  // Add `splits` that come from all but the last dimension of the dense\n  // Tensor `indices`.  In particular, for each dimension D, we add a\n  // splits tensor whose values are:\n  //   range(reduceProd(splits.shape[:D]) + 1) * splits.shape[D+1]\n  // E.g., if indices.shape=[2, 3, 4] then we will add splits tensors:\n  //   [0, 3, 6]                    # length=2+1, stride=3\n  //   [0, 4, 8, 12, 16, 20, 24]    # length=2*3+1, stride=4\n  let nrows = 1;\n  for (let dim = 0; dim < indicesShape.length - 1; ++dim) {\n    nrows *= indicesShape[dim];\n    const rowLength = indicesShape[dim + 1];\n    for (let i = 1; i < nrows + 1; ++i) {\n      outSplits[dim].push(i * rowLength);\n    }\n  }\n  // Add `splits` that come from `paramsNestedSplits`.  Starting with the\n  // outermost ragged dimension (i.e., the first `splits` tensor), we work\n  // our way in, finding the range of values that should be copied.  As we\n  // go, we update the output `splits` for each dimension with the appropriate\n  // values.  In particular, the *lengths* of the slices from `param_splits`\n  // should be copied to generate corresponding slice lengths in the output\n  // splits.  E.g., if we are copying a ragged row with length 4, then we\n  // should add a new split point to outSplits that is 4 greater than the\n  // previous split point in outSplits.\n  for (let i = 0; i < indices.length; ++i) {\n    let start = indices[i];\n    let limit = indices[i] + 1;\n    // Copy splits.\n    for (let dim = 0; dim < paramsNestedSplits.length; ++dim) {\n      const splits = paramsNestedSplits[dim];\n      const outDim = dim + indicesShape.length - 1;\n      if (outDim >= 0) {\n        const outSplitsOutDim = outSplits[outDim];\n        const delta = outSplitsOutDim[outSplitsOutDim.length - 1] - splits[start];\n        for (let j = start; j < limit; ++j) {\n          outSplits[outDim].push(splits[j + 1] + delta);\n        }\n      }\n      start = splits[start];\n      limit = splits[limit];\n    }\n    if (limit !== start) {\n      valueSlices.push([start, limit]);\n      numValues += limit - start;\n    }\n  }\n  return {\n    outSplits,\n    valueSlices,\n    numValues\n  };\n}\nfunction getSplits(outSplits) {\n  const splitsOut = [];\n  for (let i = 0; i < outSplits.length; ++i) {\n    const numSplits = outSplits[i].length;\n    const splits = util.getArrayFromDType('int32', numSplits);\n    splitsOut.push(splits);\n    outSplits[i].forEach((value, j) => splits[j] = value);\n  }\n  return splitsOut;\n}\nfunction computeFlatOuterDims(orig, numOutDims) {\n  const outDims = orig.slice(0, numOutDims);\n  while (outDims.length < numOutDims) {\n    outDims.push(1);\n  }\n  for (let inDim = numOutDims; inDim < orig.length; inDim++) {\n    outDims[numOutDims - 1] *= orig[inDim];\n  }\n  return outDims;\n}\n// For each slice in `(start, limit)` in `valueSlices`, append\n// `paramsDenseValues[start,...,limit] to `values`.  `valueSize` indicates\n// the number of scalars contained in each value paramsDenseValues[i].\nfunction writeValueSlices(paramsDenseValues, paramsDenseValuesShape, valueSlices, valueSize, values, valuesShape) {\n  const denseM = computeFlatOuterDims(paramsDenseValuesShape, 2)[1];\n  const valuesM = computeFlatOuterDims(valuesShape, 2)[1];\n  let outPos = 0;\n  for (const slice of valueSlices) {\n    for (let i = slice[0]; i < slice[1]; ++i) {\n      for (let j = 0; j < valueSize; ++j) {\n        values[outPos * valuesM + j] = paramsDenseValues[i * denseM + j];\n      }\n      ++outPos;\n    }\n  }\n}\nfunction getValues(paramsDenseValues, paramsDenseValuesShape, paramsDenseValuesDType, valueSlices, numValues) {\n  const valuesShape = paramsDenseValuesShape.slice();\n  valuesShape[0] = numValues;\n  const valuesOut = util.getArrayFromDType(paramsDenseValuesDType, util.sizeFromShape(valuesShape));\n  const numElements = paramsDenseValues.length;\n  const valueSize = numElements === 0 ? 0 : numElements / paramsDenseValuesShape[0];\n  writeValueSlices(paramsDenseValues, paramsDenseValuesShape, valueSlices, valueSize, valuesOut, valuesShape);\n  return [valuesOut, valuesShape];\n}\nexport function raggedGatherImpl(paramsNestedSplits, paramsNestedSplitsShapes, paramsDenseValues, paramsDenseValuesShape, paramsDenseValuesDType, indices, indicesShape, outputRaggedRank) {\n  if (paramsNestedSplits.length === 0) {\n    throw new Error('paramsNestedSplits must be non empty');\n  }\n  if (paramsNestedSplitsShapes[0].length === 0) {\n    throw new Error('Split tensors must not be scalars');\n  }\n  const numParams = paramsNestedSplitsShapes[0][0] - 1;\n  validateIndices(indices, indicesShape, numParams);\n  if (paramsDenseValuesShape.length === 0) {\n    throw new Error('params.rank must be nonzero');\n  }\n  const numParamsDenseValues = paramsDenseValuesShape[0];\n  // Calculate the `splits`, and store the value slices that we need to\n  // copy in `valueSlices`.\n  const {\n    outSplits,\n    valueSlices,\n    numValues\n  } = makeSplits(indices, indicesShape, paramsNestedSplits, numParamsDenseValues);\n  // Write the output tensors.\n  const outputNestedSplits = getSplits(outSplits);\n  const outputDenseValues = getValues(paramsDenseValues, paramsDenseValuesShape, paramsDenseValuesDType, valueSlices, numValues);\n  return [outputNestedSplits, outputDenseValues[0], outputDenseValues[1]];\n}","map":{"version":3,"names":["util","validateIndices","indices","indicesShape","numParams","forEach","index","i","locString","indexToLoc","length","computeStrides","join","Error","validateSplits","paramsNestedSplits","numParamsDenseValues","dim","splits","lastSplit","makeSplits","valueSlices","numValues","numSplits","outSplits","Array","fill","map","nrows","rowLength","push","start","limit","outDim","outSplitsOutDim","delta","j","getSplits","splitsOut","getArrayFromDType","value","computeFlatOuterDims","orig","numOutDims","outDims","slice","inDim","writeValueSlices","paramsDenseValues","paramsDenseValuesShape","valueSize","values","valuesShape","denseM","valuesM","outPos","getValues","paramsDenseValuesDType","valuesOut","sizeFromShape","numElements","raggedGatherImpl","paramsNestedSplitsShapes","outputRaggedRank","outputNestedSplits","outputDenseValues"],"sources":["/Users/jonchen/Documents/HackPSU/tfjs-backend-cpu/src/kernels/RaggedGather_impl.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {DataType, TypedArray, util} from '@tensorflow/tfjs-core';\n\nfunction validateIndices(\n    indices: TypedArray, indicesShape: number[], numParams: number) {\n  indices.forEach((index: number, i: number) => {\n    if (index < 0 || index >= numParams) {\n      const locString =\n          util.indexToLoc(\n                  i, indicesShape.length, util.computeStrides(indicesShape))\n              .join(',');\n      throw new Error(\n          `indices[${locString}] = ${index} is not in [0, ${numParams})`);\n    }\n  });\n}\n\nfunction validateSplits(\n    paramsNestedSplits: TypedArray[], numParamsDenseValues: number) {\n  // Validate\n  for (let dim = 0; dim < paramsNestedSplits.length; ++dim) {\n    const splits = paramsNestedSplits[dim];\n    const lastSplit = (dim === paramsNestedSplits.length - 1) ?\n        numParamsDenseValues :\n        paramsNestedSplits[dim + 1].length;\n    if (splits.length === 0) {\n      throw new Error('Ragged splits may not be empty');\n    }\n    if (splits[0] < 0) {\n      throw new Error('Ragged splits must be non-negative');\n    }\n    if (splits[splits.length - 1] > lastSplit) {\n      throw new Error('Ragged splits must not point past values');\n    }\n    for (let i = 1; i < splits.length; ++i) {\n      if (splits[i - 1] > splits[i]) {\n        throw new Error('Ragged splits must be sorted in ascending order');\n      }\n    }\n  }\n}\n\n// Construct the `splits` output tensors, encoded using a nested vector.\n// Also find the slices of values that need to be copied, and store them\n// in `valueSlices`.  The total number of values that will be copied (which\n// we need for allocating the output values tensor) is stored in `numValues`.\nfunction makeSplits(\n    indices: TypedArray, indicesShape: number[],\n    paramsNestedSplits: TypedArray[], numParamsDenseValues: number) {\n  const valueSlices: Array<[number, number]> = [];\n  let numValues = 0;\n\n  const numSplits = indicesShape.length - 1 + paramsNestedSplits.length;\n  const outSplits = new Array(numSplits).fill(null).map(() => [0]);\n\n  validateSplits(paramsNestedSplits, numParamsDenseValues);\n\n  // Add `splits` that come from all but the last dimension of the dense\n  // Tensor `indices`.  In particular, for each dimension D, we add a\n  // splits tensor whose values are:\n  //   range(reduceProd(splits.shape[:D]) + 1) * splits.shape[D+1]\n  // E.g., if indices.shape=[2, 3, 4] then we will add splits tensors:\n  //   [0, 3, 6]                    # length=2+1, stride=3\n  //   [0, 4, 8, 12, 16, 20, 24]    # length=2*3+1, stride=4\n  let nrows = 1;\n  for (let dim = 0; dim < indicesShape.length - 1; ++dim) {\n    nrows *= indicesShape[dim];\n    const rowLength = indicesShape[dim + 1];\n    for (let i = 1; i < nrows + 1; ++i) {\n      outSplits[dim].push(i * rowLength);\n    }\n  }\n\n  // Add `splits` that come from `paramsNestedSplits`.  Starting with the\n  // outermost ragged dimension (i.e., the first `splits` tensor), we work\n  // our way in, finding the range of values that should be copied.  As we\n  // go, we update the output `splits` for each dimension with the appropriate\n  // values.  In particular, the *lengths* of the slices from `param_splits`\n  // should be copied to generate corresponding slice lengths in the output\n  // splits.  E.g., if we are copying a ragged row with length 4, then we\n  // should add a new split point to outSplits that is 4 greater than the\n  // previous split point in outSplits.\n  for (let i = 0; i < indices.length; ++i) {\n    let start = indices[i];\n    let limit = indices[i] + 1;\n\n    // Copy splits.\n    for (let dim = 0; dim < paramsNestedSplits.length; ++dim) {\n      const splits = paramsNestedSplits[dim];\n      const outDim = dim + indicesShape.length - 1;\n      if (outDim >= 0) {\n        const outSplitsOutDim = outSplits[outDim];\n        const delta =\n            outSplitsOutDim[outSplitsOutDim.length - 1] - splits[start];\n        for (let j = start; j < limit; ++j) {\n          outSplits[outDim].push(splits[j + 1] + delta);\n        }\n      }\n      start = splits[start];\n      limit = splits[limit];\n    }\n    if (limit !== start) {\n      valueSlices.push([start, limit]);\n      numValues += limit - start;\n    }\n  }\n\n  return {outSplits, valueSlices, numValues};\n}\n\nfunction getSplits(outSplits: number[][]) {\n  const splitsOut: TypedArray[] = [];\n  for (let i = 0; i < outSplits.length; ++i) {\n    const numSplits = outSplits[i].length;\n    const splits = util.getArrayFromDType('int32', numSplits) as TypedArray;\n    splitsOut.push(splits);\n\n    outSplits[i].forEach((value, j: number) => splits[j] = value);\n  }\n\n  return splitsOut;\n}\n\nfunction computeFlatOuterDims(orig: number[], numOutDims: number) {\n  const outDims = orig.slice(0, numOutDims);\n  while (outDims.length < numOutDims) {\n    outDims.push(1);\n  }\n\n  for (let inDim = numOutDims; inDim < orig.length; inDim++) {\n    outDims[numOutDims - 1] *= orig[inDim];\n  }\n\n  return outDims;\n}\n// For each slice in `(start, limit)` in `valueSlices`, append\n// `paramsDenseValues[start,...,limit] to `values`.  `valueSize` indicates\n// the number of scalars contained in each value paramsDenseValues[i].\nfunction writeValueSlices(\n    paramsDenseValues: TypedArray, paramsDenseValuesShape: number[],\n    valueSlices: Array<[number, number]>, valueSize: number, values: TypedArray,\n    valuesShape: number[]) {\n  const denseM = computeFlatOuterDims(paramsDenseValuesShape, 2)[1];\n  const valuesM = computeFlatOuterDims(valuesShape, 2)[1];\n\n  let outPos = 0;\n  for (const slice of valueSlices) {\n    for (let i = slice[0]; i < slice[1]; ++i) {\n      for (let j = 0; j < valueSize; ++j) {\n        values[outPos * valuesM + j] = paramsDenseValues[i * denseM + j];\n      }\n      ++outPos;\n    }\n  }\n}\n\nfunction getValues(\n    paramsDenseValues: TypedArray, paramsDenseValuesShape: number[],\n    paramsDenseValuesDType: DataType, valueSlices: Array<[number, number]>,\n    numValues: number): [TypedArray, number[]] {\n  const valuesShape = paramsDenseValuesShape.slice();\n  valuesShape[0] = numValues;\n\n  const valuesOut = util.getArrayFromDType(\n                        paramsDenseValuesDType,\n                        util.sizeFromShape(valuesShape)) as TypedArray;\n\n  const numElements = paramsDenseValues.length;\n  const valueSize =\n      numElements === 0 ? 0 : (numElements / paramsDenseValuesShape[0]);\n  writeValueSlices(\n      paramsDenseValues, paramsDenseValuesShape, valueSlices, valueSize,\n      valuesOut, valuesShape);\n\n  return [valuesOut, valuesShape];\n}\nexport function raggedGatherImpl(\n    paramsNestedSplits: TypedArray[], paramsNestedSplitsShapes: number[][],\n    paramsDenseValues: TypedArray, paramsDenseValuesShape: number[],\n    paramsDenseValuesDType: DataType, indices: TypedArray,\n    indicesShape: number[],\n    outputRaggedRank: number): [TypedArray[], TypedArray, number[]] {\n  if (paramsNestedSplits.length === 0) {\n    throw new Error('paramsNestedSplits must be non empty');\n  }\n\n  if (paramsNestedSplitsShapes[0].length === 0) {\n    throw new Error('Split tensors must not be scalars');\n  }\n  const numParams = paramsNestedSplitsShapes[0][0] - 1;\n  validateIndices(indices, indicesShape, numParams);\n\n  if (paramsDenseValuesShape.length === 0) {\n    throw new Error('params.rank must be nonzero');\n  }\n  const numParamsDenseValues = paramsDenseValuesShape[0];\n\n  // Calculate the `splits`, and store the value slices that we need to\n  // copy in `valueSlices`.\n  const {outSplits, valueSlices, numValues} = makeSplits(\n      indices, indicesShape, paramsNestedSplits, numParamsDenseValues);\n\n  // Write the output tensors.\n  const outputNestedSplits = getSplits(outSplits);\n  const outputDenseValues = getValues(\n      paramsDenseValues, paramsDenseValuesShape, paramsDenseValuesDType,\n      valueSlices, numValues);\n\n  return [outputNestedSplits, outputDenseValues[0], outputDenseValues[1]];\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}