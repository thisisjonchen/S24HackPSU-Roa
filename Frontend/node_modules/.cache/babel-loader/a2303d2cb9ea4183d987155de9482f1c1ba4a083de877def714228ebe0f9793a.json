{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nimport { serialization } from '@tensorflow/tfjs-core';\nimport { getUid } from '../backend/state';\nimport { ValueError } from '../errors';\nimport { Layer, Node, SymbolicTensor } from './topology';\nclass InputLayer extends Layer {\n  constructor(args) {\n    super({\n      dtype: args.dtype,\n      name: args.name != null ? args.name : getUid('input').toString()\n    });\n    // Normalize config.batchSize and config.sparse\n    if (args.batchSize == null) {\n      args.batchSize = null;\n    }\n    if (args.sparse == null) {\n      args.sparse = false;\n    }\n    this.trainable = false;\n    this.built = true;\n    this.sparse = args.sparse;\n    if (args.inputShape != null && args.batchInputShape != null) {\n      throw new ValueError('Only provide the inputShape OR ' + 'batchInputShape argument to inputLayer, not both at the same time.');\n    }\n    let batchInputShape = args.batchInputShape;\n    if (batchInputShape == null) {\n      if (args.inputShape == null) {\n        throw new ValueError('An InputLayer should be passed either a ' + '`batchInputShape` or an `inputShape`.');\n      } else {\n        batchInputShape = [args.batchSize].concat(args.inputShape);\n      }\n    } else {\n      // TODO(michaelterry): Backport to PyKeras\n      if (args.batchSize != null) {\n        throw new ValueError('Cannot specify batchSize if batchInputShape is ' + 'specified when creating an InputLayer.');\n      }\n    }\n    const dtype = args.dtype || 'float32';\n    this.batchInputShape = batchInputShape;\n    this.dtype = dtype;\n    // TODO(michaelterry): Backport this to PyKeras?\n    this.inputSpec = [{\n      shape: batchInputShape\n    }];\n    const inputTensor = new SymbolicTensor(this.dtype, this.batchInputShape, this, [], {}, this.name);\n    inputTensor.nodeIndex = 0;\n    inputTensor.tensorIndex = 0;\n    // Create an input node to add to this.outboundNode.\n    // (This call has side effects.)\n    // tslint:disable-next-line:no-unused-expression\n    new Node({\n      outboundLayer: this,\n      inboundLayers: [],\n      nodeIndices: [],\n      tensorIndices: [],\n      inputTensors: [inputTensor],\n      outputTensors: [inputTensor],\n      inputMasks: [null],\n      outputMasks: [null],\n      inputShapes: [batchInputShape],\n      outputShapes: [batchInputShape]\n    });\n  }\n  apply(inputs, kwargs) {\n    throw new ValueError('Cannot pass any input to an ' + `InputLayer's apply() method. InputLayer name: ${this.name}`);\n  }\n  dispose() {\n    // dispose() for InputLayer is overridden as no-op.\n    return {\n      refCountAfterDispose: this._refCount,\n      numDisposedVariables: 0\n    };\n  }\n  getConfig() {\n    return {\n      batchInputShape: this.batchInputShape,\n      dtype: this.dtype,\n      sparse: this.sparse,\n      name: this.name\n    };\n  }\n}\n/** @nocollapse */\nInputLayer.className = 'InputLayer';\nexport { InputLayer };\nserialization.registerClass(InputLayer);\nexport function Input(config) {\n  if (config.batchShape == null && config.shape == null) {\n    throw new Error('Please provide to Input either a `shape`' + ' or a `batchShape` argument. Note that ' + '`shape` does not include the batch ' + 'dimension.');\n  }\n  if (config.batchShape != null && config.shape != null) {\n    // TODO(michaelterry): Backport to PyKeras.\n    throw new ValueError('Please provide either a `shape` or `batchShape` ' + 'argument to Input, but not both.');\n  }\n  let batchShape = config.batchShape;\n  if (config.shape != null && batchShape == null) {\n    batchShape = [null].concat(config.shape);\n  }\n  let dtype = config.dtype;\n  if (dtype == null) {\n    dtype = 'float32';\n  }\n  const inputLayer = new InputLayer({\n    batchInputShape: batchShape,\n    name: config.name,\n    dtype,\n    sparse: config.sparse\n  });\n  const outputs = inputLayer.inboundNodes[0].outputTensors;\n  return outputs[0];\n}","map":{"version":3,"names":["serialization","getUid","ValueError","Layer","Node","SymbolicTensor","InputLayer","constructor","args","dtype","name","toString","batchSize","sparse","trainable","built","inputShape","batchInputShape","concat","inputSpec","shape","inputTensor","nodeIndex","tensorIndex","outboundLayer","inboundLayers","nodeIndices","tensorIndices","inputTensors","outputTensors","inputMasks","outputMasks","inputShapes","outputShapes","apply","inputs","kwargs","dispose","refCountAfterDispose","_refCount","numDisposedVariables","getConfig","className","registerClass","Input","config","batchShape","Error","inputLayer","outputs","inboundNodes"],"sources":["/Users/jonchen/Documents/HackPSU/tfjs-layers/src/engine/input_layer.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\nimport {DataType, serialization, Tensor} from '@tensorflow/tfjs-core';\n\nimport {getUid} from '../backend/state';\nimport {ValueError} from '../errors';\nimport {Shape} from '../keras_format/common';\nimport {Kwargs} from '../types';\n\nimport {DisposeResult, Layer, Node, SymbolicTensor} from './topology';\n\n/**\n * Constructor arguments for InputLayer.\n *\n * Note: You should provide only inputShape or batchInputShape (not both).\n * If only inputShape is provided, then the batchInputShape is determined by\n * the batchSize argument and the inputShape: [batchSize].concat(inputShape).\n */\nexport declare interface InputLayerArgs {\n  /** Input shape, not including the batch axis. */\n  inputShape?: Shape;\n  /** Optional input batch size (integer or null). */\n  batchSize?: number;\n  /** Batch input shape, including the batch axis. */\n  batchInputShape?: Shape;\n  /** Datatype of the input.  */\n  dtype?: DataType;\n  /**\n   * Whether the placeholder created is meant to be sparse.\n   */\n  sparse?: boolean;  // TODO(michaelterry): Not clear whether we'll need this.\n\n  /** Name of the layer. */\n  name?: string;\n}\n\nexport class InputLayer extends Layer {\n  /** @nocollapse */\n  static readonly className = 'InputLayer';\n  sparse: boolean;\n  constructor(args: InputLayerArgs) {\n    super({\n      dtype: args.dtype,\n      name: args.name != null ? args.name : getUid('input').toString()\n    });\n    // Normalize config.batchSize and config.sparse\n    if (args.batchSize == null) {\n      args.batchSize = null;\n    }\n    if (args.sparse == null) {\n      args.sparse = false;\n    }\n\n    this.trainable = false;\n    this.built = true;\n    this.sparse = args.sparse;\n\n    if (args.inputShape != null && args.batchInputShape != null) {\n      throw new ValueError(\n          'Only provide the inputShape OR ' +\n          'batchInputShape argument to inputLayer, not both at the same time.');\n    }\n    let batchInputShape = args.batchInputShape;\n    if (batchInputShape == null) {\n      if (args.inputShape == null) {\n        throw new ValueError(\n            'An InputLayer should be passed either a ' +\n            '`batchInputShape` or an `inputShape`.');\n      } else {\n        batchInputShape = [args.batchSize].concat(args.inputShape);\n      }\n    } else {\n      // TODO(michaelterry): Backport to PyKeras\n      if (args.batchSize != null) {\n        throw new ValueError(\n            'Cannot specify batchSize if batchInputShape is ' +\n            'specified when creating an InputLayer.');\n      }\n    }\n\n    const dtype = args.dtype || 'float32';\n\n    this.batchInputShape = batchInputShape;\n    this.dtype = dtype;\n    // TODO(michaelterry): Backport this to PyKeras?\n    this.inputSpec = [{shape: batchInputShape}];\n\n    const inputTensor = new SymbolicTensor(\n        this.dtype, this.batchInputShape, this, [], {}, this.name);\n    inputTensor.nodeIndex = 0;\n    inputTensor.tensorIndex = 0;\n\n    // Create an input node to add to this.outboundNode.\n    // (This call has side effects.)\n    // tslint:disable-next-line:no-unused-expression\n    new Node({\n      outboundLayer: this,\n      inboundLayers: [],\n      nodeIndices: [],\n      tensorIndices: [],\n      inputTensors: [inputTensor],\n      outputTensors: [inputTensor],\n      inputMasks: [null],\n      outputMasks: [null],\n      inputShapes: [batchInputShape],\n      outputShapes: [batchInputShape]\n    });\n  }\n\n  override apply(\n      inputs: Tensor|Tensor[]|SymbolicTensor|SymbolicTensor[],\n      kwargs?: Kwargs): Tensor|Tensor[]|SymbolicTensor {\n    throw new ValueError(\n        'Cannot pass any input to an ' +\n        `InputLayer's apply() method. InputLayer name: ${this.name}`);\n  }\n\n  override dispose(): DisposeResult {\n    // dispose() for InputLayer is overridden as no-op.\n    return {refCountAfterDispose: this._refCount, numDisposedVariables: 0};\n  }\n\n  override getConfig(): serialization.ConfigDict {\n    return {\n      batchInputShape: this.batchInputShape,\n      dtype: this.dtype,\n      sparse: this.sparse,\n      name: this.name\n    };\n  }\n}\nserialization.registerClass(InputLayer);\n\n/**\n * Config for the Input function.\n *\n * Note: You should provide only shape or batchShape (not both).\n * If only shape is provided, then the batchShape becomes\n * [null].concat(inputShape).\n */\nexport interface InputConfig {\n  /**\n   * A shape, not including the batch size. For instance, `shape=[32]`\n   * indicates that the expected input will be batches of 32-dimensional\n   * vectors.\n   */\n  shape?: Shape;\n  /**\n   * A shape tuple (integer), including the batch size. For instance,\n   * `batchShape=[10, 32]` indicates that the expected input will be batches of\n   * 10 32-dimensional vectors. `batchShape=[null, 32]` indicates batches of an\n   * arbitrary number of 32-dimensional vectors.\n   */\n  batchShape?: Shape;\n  /**\n   * An optional name string for the layer. Should be unique in a model (do not\n   * reuse the same name twice). It will be autogenerated if it isn't provided.\n   */\n  name?: string;\n  dtype?: DataType;\n  /**\n   * A boolean specifying whether the placeholder to be created is sparse.\n   */\n  sparse?: boolean;\n}\n\nexport function Input(config: InputConfig): SymbolicTensor {\n  if (config.batchShape == null && config.shape == null) {\n    throw new Error(\n        'Please provide to Input either a `shape`' +\n        ' or a `batchShape` argument. Note that ' +\n        '`shape` does not include the batch ' +\n        'dimension.');\n  }\n  if (config.batchShape != null && config.shape != null) {\n    // TODO(michaelterry): Backport to PyKeras.\n    throw new ValueError(\n        'Please provide either a `shape` or `batchShape` ' +\n        'argument to Input, but not both.');\n  }\n  let batchShape = config.batchShape;\n  if (config.shape != null && batchShape == null) {\n    batchShape = [null].concat(config.shape);\n  }\n\n  let dtype = config.dtype;\n  if (dtype == null) {\n    dtype = 'float32';\n  }\n\n  const inputLayer = new InputLayer({\n    batchInputShape: batchShape,\n    name: config.name,\n    dtype,\n    sparse: config.sparse\n  });\n\n  const outputs = inputLayer.inboundNodes[0].outputTensors;\n  return outputs[0];\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}