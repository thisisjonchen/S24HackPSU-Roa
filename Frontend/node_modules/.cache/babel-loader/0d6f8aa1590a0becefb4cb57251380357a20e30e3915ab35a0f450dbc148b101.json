{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { SparseToDense } from '../kernel_names';\nimport * as sparse_to_dense from '../ops/sparse_to_dense_util';\nimport { convertToTensor } from '../tensor_util_env';\nimport { assertNonNegativeIntegerDimensions } from '../util_base';\nimport { op } from './operation';\n/**\n * Converts a sparse representation into a dense tensor.\n *\n * Builds an array dense with shape outputShape such that:\n *\n * // If sparseIndices is scalar\n * dense[i] = (i == sparseIndices ? sparseValues : defaultValue)\n *\n * // If sparseIndices is a vector, then for each i\n * dense[sparseIndices[i]] = sparseValues[i]\n *\n * // If sparseIndices is an n by d matrix, then for each i in [0, n)\n * dense[sparseIndices[i][0], ..., sparseIndices[i][d-1]] = sparseValues[i]\n * All other values in dense are set to defaultValue. If sparseValues is a\n * scalar, all sparse indices are set to this single value.\n *\n * If indices are repeated the final value is summed over all values for those\n * indices.\n *\n * ```js\n * const indices = tf.tensor1d([4, 5, 6, 1, 2, 3], 'int32');\n * const values = tf.tensor1d([10, 11, 12, 13, 14, 15], 'float32');\n * const shape = [8];\n * tf.sparseToDense(indices, values, shape).print();\n * ```\n *\n * @param sparseIndices A 0-D, 1-D, or 2-D Tensor of type int32.\n * sparseIndices[i] contains the complete index where sparseValues[i] will be\n * placed.\n * @param sparseValues A 0-D or 1-D Tensor. Values\n * corresponding to each row of sparseIndices, or a scalar value to be used for\n * all sparse indices.\n * @param outputShape Shape of the dense output tensor. The type is inferred.\n * @param defaultValue Scalar. Value to set for indices not specified in\n * sparseIndices. Defaults to zero.\n *\n * @doc {heading: 'Operations', subheading: 'Normalization'}\n */\nfunction sparseToDense_(sparseIndices, sparseValues, outputShape, defaultValue = 0) {\n  assertNonNegativeIntegerDimensions(outputShape);\n  const $sparseIndices = convertToTensor(sparseIndices, 'sparseIndices', 'sparseToDense', 'int32');\n  const $sparseValues = convertToTensor(sparseValues, 'sparseValues', 'sparseToDense', 'string_or_numeric');\n  const $defaultValue = convertToTensor(defaultValue, 'defaultValue', 'sparseToDense', $sparseValues.dtype);\n  sparse_to_dense.validateInput($sparseIndices, $sparseValues, outputShape, $defaultValue);\n  const inputs = {\n    sparseIndices: $sparseIndices,\n    sparseValues: $sparseValues,\n    defaultValue: $defaultValue\n  };\n  const attrs = {\n    outputShape\n  };\n  return ENGINE.runKernel(SparseToDense, inputs, attrs);\n}\nexport const sparseToDense = /* @__PURE__ */op({\n  sparseToDense_\n});","map":{"version":3,"names":["ENGINE","SparseToDense","sparse_to_dense","convertToTensor","assertNonNegativeIntegerDimensions","op","sparseToDense_","sparseIndices","sparseValues","outputShape","defaultValue","$sparseIndices","$sparseValues","$defaultValue","dtype","validateInput","inputs","attrs","runKernel","sparseToDense"],"sources":["/Users/jonchen/Documents/HackPSU/tfjs-core/src/ops/sparse_to_dense.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {SparseToDense, SparseToDenseAttrs, SparseToDenseInputs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport * as sparse_to_dense from '../ops/sparse_to_dense_util';\nimport {Scalar, Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {Rank, ScalarLike, ShapeMap, TensorLike} from '../types';\nimport {assertNonNegativeIntegerDimensions} from '../util_base';\n\nimport {op} from './operation';\n\n/**\n * Converts a sparse representation into a dense tensor.\n *\n * Builds an array dense with shape outputShape such that:\n *\n * // If sparseIndices is scalar\n * dense[i] = (i == sparseIndices ? sparseValues : defaultValue)\n *\n * // If sparseIndices is a vector, then for each i\n * dense[sparseIndices[i]] = sparseValues[i]\n *\n * // If sparseIndices is an n by d matrix, then for each i in [0, n)\n * dense[sparseIndices[i][0], ..., sparseIndices[i][d-1]] = sparseValues[i]\n * All other values in dense are set to defaultValue. If sparseValues is a\n * scalar, all sparse indices are set to this single value.\n *\n * If indices are repeated the final value is summed over all values for those\n * indices.\n *\n * ```js\n * const indices = tf.tensor1d([4, 5, 6, 1, 2, 3], 'int32');\n * const values = tf.tensor1d([10, 11, 12, 13, 14, 15], 'float32');\n * const shape = [8];\n * tf.sparseToDense(indices, values, shape).print();\n * ```\n *\n * @param sparseIndices A 0-D, 1-D, or 2-D Tensor of type int32.\n * sparseIndices[i] contains the complete index where sparseValues[i] will be\n * placed.\n * @param sparseValues A 0-D or 1-D Tensor. Values\n * corresponding to each row of sparseIndices, or a scalar value to be used for\n * all sparse indices.\n * @param outputShape Shape of the dense output tensor. The type is inferred.\n * @param defaultValue Scalar. Value to set for indices not specified in\n * sparseIndices. Defaults to zero.\n *\n * @doc {heading: 'Operations', subheading: 'Normalization'}\n */\nfunction sparseToDense_<R extends Rank>(\n    sparseIndices: Tensor|TensorLike, sparseValues: Tensor|TensorLike,\n    outputShape: ShapeMap[R], defaultValue: Scalar|ScalarLike = 0): Tensor<R> {\n  assertNonNegativeIntegerDimensions(outputShape);\n\n  const $sparseIndices =\n      convertToTensor(sparseIndices, 'sparseIndices', 'sparseToDense', 'int32');\n  const $sparseValues = convertToTensor(\n      sparseValues, 'sparseValues', 'sparseToDense', 'string_or_numeric');\n  const $defaultValue = convertToTensor(\n      defaultValue, 'defaultValue', 'sparseToDense', $sparseValues.dtype);\n\n  sparse_to_dense.validateInput(\n      $sparseIndices, $sparseValues, outputShape, $defaultValue);\n\n  const inputs: SparseToDenseInputs = {\n    sparseIndices: $sparseIndices,\n    sparseValues: $sparseValues,\n    defaultValue: $defaultValue\n  };\n\n  const attrs: SparseToDenseAttrs = {outputShape};\n\n  return ENGINE.runKernel(\n      SparseToDense, inputs as unknown as NamedTensorMap,\n      attrs as unknown as NamedAttrMap);\n}\n\nexport const sparseToDense = /* @__PURE__ */ op({sparseToDense_});\n"],"mappings":"AAAA;;;;;;;;;;;;;;;;AAiBA,SAAQA,MAAM,QAAO,WAAW;AAChC,SAAQC,aAAa,QAAgD,iBAAiB;AAEtF,OAAO,KAAKC,eAAe,MAAM,6BAA6B;AAG9D,SAAQC,eAAe,QAAO,oBAAoB;AAElD,SAAQC,kCAAkC,QAAO,cAAc;AAE/D,SAAQC,EAAE,QAAO,aAAa;AAE9B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsCA,SAASC,cAAcA,CACnBC,aAAgC,EAAEC,YAA+B,EACjEC,WAAwB,EAAEC,YAAA,GAAkC,CAAC;EAC/DN,kCAAkC,CAACK,WAAW,CAAC;EAE/C,MAAME,cAAc,GAChBR,eAAe,CAACI,aAAa,EAAE,eAAe,EAAE,eAAe,EAAE,OAAO,CAAC;EAC7E,MAAMK,aAAa,GAAGT,eAAe,CACjCK,YAAY,EAAE,cAAc,EAAE,eAAe,EAAE,mBAAmB,CAAC;EACvE,MAAMK,aAAa,GAAGV,eAAe,CACjCO,YAAY,EAAE,cAAc,EAAE,eAAe,EAAEE,aAAa,CAACE,KAAK,CAAC;EAEvEZ,eAAe,CAACa,aAAa,CACzBJ,cAAc,EAAEC,aAAa,EAAEH,WAAW,EAAEI,aAAa,CAAC;EAE9D,MAAMG,MAAM,GAAwB;IAClCT,aAAa,EAAEI,cAAc;IAC7BH,YAAY,EAAEI,aAAa;IAC3BF,YAAY,EAAEG;GACf;EAED,MAAMI,KAAK,GAAuB;IAACR;EAAW,CAAC;EAE/C,OAAOT,MAAM,CAACkB,SAAS,CACnBjB,aAAa,EAAEe,MAAmC,EAClDC,KAAgC,CAAC;AACvC;AAEA,OAAO,MAAME,aAAa,GAAG,eAAgBd,EAAE,CAAC;EAACC;AAAc,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}