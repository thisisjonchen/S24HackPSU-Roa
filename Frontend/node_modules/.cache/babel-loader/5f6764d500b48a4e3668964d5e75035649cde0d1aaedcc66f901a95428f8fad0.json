{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { assert } from '../../util';\nimport { complex } from '../complex';\nimport { concat } from '../concat';\nimport { imag } from '../imag';\nimport { op } from '../operation';\nimport { real } from '../real';\nimport { reshape } from '../reshape';\nimport { slice } from '../slice';\nimport { split } from '../split';\nimport { zeros } from '../zeros';\nimport { zerosLike } from '../zeros_like';\nimport { fft } from './fft';\n/**\n * Real value input fast Fourier transform.\n *\n * Computes the 1-dimensional discrete Fourier transform over the\n * inner-most dimension of the real input.\n *\n * ```js\n * const real = tf.tensor1d([1, 2, 3]);\n *\n * real.rfft().print();\n * ```\n * @param input The real value input to compute an rfft over.\n *\n * @doc {heading: 'Operations', subheading: 'Spectral', namespace: 'spectral'}\n */\nfunction rfft_(input, fftLength) {\n  assert(input.dtype === 'float32', () => `The dtype for rfft() must be real value but got ${input.dtype}`);\n  let innerDimensionSize = input.shape[input.shape.length - 1];\n  const batch = input.size / innerDimensionSize;\n  let adjustedInput;\n  if (fftLength != null && fftLength < innerDimensionSize) {\n    // Need to crop\n    const begin = input.shape.map(v => 0);\n    const size = input.shape.map(v => v);\n    size[input.shape.length - 1] = fftLength;\n    adjustedInput = slice(input, begin, size);\n    innerDimensionSize = fftLength;\n  } else if (fftLength != null && fftLength > innerDimensionSize) {\n    // Need to pad with zeros\n    const zerosShape = input.shape.map(v => v);\n    zerosShape[input.shape.length - 1] = fftLength - innerDimensionSize;\n    adjustedInput = concat([input, zeros(zerosShape)], input.shape.length - 1);\n    innerDimensionSize = fftLength;\n  } else {\n    adjustedInput = input;\n  }\n  // Complement the input with zero imaginary numbers.\n  const zerosInput = zerosLike(adjustedInput);\n  const complexInput = reshape(complex(adjustedInput, zerosInput), [batch, innerDimensionSize]);\n  const ret = fft(complexInput);\n  // Exclude complex conjugations. These conjugations are put symmetrically.\n  const half = Math.floor(innerDimensionSize / 2) + 1;\n  const realValues = real(ret);\n  const imagValues = imag(ret);\n  const realComplexConjugate = split(realValues, [half, innerDimensionSize - half], realValues.shape.length - 1);\n  const imagComplexConjugate = split(imagValues, [half, innerDimensionSize - half], imagValues.shape.length - 1);\n  const outputShape = adjustedInput.shape.slice();\n  outputShape[adjustedInput.shape.length - 1] = half;\n  return reshape(complex(realComplexConjugate[0], imagComplexConjugate[0]), outputShape);\n}\nexport const rfft = /* @__PURE__ */op({\n  rfft_\n});","map":{"version":3,"names":["assert","complex","concat","imag","op","real","reshape","slice","split","zeros","zerosLike","fft","rfft_","input","fftLength","dtype","innerDimensionSize","shape","length","batch","size","adjustedInput","begin","map","v","zerosShape","zerosInput","complexInput","ret","half","Math","floor","realValues","imagValues","realComplexConjugate","imagComplexConjugate","outputShape","rfft"],"sources":["/Users/jonchen/Documents/HackPSU/tfjs-core/src/ops/spectral/rfft.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor} from '../../tensor';\nimport {assert} from '../../util';\nimport {complex} from '../complex';\nimport {concat} from '../concat';\nimport {imag} from '../imag';\nimport {op} from '../operation';\nimport {real} from '../real';\nimport {reshape} from '../reshape';\nimport {slice} from '../slice';\nimport {split} from '../split';\nimport {zeros} from '../zeros';\nimport {zerosLike} from '../zeros_like';\n\nimport {fft} from './fft';\n\n/**\n * Real value input fast Fourier transform.\n *\n * Computes the 1-dimensional discrete Fourier transform over the\n * inner-most dimension of the real input.\n *\n * ```js\n * const real = tf.tensor1d([1, 2, 3]);\n *\n * real.rfft().print();\n * ```\n * @param input The real value input to compute an rfft over.\n *\n * @doc {heading: 'Operations', subheading: 'Spectral', namespace: 'spectral'}\n */\nfunction rfft_(input: Tensor, fftLength?: number): Tensor {\n  assert(\n      input.dtype === 'float32',\n      () => `The dtype for rfft() must be real value but got ${input.dtype}`);\n\n  let innerDimensionSize = input.shape[input.shape.length - 1];\n  const batch = input.size / innerDimensionSize;\n\n  let adjustedInput: Tensor;\n  if (fftLength != null && fftLength < innerDimensionSize) {\n    // Need to crop\n    const begin = input.shape.map(v => 0);\n    const size = input.shape.map(v => v);\n    size[input.shape.length - 1] = fftLength;\n    adjustedInput = slice(input, begin, size);\n    innerDimensionSize = fftLength;\n  } else if (fftLength != null && fftLength > innerDimensionSize) {\n    // Need to pad with zeros\n    const zerosShape = input.shape.map(v => v);\n    zerosShape[input.shape.length - 1] = fftLength - innerDimensionSize;\n    adjustedInput = concat([input, zeros(zerosShape)], input.shape.length - 1);\n    innerDimensionSize = fftLength;\n  } else {\n    adjustedInput = input;\n  }\n\n  // Complement the input with zero imaginary numbers.\n  const zerosInput = zerosLike(adjustedInput);\n  const complexInput =\n      reshape(complex(adjustedInput, zerosInput), [batch, innerDimensionSize]);\n\n  const ret = fft(complexInput);\n\n  // Exclude complex conjugations. These conjugations are put symmetrically.\n  const half = Math.floor(innerDimensionSize / 2) + 1;\n  const realValues = real(ret);\n  const imagValues = imag(ret);\n  const realComplexConjugate = split(\n      realValues, [half, innerDimensionSize - half],\n      realValues.shape.length - 1);\n  const imagComplexConjugate = split(\n      imagValues, [half, innerDimensionSize - half],\n      imagValues.shape.length - 1);\n\n  const outputShape = adjustedInput.shape.slice();\n  outputShape[adjustedInput.shape.length - 1] = half;\n\n  return reshape(\n      complex(realComplexConjugate[0], imagComplexConjugate[0]), outputShape);\n}\n\nexport const rfft = /* @__PURE__ */ op({rfft_});\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}