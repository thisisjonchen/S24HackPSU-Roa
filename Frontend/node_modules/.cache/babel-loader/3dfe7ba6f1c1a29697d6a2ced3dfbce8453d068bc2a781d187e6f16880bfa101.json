{"ast":null,"code":"/**\n * @license\n * Copyright 2022 Google LLC.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nconst INT32_MAX = 2147483647;\nexport function raggedRangeImpl(starts, startsShape, startsDType, limits, limitsShape, deltas, deltasShape) {\n  // Check input tensor shapes.\n  if (startsShape.length > 1) {\n    throw new Error('starts must be a scalar or vector');\n  }\n  if (limitsShape.length > 1) {\n    throw new Error('limits must be a scalar or vector');\n  }\n  if (deltasShape.length > 1) {\n    throw new Error('deltas must be a scalar or vector');\n  }\n  // Determine which tensors we need to broadcast.\n  const broadcastStarts = startsShape.length === 0;\n  const broadcastLimits = limitsShape.length === 0;\n  const broadcastDeltas = deltasShape.length === 0;\n  // nRows (number of output rows) is the size of the non-broadcast inputs,\n  // or 1 if all inputs are scalars.\n  const inSizes = [];\n  if (!broadcastStarts) {\n    inSizes.push(startsShape[0]);\n  }\n  if (!broadcastLimits) {\n    inSizes.push(limitsShape[0]);\n  }\n  if (!broadcastDeltas) {\n    inSizes.push(deltasShape[0]);\n  }\n  for (let i = 1; i < inSizes.length; ++i) {\n    if (inSizes[i] !== inSizes[i - 1]) {\n      throw new Error('starts, limits, and deltas must have the same shape');\n    }\n  }\n  const nRows = inSizes.length === 0 ? 1 : inSizes[0];\n  // Construct the rtNestedSplits tensor.\n  const rtNestedSplits = util.getArrayFromDType('int32', nRows + 1);\n  rtNestedSplits[0] = 0;\n  for (let row = 0; row < nRows; ++row) {\n    const start = broadcastStarts ? starts[0] : starts[row];\n    const limit = broadcastLimits ? limits[0] : limits[row];\n    const delta = broadcastDeltas ? deltas[0] : deltas[row];\n    if (delta === 0) {\n      throw new Error('Requires delta != 0');\n    }\n    let size; // The number of elements in the specified range.\n    if (delta > 0 && limit < start || delta < 0 && limit > start) {\n      size = 0;\n    } else {\n      size = Math.ceil(Math.abs((limit - start) / delta));\n      if (size > INT32_MAX) {\n        throw new Error(`Requires ((limit - start) / delta) <= ${INT32_MAX}`);\n      }\n    }\n    rtNestedSplits[row + 1] = rtNestedSplits[row] + size;\n  }\n  const nVals = rtNestedSplits[nRows];\n  // Construct the rtDenseValues tensor.\n  const rtDenseValues = util.getArrayFromDType(startsDType, nVals);\n  let valueIndex = 0;\n  for (let row = 0; row < nRows; ++row) {\n    const rowSize = rtNestedSplits[row + 1] - rtNestedSplits[row];\n    let value = broadcastStarts ? starts[0] : starts[row];\n    const delta = broadcastDeltas ? deltas[0] : deltas[row];\n    for (let i = 0; i < rowSize; ++i) {\n      rtDenseValues[valueIndex++] = value;\n      value += delta;\n    }\n  }\n  return [rtNestedSplits, rtDenseValues];\n}","map":{"version":3,"names":["util","INT32_MAX","raggedRangeImpl","starts","startsShape","startsDType","limits","limitsShape","deltas","deltasShape","length","Error","broadcastStarts","broadcastLimits","broadcastDeltas","inSizes","push","i","nRows","rtNestedSplits","getArrayFromDType","row","start","limit","delta","size","Math","ceil","abs","nVals","rtDenseValues","valueIndex","rowSize","value"],"sources":["/Users/jonchen/Documents/HackPSU/tfjs-backend-cpu/src/kernels/RaggedRange_impl.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2022 Google LLC.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {DataType, TypedArray, util} from '@tensorflow/tfjs-core';\n\nconst INT32_MAX = 2147483647;\n\nexport function raggedRangeImpl(\n    starts: TypedArray, startsShape: number[], startsDType: DataType,\n    limits: TypedArray, limitsShape: number[], deltas: TypedArray,\n    deltasShape: number[]): [TypedArray, TypedArray] {\n  // Check input tensor shapes.\n  if (startsShape.length > 1) {\n    throw new Error('starts must be a scalar or vector');\n  }\n  if (limitsShape.length > 1) {\n    throw new Error('limits must be a scalar or vector');\n  }\n  if (deltasShape.length > 1) {\n    throw new Error('deltas must be a scalar or vector');\n  }\n\n  // Determine which tensors we need to broadcast.\n  const broadcastStarts = startsShape.length === 0;\n  const broadcastLimits = limitsShape.length === 0;\n  const broadcastDeltas = deltasShape.length === 0;\n\n  // nRows (number of output rows) is the size of the non-broadcast inputs,\n  // or 1 if all inputs are scalars.\n  const inSizes: number[] = [];\n  if (!broadcastStarts) {\n    inSizes.push(startsShape[0]);\n  }\n  if (!broadcastLimits) {\n    inSizes.push(limitsShape[0]);\n  }\n  if (!broadcastDeltas) {\n    inSizes.push(deltasShape[0]);\n  }\n\n  for (let i = 1; i < inSizes.length; ++i) {\n    if (inSizes[i] !== inSizes[i - 1]) {\n      throw new Error('starts, limits, and deltas must have the same shape');\n    }\n  }\n  const nRows = inSizes.length === 0 ? 1 : inSizes[0];\n\n  // Construct the rtNestedSplits tensor.\n  const rtNestedSplits =\n      util.getArrayFromDType('int32', nRows + 1) as TypedArray;\n  rtNestedSplits[0] = 0;\n  for (let row = 0; row < nRows; ++row) {\n    const start = broadcastStarts ? starts[0] : starts[row];\n    const limit = broadcastLimits ? limits[0] : limits[row];\n    const delta = broadcastDeltas ? deltas[0] : deltas[row];\n    if (delta === 0) {\n      throw new Error('Requires delta != 0');\n    }\n    let size: number;  // The number of elements in the specified range.\n    if (((delta > 0) && (limit < start)) || ((delta < 0) && (limit > start))) {\n      size = 0;\n    } else {\n      size = Math.ceil(Math.abs((limit - start) / delta));\n\n      if (size > INT32_MAX) {\n        throw new Error(`Requires ((limit - start) / delta) <= ${INT32_MAX}`);\n      }\n    }\n    rtNestedSplits[row + 1] = rtNestedSplits[row] + size;\n  }\n\n  const nVals = rtNestedSplits[nRows];\n\n  // Construct the rtDenseValues tensor.\n  const rtDenseValues =\n      util.getArrayFromDType(startsDType, nVals) as TypedArray;\n\n  let valueIndex = 0;\n  for (let row = 0; row < nRows; ++row) {\n    const rowSize = rtNestedSplits[row + 1] - rtNestedSplits[row];\n    let value = broadcastStarts ? starts[0] : starts[row];\n    const delta = broadcastDeltas ? deltas[0] : deltas[row];\n    for (let i = 0; i < rowSize; ++i) {\n      rtDenseValues[valueIndex++] = value;\n      value += delta;\n    }\n  }\n\n  return [rtNestedSplits, rtDenseValues];\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}