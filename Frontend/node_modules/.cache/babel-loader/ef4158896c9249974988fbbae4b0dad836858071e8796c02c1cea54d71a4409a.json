{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/**\n * TensorFlow.js Layers: Pooling Layers.\n */\nimport * as tfc from '@tensorflow/tfjs-core';\nimport { serialization, tidy } from '@tensorflow/tfjs-core';\nimport { imageDataFormat } from '../backend/common';\nimport * as K from '../backend/tfjs_backend';\nimport { checkDataFormat, checkPaddingMode, checkPoolMode } from '../common';\nimport { InputSpec } from '../engine/topology';\nimport { Layer } from '../engine/topology';\nimport { NotImplementedError, ValueError } from '../errors';\nimport { convOutputLength } from '../utils/conv_utils';\nimport { assertPositiveInteger } from '../utils/generic_utils';\nimport { getExactlyOneShape, getExactlyOneTensor } from '../utils/types_utils';\nimport { preprocessConv2DInput, preprocessConv3DInput } from './convolutional';\n/**\n * 2D pooling.\n * @param x\n * @param poolSize\n * @param strides strides. Defaults to [1, 1].\n * @param padding padding. Defaults to 'valid'.\n * @param dataFormat data format. Defaults to 'channelsLast'.\n * @param poolMode Mode of pooling. Defaults to 'max'.\n * @returns Result of the 2D pooling.\n */\nexport function pool2d(x, poolSize, strides, padding, dataFormat, poolMode) {\n  return tidy(() => {\n    checkDataFormat(dataFormat);\n    checkPoolMode(poolMode);\n    checkPaddingMode(padding);\n    if (strides == null) {\n      strides = [1, 1];\n    }\n    if (padding == null) {\n      padding = 'valid';\n    }\n    if (dataFormat == null) {\n      dataFormat = imageDataFormat();\n    }\n    if (poolMode == null) {\n      poolMode = 'max';\n    }\n    // TODO(cais): Remove the preprocessing step once deeplearn.js supports\n    // dataFormat as an input argument.\n    x = preprocessConv2DInput(x, dataFormat); // x is NHWC after preprocessing.\n    let y;\n    const paddingString = padding === 'same' ? 'same' : 'valid';\n    if (poolMode === 'max') {\n      // TODO(cais): Rank check?\n      y = tfc.maxPool(x, poolSize, strides, paddingString);\n    } else {\n      // 'avg'\n      // TODO(cais): Check the dtype and rank of x and give clear error message\n      //   if those are incorrect.\n      y = tfc.avgPool(\n      // TODO(cais): Rank check?\n      x, poolSize, strides, paddingString);\n    }\n    if (dataFormat === 'channelsFirst') {\n      y = tfc.transpose(y, [0, 3, 1, 2]); // NHWC -> NCHW.\n    }\n    return y;\n  });\n}\n/**\n * 3D pooling.\n * @param x\n * @param poolSize. Default to [1, 1, 1].\n * @param strides strides. Defaults to [1, 1, 1].\n * @param padding padding. Defaults to 'valid'.\n * @param dataFormat data format. Defaults to 'channelsLast'.\n * @param poolMode Mode of pooling. Defaults to 'max'.\n * @returns Result of the 3D pooling.\n */\nexport function pool3d(x, poolSize, strides, padding, dataFormat, poolMode) {\n  return tidy(() => {\n    checkDataFormat(dataFormat);\n    checkPoolMode(poolMode);\n    checkPaddingMode(padding);\n    if (strides == null) {\n      strides = [1, 1, 1];\n    }\n    if (padding == null) {\n      padding = 'valid';\n    }\n    if (dataFormat == null) {\n      dataFormat = imageDataFormat();\n    }\n    if (poolMode == null) {\n      poolMode = 'max';\n    }\n    // x is NDHWC after preprocessing.\n    x = preprocessConv3DInput(x, dataFormat);\n    let y;\n    const paddingString = padding === 'same' ? 'same' : 'valid';\n    if (poolMode === 'max') {\n      y = tfc.maxPool3d(x, poolSize, strides, paddingString);\n    } else {\n      // 'avg'\n      y = tfc.avgPool3d(x, poolSize, strides, paddingString);\n    }\n    if (dataFormat === 'channelsFirst') {\n      y = tfc.transpose(y, [0, 4, 1, 2, 3]); // NDHWC -> NCDHW.\n    }\n    return y;\n  });\n}\n/**\n * Abstract class for different pooling 1D layers.\n */\nexport class Pooling1D extends Layer {\n  /**\n   *\n   * @param args Parameters for the Pooling layer.\n   *\n   * config.poolSize defaults to 2.\n   */\n  constructor(args) {\n    if (args.poolSize == null) {\n      args.poolSize = 2;\n    }\n    super(args);\n    if (typeof args.poolSize === 'number') {\n      this.poolSize = [args.poolSize];\n    } else if (Array.isArray(args.poolSize) && args.poolSize.length === 1 && typeof args.poolSize[0] === 'number') {\n      this.poolSize = args.poolSize;\n    } else {\n      throw new ValueError(`poolSize for 1D convolutional layer must be a number or an ` + `Array of a single number, but received ` + `${JSON.stringify(args.poolSize)}`);\n    }\n    assertPositiveInteger(this.poolSize, 'poolSize');\n    if (args.strides == null) {\n      this.strides = this.poolSize;\n    } else {\n      if (typeof args.strides === 'number') {\n        this.strides = [args.strides];\n      } else if (Array.isArray(args.strides) && args.strides.length === 1 && typeof args.strides[0] === 'number') {\n        this.strides = args.strides;\n      } else {\n        throw new ValueError(`strides for 1D convolutional layer must be a number or an ` + `Array of a single number, but received ` + `${JSON.stringify(args.strides)}`);\n      }\n    }\n    assertPositiveInteger(this.strides, 'strides');\n    this.padding = args.padding == null ? 'valid' : args.padding;\n    checkPaddingMode(this.padding);\n    this.inputSpec = [new InputSpec({\n      ndim: 3\n    })];\n  }\n  computeOutputShape(inputShape) {\n    inputShape = getExactlyOneShape(inputShape);\n    const length = convOutputLength(inputShape[1], this.poolSize[0], this.padding, this.strides[0]);\n    return [inputShape[0], length, inputShape[2]];\n  }\n  call(inputs, kwargs) {\n    return tidy(() => {\n      this.invokeCallHook(inputs, kwargs);\n      // Add dummy last dimension.\n      inputs = K.expandDims(getExactlyOneTensor(inputs), 2);\n      const output = this.poolingFunction(getExactlyOneTensor(inputs), [this.poolSize[0], 1], [this.strides[0], 1], this.padding, 'channelsLast');\n      // Remove dummy last dimension.\n      return tfc.squeeze(output, [2]);\n    });\n  }\n  getConfig() {\n    const config = {\n      poolSize: this.poolSize,\n      padding: this.padding,\n      strides: this.strides\n    };\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n}\nclass MaxPooling1D extends Pooling1D {\n  constructor(args) {\n    super(args);\n  }\n  poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n    checkDataFormat(dataFormat);\n    checkPaddingMode(padding);\n    return pool2d(inputs, poolSize, strides, padding, dataFormat, 'max');\n  }\n}\n/** @nocollapse */\nMaxPooling1D.className = 'MaxPooling1D';\nexport { MaxPooling1D };\nserialization.registerClass(MaxPooling1D);\nclass AveragePooling1D extends Pooling1D {\n  constructor(args) {\n    super(args);\n  }\n  poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n    checkDataFormat(dataFormat);\n    checkPaddingMode(padding);\n    return pool2d(inputs, poolSize, strides, padding, dataFormat, 'avg');\n  }\n}\n/** @nocollapse */\nAveragePooling1D.className = 'AveragePooling1D';\nexport { AveragePooling1D };\nserialization.registerClass(AveragePooling1D);\n/**\n * Abstract class for different pooling 2D layers.\n */\nexport class Pooling2D extends Layer {\n  constructor(args) {\n    if (args.poolSize == null) {\n      args.poolSize = [2, 2];\n    }\n    super(args);\n    this.poolSize = Array.isArray(args.poolSize) ? args.poolSize : [args.poolSize, args.poolSize];\n    if (args.strides == null) {\n      this.strides = this.poolSize;\n    } else if (Array.isArray(args.strides)) {\n      if (args.strides.length !== 2) {\n        throw new ValueError(`If the strides property of a 2D pooling layer is an Array, ` + `it is expected to have a length of 2, but received length ` + `${args.strides.length}.`);\n      }\n      this.strides = args.strides;\n    } else {\n      // `config.strides` is a number.\n      this.strides = [args.strides, args.strides];\n    }\n    assertPositiveInteger(this.poolSize, 'poolSize');\n    assertPositiveInteger(this.strides, 'strides');\n    this.padding = args.padding == null ? 'valid' : args.padding;\n    this.dataFormat = args.dataFormat == null ? 'channelsLast' : args.dataFormat;\n    checkDataFormat(this.dataFormat);\n    checkPaddingMode(this.padding);\n    this.inputSpec = [new InputSpec({\n      ndim: 4\n    })];\n  }\n  computeOutputShape(inputShape) {\n    inputShape = getExactlyOneShape(inputShape);\n    let rows = this.dataFormat === 'channelsFirst' ? inputShape[2] : inputShape[1];\n    let cols = this.dataFormat === 'channelsFirst' ? inputShape[3] : inputShape[2];\n    rows = convOutputLength(rows, this.poolSize[0], this.padding, this.strides[0]);\n    cols = convOutputLength(cols, this.poolSize[1], this.padding, this.strides[1]);\n    if (this.dataFormat === 'channelsFirst') {\n      return [inputShape[0], inputShape[1], rows, cols];\n    } else {\n      return [inputShape[0], rows, cols, inputShape[3]];\n    }\n  }\n  call(inputs, kwargs) {\n    return tidy(() => {\n      this.invokeCallHook(inputs, kwargs);\n      return this.poolingFunction(getExactlyOneTensor(inputs), this.poolSize, this.strides, this.padding, this.dataFormat);\n    });\n  }\n  getConfig() {\n    const config = {\n      poolSize: this.poolSize,\n      padding: this.padding,\n      strides: this.strides,\n      dataFormat: this.dataFormat\n    };\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n}\nclass MaxPooling2D extends Pooling2D {\n  constructor(args) {\n    super(args);\n  }\n  poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n    checkDataFormat(dataFormat);\n    checkPaddingMode(padding);\n    return pool2d(inputs, poolSize, strides, padding, dataFormat, 'max');\n  }\n}\n/** @nocollapse */\nMaxPooling2D.className = 'MaxPooling2D';\nexport { MaxPooling2D };\nserialization.registerClass(MaxPooling2D);\nclass AveragePooling2D extends Pooling2D {\n  constructor(args) {\n    super(args);\n  }\n  poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n    checkDataFormat(dataFormat);\n    checkPaddingMode(padding);\n    return pool2d(inputs, poolSize, strides, padding, dataFormat, 'avg');\n  }\n}\n/** @nocollapse */\nAveragePooling2D.className = 'AveragePooling2D';\nexport { AveragePooling2D };\nserialization.registerClass(AveragePooling2D);\n/**\n * Abstract class for different pooling 3D layers.\n */\nexport class Pooling3D extends Layer {\n  constructor(args) {\n    if (args.poolSize == null) {\n      args.poolSize = [2, 2, 2];\n    }\n    super(args);\n    this.poolSize = Array.isArray(args.poolSize) ? args.poolSize : [args.poolSize, args.poolSize, args.poolSize];\n    if (args.strides == null) {\n      this.strides = this.poolSize;\n    } else if (Array.isArray(args.strides)) {\n      if (args.strides.length !== 3) {\n        throw new ValueError(`If the strides property of a 3D pooling layer is an Array, ` + `it is expected to have a length of 3, but received length ` + `${args.strides.length}.`);\n      }\n      this.strides = args.strides;\n    } else {\n      // `config.strides` is a number.\n      this.strides = [args.strides, args.strides, args.strides];\n    }\n    assertPositiveInteger(this.poolSize, 'poolSize');\n    assertPositiveInteger(this.strides, 'strides');\n    this.padding = args.padding == null ? 'valid' : args.padding;\n    this.dataFormat = args.dataFormat == null ? 'channelsLast' : args.dataFormat;\n    checkDataFormat(this.dataFormat);\n    checkPaddingMode(this.padding);\n    this.inputSpec = [new InputSpec({\n      ndim: 5\n    })];\n  }\n  computeOutputShape(inputShape) {\n    inputShape = getExactlyOneShape(inputShape);\n    let depths = this.dataFormat === 'channelsFirst' ? inputShape[2] : inputShape[1];\n    let rows = this.dataFormat === 'channelsFirst' ? inputShape[3] : inputShape[2];\n    let cols = this.dataFormat === 'channelsFirst' ? inputShape[4] : inputShape[3];\n    depths = convOutputLength(depths, this.poolSize[0], this.padding, this.strides[0]);\n    rows = convOutputLength(rows, this.poolSize[1], this.padding, this.strides[1]);\n    cols = convOutputLength(cols, this.poolSize[2], this.padding, this.strides[2]);\n    if (this.dataFormat === 'channelsFirst') {\n      return [inputShape[0], inputShape[1], depths, rows, cols];\n    } else {\n      return [inputShape[0], depths, rows, cols, inputShape[4]];\n    }\n  }\n  call(inputs, kwargs) {\n    return tidy(() => {\n      this.invokeCallHook(inputs, kwargs);\n      return this.poolingFunction(getExactlyOneTensor(inputs), this.poolSize, this.strides, this.padding, this.dataFormat);\n    });\n  }\n  getConfig() {\n    const config = {\n      poolSize: this.poolSize,\n      padding: this.padding,\n      strides: this.strides,\n      dataFormat: this.dataFormat\n    };\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n}\nclass MaxPooling3D extends Pooling3D {\n  constructor(args) {\n    super(args);\n  }\n  poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n    checkDataFormat(dataFormat);\n    checkPaddingMode(padding);\n    return pool3d(inputs, poolSize, strides, padding, dataFormat, 'max');\n  }\n}\n/** @nocollapse */\nMaxPooling3D.className = 'MaxPooling3D';\nexport { MaxPooling3D };\nserialization.registerClass(MaxPooling3D);\nclass AveragePooling3D extends Pooling3D {\n  constructor(args) {\n    super(args);\n  }\n  poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n    checkDataFormat(dataFormat);\n    checkPaddingMode(padding);\n    return pool3d(inputs, poolSize, strides, padding, dataFormat, 'avg');\n  }\n}\n/** @nocollapse */\nAveragePooling3D.className = 'AveragePooling3D';\nexport { AveragePooling3D };\nserialization.registerClass(AveragePooling3D);\n/**\n * Abstract class for different global pooling 1D layers.\n */\nexport class GlobalPooling1D extends Layer {\n  constructor(args) {\n    super(args);\n    this.inputSpec = [new InputSpec({\n      ndim: 3\n    })];\n  }\n  computeOutputShape(inputShape) {\n    return [inputShape[0], inputShape[2]];\n  }\n  call(inputs, kwargs) {\n    throw new NotImplementedError();\n  }\n}\nclass GlobalAveragePooling1D extends GlobalPooling1D {\n  constructor(args) {\n    super(args || {});\n  }\n  call(inputs, kwargs) {\n    return tidy(() => {\n      const input = getExactlyOneTensor(inputs);\n      return tfc.mean(input, 1);\n    });\n  }\n}\n/** @nocollapse */\nGlobalAveragePooling1D.className = 'GlobalAveragePooling1D';\nexport { GlobalAveragePooling1D };\nserialization.registerClass(GlobalAveragePooling1D);\nclass GlobalMaxPooling1D extends GlobalPooling1D {\n  constructor(args) {\n    super(args || {});\n  }\n  call(inputs, kwargs) {\n    return tidy(() => {\n      const input = getExactlyOneTensor(inputs);\n      return tfc.max(input, 1);\n    });\n  }\n}\n/** @nocollapse */\nGlobalMaxPooling1D.className = 'GlobalMaxPooling1D';\nexport { GlobalMaxPooling1D };\nserialization.registerClass(GlobalMaxPooling1D);\n/**\n * Abstract class for different global pooling 2D layers.\n */\nexport class GlobalPooling2D extends Layer {\n  constructor(args) {\n    super(args);\n    this.dataFormat = args.dataFormat == null ? 'channelsLast' : args.dataFormat;\n    checkDataFormat(this.dataFormat);\n    this.inputSpec = [new InputSpec({\n      ndim: 4\n    })];\n  }\n  computeOutputShape(inputShape) {\n    inputShape = inputShape;\n    if (this.dataFormat === 'channelsLast') {\n      return [inputShape[0], inputShape[3]];\n    } else {\n      return [inputShape[0], inputShape[1]];\n    }\n  }\n  call(inputs, kwargs) {\n    throw new NotImplementedError();\n  }\n  getConfig() {\n    const config = {\n      dataFormat: this.dataFormat\n    };\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n}\nclass GlobalAveragePooling2D extends GlobalPooling2D {\n  call(inputs, kwargs) {\n    return tidy(() => {\n      const input = getExactlyOneTensor(inputs);\n      if (this.dataFormat === 'channelsLast') {\n        return tfc.mean(input, [1, 2]);\n      } else {\n        return tfc.mean(input, [2, 3]);\n      }\n    });\n  }\n}\n/** @nocollapse */\nGlobalAveragePooling2D.className = 'GlobalAveragePooling2D';\nexport { GlobalAveragePooling2D };\nserialization.registerClass(GlobalAveragePooling2D);\nclass GlobalMaxPooling2D extends GlobalPooling2D {\n  call(inputs, kwargs) {\n    return tidy(() => {\n      const input = getExactlyOneTensor(inputs);\n      if (this.dataFormat === 'channelsLast') {\n        return tfc.max(input, [1, 2]);\n      } else {\n        return tfc.max(input, [2, 3]);\n      }\n    });\n  }\n}\n/** @nocollapse */\nGlobalMaxPooling2D.className = 'GlobalMaxPooling2D';\nexport { GlobalMaxPooling2D };\nserialization.registerClass(GlobalMaxPooling2D);","map":{"version":3,"names":["tfc","serialization","tidy","imageDataFormat","K","checkDataFormat","checkPaddingMode","checkPoolMode","InputSpec","Layer","NotImplementedError","ValueError","convOutputLength","assertPositiveInteger","getExactlyOneShape","getExactlyOneTensor","preprocessConv2DInput","preprocessConv3DInput","pool2d","x","poolSize","strides","padding","dataFormat","poolMode","y","paddingString","maxPool","avgPool","transpose","pool3d","maxPool3d","avgPool3d","Pooling1D","constructor","args","Array","isArray","length","JSON","stringify","inputSpec","ndim","computeOutputShape","inputShape","call","inputs","kwargs","invokeCallHook","expandDims","output","poolingFunction","squeeze","getConfig","config","baseConfig","Object","assign","MaxPooling1D","className","registerClass","AveragePooling1D","Pooling2D","rows","cols","MaxPooling2D","AveragePooling2D","Pooling3D","depths","MaxPooling3D","AveragePooling3D","GlobalPooling1D","GlobalAveragePooling1D","input","mean","GlobalMaxPooling1D","max","GlobalPooling2D","GlobalAveragePooling2D","GlobalMaxPooling2D"],"sources":["/Users/jonchen/Documents/HackPSU/tfjs-layers/src/layers/pooling.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\n/**\n * TensorFlow.js Layers: Pooling Layers.\n */\n\nimport * as tfc from '@tensorflow/tfjs-core';\nimport {serialization, Tensor, Tensor3D, Tensor4D, Tensor5D, tidy} from '@tensorflow/tfjs-core';\n\nimport {imageDataFormat} from '../backend/common';\nimport * as K from '../backend/tfjs_backend';\nimport {checkDataFormat, checkPaddingMode, checkPoolMode} from '../common';\nimport {InputSpec} from '../engine/topology';\nimport {Layer, LayerArgs} from '../engine/topology';\nimport {NotImplementedError, ValueError} from '../errors';\nimport {DataFormat, PaddingMode, PoolMode, Shape} from '../keras_format/common';\nimport {Kwargs} from '../types';\nimport {convOutputLength} from '../utils/conv_utils';\nimport {assertPositiveInteger} from '../utils/generic_utils';\nimport {getExactlyOneShape, getExactlyOneTensor} from '../utils/types_utils';\n\nimport {preprocessConv2DInput, preprocessConv3DInput} from './convolutional';\n\n/**\n * 2D pooling.\n * @param x\n * @param poolSize\n * @param strides strides. Defaults to [1, 1].\n * @param padding padding. Defaults to 'valid'.\n * @param dataFormat data format. Defaults to 'channelsLast'.\n * @param poolMode Mode of pooling. Defaults to 'max'.\n * @returns Result of the 2D pooling.\n */\nexport function pool2d(\n    x: Tensor, poolSize: [number, number], strides?: [number, number],\n    padding?: PaddingMode, dataFormat?: DataFormat,\n    poolMode?: PoolMode): Tensor {\n  return tidy(() => {\n    checkDataFormat(dataFormat);\n    checkPoolMode(poolMode);\n    checkPaddingMode(padding);\n    if (strides == null) {\n      strides = [1, 1];\n    }\n    if (padding == null) {\n      padding = 'valid';\n    }\n    if (dataFormat == null) {\n      dataFormat = imageDataFormat();\n    }\n    if (poolMode == null) {\n      poolMode = 'max';\n    }\n\n    // TODO(cais): Remove the preprocessing step once deeplearn.js supports\n    // dataFormat as an input argument.\n    x = preprocessConv2DInput(x, dataFormat);  // x is NHWC after preprocessing.\n    let y: Tensor;\n    const paddingString = (padding === 'same') ? 'same' : 'valid';\n    if (poolMode === 'max') {\n      // TODO(cais): Rank check?\n      y = tfc.maxPool(x as Tensor4D, poolSize, strides, paddingString);\n    } else {  // 'avg'\n      // TODO(cais): Check the dtype and rank of x and give clear error message\n      //   if those are incorrect.\n      y = tfc.avgPool(\n          // TODO(cais): Rank check?\n          x as Tensor3D | Tensor4D, poolSize, strides, paddingString);\n    }\n    if (dataFormat === 'channelsFirst') {\n      y = tfc.transpose(y, [0, 3, 1, 2]);  // NHWC -> NCHW.\n    }\n    return y;\n  });\n}\n\n/**\n * 3D pooling.\n * @param x\n * @param poolSize. Default to [1, 1, 1].\n * @param strides strides. Defaults to [1, 1, 1].\n * @param padding padding. Defaults to 'valid'.\n * @param dataFormat data format. Defaults to 'channelsLast'.\n * @param poolMode Mode of pooling. Defaults to 'max'.\n * @returns Result of the 3D pooling.\n */\nexport function pool3d(\n    x: Tensor5D, poolSize: [number, number, number],\n    strides?: [number, number, number], padding?: PaddingMode,\n    dataFormat?: DataFormat, poolMode?: PoolMode): Tensor {\n  return tidy(() => {\n    checkDataFormat(dataFormat);\n    checkPoolMode(poolMode);\n    checkPaddingMode(padding);\n    if (strides == null) {\n      strides = [1, 1, 1];\n    }\n    if (padding == null) {\n      padding = 'valid';\n    }\n    if (dataFormat == null) {\n      dataFormat = imageDataFormat();\n    }\n    if (poolMode == null) {\n      poolMode = 'max';\n    }\n\n    // x is NDHWC after preprocessing.\n    x = preprocessConv3DInput(x as Tensor, dataFormat) as Tensor5D;\n    let y: Tensor;\n    const paddingString = (padding === 'same') ? 'same' : 'valid';\n    if (poolMode === 'max') {\n      y = tfc.maxPool3d(x, poolSize, strides, paddingString);\n    } else {  // 'avg'\n      y = tfc.avgPool3d(x, poolSize, strides, paddingString);\n    }\n    if (dataFormat === 'channelsFirst') {\n      y = tfc.transpose(y, [0, 4, 1, 2, 3]);  // NDHWC -> NCDHW.\n    }\n    return y;\n  });\n}\n\nexport declare interface Pooling1DLayerArgs extends LayerArgs {\n  /**\n   * Size of the window to pool over, should be an integer.\n   */\n  poolSize?: number|[number];\n  /**\n   * Period at which to sample the pooled values.\n   *\n   * If `null`, defaults to `poolSize`.\n   */\n  strides?: number|[number];\n  /** How to fill in data that's not an integer multiple of poolSize. */\n  padding?: PaddingMode;\n}\n\n/**\n * Abstract class for different pooling 1D layers.\n */\nexport abstract class Pooling1D extends Layer {\n  protected readonly poolSize: [number];\n  protected readonly strides: [number];\n  protected readonly padding: PaddingMode;\n\n  /**\n   *\n   * @param args Parameters for the Pooling layer.\n   *\n   * config.poolSize defaults to 2.\n   */\n  constructor(args: Pooling1DLayerArgs) {\n    if (args.poolSize == null) {\n      args.poolSize = 2;\n    }\n    super(args);\n    if (typeof args.poolSize === 'number') {\n      this.poolSize = [args.poolSize];\n    } else if (\n        Array.isArray(args.poolSize) &&\n        (args.poolSize as number[]).length === 1 &&\n        typeof (args.poolSize as number[])[0] === 'number') {\n      this.poolSize = args.poolSize;\n    } else {\n      throw new ValueError(\n          `poolSize for 1D convolutional layer must be a number or an ` +\n          `Array of a single number, but received ` +\n          `${JSON.stringify(args.poolSize)}`);\n    }\n    assertPositiveInteger(this.poolSize, 'poolSize');\n    if (args.strides == null) {\n      this.strides = this.poolSize;\n    } else {\n      if (typeof args.strides === 'number') {\n        this.strides = [args.strides];\n      } else if (\n          Array.isArray(args.strides) &&\n          (args.strides as number[]).length === 1 &&\n          typeof (args.strides as number[])[0] === 'number') {\n        this.strides = args.strides;\n      } else {\n        throw new ValueError(\n            `strides for 1D convolutional layer must be a number or an ` +\n            `Array of a single number, but received ` +\n            `${JSON.stringify(args.strides)}`);\n      }\n    }\n    assertPositiveInteger(this.strides, 'strides');\n\n    this.padding = args.padding == null ? 'valid' : args.padding;\n    checkPaddingMode(this.padding);\n    this.inputSpec = [new InputSpec({ndim: 3})];\n  }\n\n  override computeOutputShape(inputShape: Shape|Shape[]): Shape|Shape[] {\n    inputShape = getExactlyOneShape(inputShape);\n    const length = convOutputLength(\n        inputShape[1], this.poolSize[0], this.padding, this.strides[0]);\n    return [inputShape[0], length, inputShape[2]];\n  }\n\n  protected abstract poolingFunction(\n      inputs: Tensor, poolSize: [number, number], strides: [number, number],\n      padding: PaddingMode, dataFormat: DataFormat): Tensor;\n\n  override call(inputs: Tensor|Tensor[], kwargs: Kwargs): Tensor|Tensor[] {\n    return tidy(() => {\n      this.invokeCallHook(inputs, kwargs);\n      // Add dummy last dimension.\n      inputs = K.expandDims(getExactlyOneTensor(inputs), 2);\n      const output = this.poolingFunction(\n          getExactlyOneTensor(inputs), [this.poolSize[0], 1],\n          [this.strides[0], 1], this.padding, 'channelsLast');\n      // Remove dummy last dimension.\n      return tfc.squeeze(output, [2]);\n    });\n  }\n\n  override getConfig(): serialization.ConfigDict {\n    const config = {\n      poolSize: this.poolSize,\n      padding: this.padding,\n      strides: this.strides,\n    };\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n}\n\nexport class MaxPooling1D extends Pooling1D {\n  /** @nocollapse */\n  static className = 'MaxPooling1D';\n  constructor(args: Pooling1DLayerArgs) {\n    super(args);\n  }\n\n  protected poolingFunction(\n      inputs: Tensor, poolSize: [number, number], strides: [number, number],\n      padding: PaddingMode, dataFormat: DataFormat): Tensor {\n    checkDataFormat(dataFormat);\n    checkPaddingMode(padding);\n    return pool2d(inputs, poolSize, strides, padding, dataFormat, 'max');\n  }\n}\nserialization.registerClass(MaxPooling1D);\n\nexport class AveragePooling1D extends Pooling1D {\n  /** @nocollapse */\n  static className = 'AveragePooling1D';\n  constructor(args: Pooling1DLayerArgs) {\n    super(args);\n  }\n\n  protected poolingFunction(\n      inputs: Tensor, poolSize: [number, number], strides: [number, number],\n      padding: PaddingMode, dataFormat: DataFormat): Tensor {\n    checkDataFormat(dataFormat);\n    checkPaddingMode(padding);\n    return pool2d(inputs, poolSize, strides, padding, dataFormat, 'avg');\n  }\n}\nserialization.registerClass(AveragePooling1D);\n\nexport declare interface Pooling2DLayerArgs extends LayerArgs {\n  /**\n   * Factors by which to downscale in each dimension [vertical, horizontal].\n   * Expects an integer or an array of 2 integers.\n   *\n   * For example, `[2, 2]` will halve the input in both spatial dimensions.\n   * If only one integer is specified, the same window length\n   * will be used for both dimensions.\n   */\n  poolSize?: number|[number, number];\n\n  /**\n   * The size of the stride in each dimension of the pooling window. Expects\n   * an integer or an array of 2 integers. Integer, tuple of 2 integers, or\n   * None.\n   *\n   * If `null`, defaults to `poolSize`.\n   */\n  strides?: number|[number, number];\n\n  /** The padding type to use for the pooling layer. */\n  padding?: PaddingMode;\n  /** The data format to use for the pooling layer. */\n  dataFormat?: DataFormat;\n}\n\n/**\n * Abstract class for different pooling 2D layers.\n */\nexport abstract class Pooling2D extends Layer {\n  protected readonly poolSize: [number, number];\n  protected readonly strides: [number, number];\n  protected readonly padding: PaddingMode;\n  protected readonly dataFormat: DataFormat;\n\n  constructor(args: Pooling2DLayerArgs) {\n    if (args.poolSize == null) {\n      args.poolSize = [2, 2];\n    }\n    super(args);\n    this.poolSize = Array.isArray(args.poolSize) ?\n        args.poolSize :\n        [args.poolSize, args.poolSize];\n    if (args.strides == null) {\n      this.strides = this.poolSize;\n    } else if (Array.isArray(args.strides)) {\n      if (args.strides.length !== 2) {\n        throw new ValueError(\n            `If the strides property of a 2D pooling layer is an Array, ` +\n            `it is expected to have a length of 2, but received length ` +\n            `${args.strides.length}.`);\n      }\n      this.strides = args.strides;\n    } else {\n      // `config.strides` is a number.\n      this.strides = [args.strides, args.strides];\n    }\n    assertPositiveInteger(this.poolSize, 'poolSize');\n    assertPositiveInteger(this.strides, 'strides');\n    this.padding = args.padding == null ? 'valid' : args.padding;\n    this.dataFormat =\n        args.dataFormat == null ? 'channelsLast' : args.dataFormat;\n    checkDataFormat(this.dataFormat);\n    checkPaddingMode(this.padding);\n\n    this.inputSpec = [new InputSpec({ndim: 4})];\n  }\n\n  override computeOutputShape(inputShape: Shape|Shape[]): Shape|Shape[] {\n    inputShape = getExactlyOneShape(inputShape);\n    let rows =\n        this.dataFormat === 'channelsFirst' ? inputShape[2] : inputShape[1];\n    let cols =\n        this.dataFormat === 'channelsFirst' ? inputShape[3] : inputShape[2];\n    rows =\n        convOutputLength(rows, this.poolSize[0], this.padding, this.strides[0]);\n    cols =\n        convOutputLength(cols, this.poolSize[1], this.padding, this.strides[1]);\n    if (this.dataFormat === 'channelsFirst') {\n      return [inputShape[0], inputShape[1], rows, cols];\n    } else {\n      return [inputShape[0], rows, cols, inputShape[3]];\n    }\n  }\n\n  protected abstract poolingFunction(\n      inputs: Tensor, poolSize: [number, number], strides: [number, number],\n      padding: PaddingMode, dataFormat: DataFormat): Tensor;\n\n  override call(inputs: Tensor|Tensor[], kwargs: Kwargs): Tensor|Tensor[] {\n    return tidy(() => {\n      this.invokeCallHook(inputs, kwargs);\n      return this.poolingFunction(\n          getExactlyOneTensor(inputs), this.poolSize, this.strides,\n          this.padding, this.dataFormat);\n    });\n  }\n\n  override getConfig(): serialization.ConfigDict {\n    const config = {\n      poolSize: this.poolSize,\n      padding: this.padding,\n      strides: this.strides,\n      dataFormat: this.dataFormat\n    };\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n}\n\nexport class MaxPooling2D extends Pooling2D {\n  /** @nocollapse */\n  static className = 'MaxPooling2D';\n  constructor(args: Pooling2DLayerArgs) {\n    super(args);\n  }\n\n  protected poolingFunction(\n      inputs: Tensor, poolSize: [number, number], strides: [number, number],\n      padding: PaddingMode, dataFormat: DataFormat): Tensor {\n    checkDataFormat(dataFormat);\n    checkPaddingMode(padding);\n    return pool2d(inputs, poolSize, strides, padding, dataFormat, 'max');\n  }\n}\nserialization.registerClass(MaxPooling2D);\n\nexport class AveragePooling2D extends Pooling2D {\n  /** @nocollapse */\n  static className = 'AveragePooling2D';\n  constructor(args: Pooling2DLayerArgs) {\n    super(args);\n  }\n\n  protected poolingFunction(\n      inputs: Tensor, poolSize: [number, number], strides: [number, number],\n      padding: PaddingMode, dataFormat: DataFormat): Tensor {\n    checkDataFormat(dataFormat);\n    checkPaddingMode(padding);\n    return pool2d(inputs, poolSize, strides, padding, dataFormat, 'avg');\n  }\n}\nserialization.registerClass(AveragePooling2D);\n\nexport declare interface Pooling3DLayerArgs extends LayerArgs {\n  /**\n   * Factors by which to downscale in each dimension [depth, height, width].\n   * Expects an integer or an array of 3 integers.\n   *\n   * For example, `[2, 2, 2]` will halve the input in three dimensions.\n   * If only one integer is specified, the same window length\n   * will be used for all dimensions.\n   */\n  poolSize?: number|[number, number, number];\n\n  /**\n   * The size of the stride in each dimension of the pooling window. Expects\n   * an integer or an array of 3 integers. Integer, tuple of 3 integers, or\n   * None.\n   *\n   * If `null`, defaults to `poolSize`.\n   */\n  strides?: number|[number, number, number];\n\n  /** The padding type to use for the pooling layer. */\n  padding?: PaddingMode;\n  /** The data format to use for the pooling layer. */\n  dataFormat?: DataFormat;\n}\n\n/**\n * Abstract class for different pooling 3D layers.\n */\nexport abstract class Pooling3D extends Layer {\n  protected readonly poolSize: [number, number, number];\n  protected readonly strides: [number, number, number];\n  protected readonly padding: PaddingMode;\n  protected readonly dataFormat: DataFormat;\n\n  constructor(args: Pooling3DLayerArgs) {\n    if (args.poolSize == null) {\n      args.poolSize = [2, 2, 2];\n    }\n    super(args);\n    this.poolSize = Array.isArray(args.poolSize) ?\n        args.poolSize :\n        [args.poolSize, args.poolSize, args.poolSize];\n    if (args.strides == null) {\n      this.strides = this.poolSize;\n    } else if (Array.isArray(args.strides)) {\n      if (args.strides.length !== 3) {\n        throw new ValueError(\n            `If the strides property of a 3D pooling layer is an Array, ` +\n            `it is expected to have a length of 3, but received length ` +\n            `${args.strides.length}.`);\n      }\n      this.strides = args.strides;\n    } else {\n      // `config.strides` is a number.\n      this.strides = [args.strides, args.strides, args.strides];\n    }\n    assertPositiveInteger(this.poolSize, 'poolSize');\n    assertPositiveInteger(this.strides, 'strides');\n    this.padding = args.padding == null ? 'valid' : args.padding;\n    this.dataFormat =\n        args.dataFormat == null ? 'channelsLast' : args.dataFormat;\n    checkDataFormat(this.dataFormat);\n    checkPaddingMode(this.padding);\n\n    this.inputSpec = [new InputSpec({ndim: 5})];\n  }\n\n  override computeOutputShape(inputShape: Shape|Shape[]): Shape|Shape[] {\n    inputShape = getExactlyOneShape(inputShape);\n    let depths =\n        this.dataFormat === 'channelsFirst' ? inputShape[2] : inputShape[1];\n    let rows =\n        this.dataFormat === 'channelsFirst' ? inputShape[3] : inputShape[2];\n    let cols =\n        this.dataFormat === 'channelsFirst' ? inputShape[4] : inputShape[3];\n    depths = convOutputLength(\n        depths, this.poolSize[0], this.padding, this.strides[0]);\n    rows =\n        convOutputLength(rows, this.poolSize[1], this.padding, this.strides[1]);\n    cols =\n        convOutputLength(cols, this.poolSize[2], this.padding, this.strides[2]);\n    if (this.dataFormat === 'channelsFirst') {\n      return [inputShape[0], inputShape[1], depths, rows, cols];\n    } else {\n      return [inputShape[0], depths, rows, cols, inputShape[4]];\n    }\n  }\n\n  protected abstract poolingFunction(\n      inputs: Tensor, poolSize: [number, number, number],\n      strides: [number, number, number], padding: PaddingMode,\n      dataFormat: DataFormat): Tensor;\n\n  override call(inputs: Tensor|Tensor[], kwargs: Kwargs): Tensor|Tensor[] {\n    return tidy(() => {\n      this.invokeCallHook(inputs, kwargs);\n      return this.poolingFunction(\n          getExactlyOneTensor(inputs), this.poolSize, this.strides,\n          this.padding, this.dataFormat);\n    });\n  }\n\n  override getConfig(): serialization.ConfigDict {\n    const config = {\n      poolSize: this.poolSize,\n      padding: this.padding,\n      strides: this.strides,\n      dataFormat: this.dataFormat\n    };\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n}\n\nexport class MaxPooling3D extends Pooling3D {\n  /** @nocollapse */\n  static className = 'MaxPooling3D';\n  constructor(args: Pooling3DLayerArgs) {\n    super(args);\n  }\n\n  protected poolingFunction(\n      inputs: Tensor, poolSize: [number, number, number],\n      strides: [number, number, number], padding: PaddingMode,\n      dataFormat: DataFormat): Tensor {\n    checkDataFormat(dataFormat);\n    checkPaddingMode(padding);\n    return pool3d(\n        inputs as Tensor5D, poolSize, strides, padding, dataFormat, 'max');\n  }\n}\nserialization.registerClass(MaxPooling3D);\n\nexport class AveragePooling3D extends Pooling3D {\n  /** @nocollapse */\n  static className = 'AveragePooling3D';\n  constructor(args: Pooling3DLayerArgs) {\n    super(args);\n  }\n\n  protected poolingFunction(\n      inputs: Tensor, poolSize: [number, number, number],\n      strides: [number, number, number], padding: PaddingMode,\n      dataFormat: DataFormat): Tensor {\n    checkDataFormat(dataFormat);\n    checkPaddingMode(padding);\n    return pool3d(\n        inputs as Tensor5D, poolSize, strides, padding, dataFormat, 'avg');\n  }\n}\nserialization.registerClass(AveragePooling3D);\n\n/**\n * Abstract class for different global pooling 1D layers.\n */\nexport abstract class GlobalPooling1D extends Layer {\n  constructor(args: LayerArgs) {\n    super(args);\n    this.inputSpec = [new InputSpec({ndim: 3})];\n  }\n\n  override computeOutputShape(inputShape: Shape): Shape {\n    return [inputShape[0], inputShape[2]];\n  }\n\n  override call(inputs: Tensor|Tensor[], kwargs: Kwargs): Tensor|Tensor[] {\n    throw new NotImplementedError();\n  }\n}\n\nexport class GlobalAveragePooling1D extends GlobalPooling1D {\n  /** @nocollapse */\n  static className = 'GlobalAveragePooling1D';\n  constructor(args?: LayerArgs) {\n    super(args || {});\n  }\n\n  override call(inputs: Tensor|Tensor[], kwargs: Kwargs): Tensor|Tensor[] {\n    return tidy(() => {\n      const input = getExactlyOneTensor(inputs);\n      return tfc.mean(input, 1);\n    });\n  }\n}\nserialization.registerClass(GlobalAveragePooling1D);\n\nexport class GlobalMaxPooling1D extends GlobalPooling1D {\n  /** @nocollapse */\n  static className = 'GlobalMaxPooling1D';\n  constructor(args: LayerArgs) {\n    super(args || {});\n  }\n\n  override call(inputs: Tensor|Tensor[], kwargs: Kwargs): Tensor|Tensor[] {\n    return tidy(() => {\n      const input = getExactlyOneTensor(inputs);\n      return tfc.max(input, 1);\n    });\n  }\n}\nserialization.registerClass(GlobalMaxPooling1D);\n\nexport declare interface GlobalPooling2DLayerArgs extends LayerArgs {\n  /**\n   * One of `CHANNEL_LAST` (default) or `CHANNEL_FIRST`.\n   *\n   * The ordering of the dimensions in the inputs. `CHANNEL_LAST` corresponds\n   * to inputs with shape `[batch, height, width, channels]` while\n   * `CHANNEL_FIRST` corresponds to inputs with shape\n   * `[batch, channels, height, width]`.\n   */\n  dataFormat?: DataFormat;\n}\n\n/**\n * Abstract class for different global pooling 2D layers.\n */\nexport abstract class GlobalPooling2D extends Layer {\n  protected dataFormat: DataFormat;\n  constructor(args: GlobalPooling2DLayerArgs) {\n    super(args);\n    this.dataFormat =\n        args.dataFormat == null ? 'channelsLast' : args.dataFormat;\n    checkDataFormat(this.dataFormat);\n    this.inputSpec = [new InputSpec({ndim: 4})];\n  }\n\n  override computeOutputShape(inputShape: Shape|Shape[]): Shape|Shape[] {\n    inputShape = inputShape as Shape;\n    if (this.dataFormat === 'channelsLast') {\n      return [inputShape[0], inputShape[3]];\n    } else {\n      return [inputShape[0], inputShape[1]];\n    }\n  }\n\n  override call(inputs: Tensor|Tensor[], kwargs: Kwargs): Tensor|Tensor[] {\n    throw new NotImplementedError();\n  }\n\n  override getConfig(): serialization.ConfigDict {\n    const config = {dataFormat: this.dataFormat};\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n}\n\nexport class GlobalAveragePooling2D extends GlobalPooling2D {\n  /** @nocollapse */\n  static className = 'GlobalAveragePooling2D';\n\n  override call(inputs: Tensor|Tensor[], kwargs: Kwargs): Tensor|Tensor[] {\n    return tidy(() => {\n      const input = getExactlyOneTensor(inputs);\n      if (this.dataFormat === 'channelsLast') {\n        return tfc.mean(input, [1, 2]);\n      } else {\n        return tfc.mean(input, [2, 3]);\n      }\n    });\n  }\n}\nserialization.registerClass(GlobalAveragePooling2D);\n\nexport class GlobalMaxPooling2D extends GlobalPooling2D {\n  /** @nocollapse */\n  static className = 'GlobalMaxPooling2D';\n\n  override call(inputs: Tensor|Tensor[], kwargs: Kwargs): Tensor|Tensor[] {\n    return tidy(() => {\n      const input = getExactlyOneTensor(inputs);\n      if (this.dataFormat === 'channelsLast') {\n        return tfc.max(input, [1, 2]);\n      } else {\n        return tfc.max(input, [2, 3]);\n      }\n    });\n  }\n}\nserialization.registerClass(GlobalMaxPooling2D);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}