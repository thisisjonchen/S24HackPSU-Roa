{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { BatchMatMul, broadcast_util, buffer, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nimport { reshape } from './Reshape';\nexport function batchMatMul(args) {\n  const {\n    inputs,\n    backend,\n    attrs\n  } = args;\n  const {\n    a,\n    b\n  } = inputs;\n  const {\n    transposeA,\n    transposeB\n  } = attrs;\n  assertNotComplex([a, b], 'matMul');\n  const aRank = a.shape.length;\n  const bRank = b.shape.length;\n  const innerShapeA = transposeA ? a.shape[aRank - 2] : a.shape[aRank - 1];\n  const innerShapeB = transposeB ? b.shape[bRank - 1] : b.shape[bRank - 2];\n  const outerShapeA = transposeA ? a.shape[aRank - 1] : a.shape[aRank - 2];\n  const outerShapeB = transposeB ? b.shape[bRank - 2] : b.shape[bRank - 1];\n  const outerDimsA = a.shape.slice(0, -2);\n  const outerDimsB = b.shape.slice(0, -2);\n  const batchDimA = util.sizeFromShape(outerDimsA);\n  const batchDimB = util.sizeFromShape(outerDimsB);\n  const outShapeOuterDims = broadcast_util.assertAndGetBroadcastShape(a.shape.slice(0, -2), b.shape.slice(0, -2));\n  const outShape = outShapeOuterDims.concat([outerShapeA, outerShapeB]);\n  util.assert(innerShapeA === innerShapeB, () => `Error in matMul: inner shapes (${innerShapeA}) and (` + `${innerShapeB}) of Tensors with shapes ${a.shape} and ` + `${b.shape} and transposeA=${transposeA}` + ` and transposeB=${transposeB} must match.`);\n  const a3dShape = transposeA ? [batchDimA, innerShapeA, outerShapeA] : [batchDimA, outerShapeA, innerShapeA];\n  const b3dShape = transposeB ? [batchDimB, outerShapeB, innerShapeB] : [batchDimB, innerShapeB, outerShapeB];\n  // The rest of the implementation is designed to operate on rank-3 tensors\n  const a3d = reshape({\n    inputs: {\n      x: a\n    },\n    backend,\n    attrs: {\n      shape: a3dShape\n    }\n  });\n  const b3d = reshape({\n    inputs: {\n      x: b\n    },\n    backend,\n    attrs: {\n      shape: b3dShape\n    }\n  });\n  const sharedDim = transposeA ? a3d.shape[1] : a3d.shape[2];\n  const leftDim = transposeA ? a3d.shape[2] : a3d.shape[1];\n  const rightDim = transposeB ? b3d.shape[1] : b3d.shape[2];\n  const batchDim = Math.max(batchDimA, batchDimB);\n  const a3dValues = backend.data.get(a3d.dataId).values;\n  const b3dValues = backend.data.get(b3d.dataId).values;\n  const a3dStrides = util.computeStrides(a3d.shape);\n  const b3dStrides = util.computeStrides(b3d.shape);\n  const [aBatch, aOuterStep, aInnerStep] = transposeA ? [a3dStrides[0], 1, a3dStrides[1]] : [a3dStrides[0], a3dStrides[1], 1];\n  const [bInnerStep, bOuterStep, bBatch] = transposeB ? [1, b3dStrides[1], b3dStrides[0]] : [b3dStrides[1], 1, b3dStrides[0]];\n  const size = leftDim * rightDim;\n  const result = buffer([batchDim, leftDim, rightDim], a3d.dtype);\n  const resVals = result.values;\n  const blockSize = backend.blockSize;\n  for (let bi = 0; bi < batchDim; bi++) {\n    const batchIndexA = bi % batchDimA;\n    const batchIndexB = bi % batchDimB;\n    for (let i0 = 0; i0 < leftDim; i0 += blockSize) {\n      // for when blockSize doesn't evenly divide the input\n      const iBlock = Math.min(i0 + blockSize, leftDim);\n      for (let j0 = 0; j0 < rightDim; j0 += blockSize) {\n        const jBlock = Math.min(j0 + blockSize, rightDim);\n        for (let k0 = 0; k0 < sharedDim; k0 += blockSize) {\n          const kBlock = Math.min(k0 + blockSize, sharedDim);\n          for (let i = i0; i < iBlock; i++) {\n            for (let j = j0; j < jBlock; j++) {\n              let sum = 0.0;\n              for (let k = k0; k < kBlock; k++) {\n                const aVal =\n                // tslint:disable-next-line: max-line-length\n                a3dValues[batchIndexA * aBatch + i * aOuterStep + k * aInnerStep];\n                const bVal =\n                // tslint:disable-next-line: max-line-length\n                b3dValues[k * bInnerStep + j * bOuterStep + batchIndexB * bBatch];\n                sum += aVal * bVal;\n              }\n              resVals[bi * size + (i * rightDim + j)] += sum;\n            }\n          }\n        }\n      }\n    }\n  }\n  backend.disposeIntermediateTensorInfo(a3d);\n  backend.disposeIntermediateTensorInfo(b3d);\n  // set correct shape on output.\n  return backend.makeTensorInfo(outShape, result.dtype, result.values);\n}\nexport const batchMatMulConfig = {\n  kernelName: BatchMatMul,\n  backendName: 'cpu',\n  kernelFunc: batchMatMul\n};","map":{"version":3,"names":["BatchMatMul","broadcast_util","buffer","util","assertNotComplex","reshape","batchMatMul","args","inputs","backend","attrs","a","b","transposeA","transposeB","aRank","shape","length","bRank","innerShapeA","innerShapeB","outerShapeA","outerShapeB","outerDimsA","slice","outerDimsB","batchDimA","sizeFromShape","batchDimB","outShapeOuterDims","assertAndGetBroadcastShape","outShape","concat","assert","a3dShape","b3dShape","a3d","x","b3d","sharedDim","leftDim","rightDim","batchDim","Math","max","a3dValues","data","get","dataId","values","b3dValues","a3dStrides","computeStrides","b3dStrides","aBatch","aOuterStep","aInnerStep","bInnerStep","bOuterStep","bBatch","size","result","dtype","resVals","blockSize","bi","batchIndexA","batchIndexB","i0","iBlock","min","j0","jBlock","k0","kBlock","i","j","sum","k","aVal","bVal","disposeIntermediateTensorInfo","makeTensorInfo","batchMatMulConfig","kernelName","backendName","kernelFunc"],"sources":["/Users/jonchen/Documents/HackPSU/tfjs-backend-cpu/src/kernels/BatchMatMul.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {BatchMatMul, BatchMatMulAttrs, BatchMatMulInputs, broadcast_util, buffer, KernelConfig, KernelFunc, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendCPU} from '../backend_cpu';\nimport {assertNotComplex} from '../cpu_util';\n\nimport {reshape} from './Reshape';\n\nexport function batchMatMul(args: {\n  inputs: BatchMatMulInputs,\n  attrs: BatchMatMulAttrs,\n  backend: MathBackendCPU\n}) {\n  const {inputs, backend, attrs} = args;\n  const {a, b} = inputs;\n  const {transposeA, transposeB} = attrs;\n\n  assertNotComplex([a, b], 'matMul');\n\n  const aRank = a.shape.length;\n  const bRank = b.shape.length;\n\n  const innerShapeA = transposeA ? a.shape[aRank - 2] : a.shape[aRank - 1];\n  const innerShapeB = transposeB ? b.shape[bRank - 1] : b.shape[bRank - 2];\n\n  const outerShapeA = transposeA ? a.shape[aRank - 1] : a.shape[aRank - 2];\n  const outerShapeB = transposeB ? b.shape[bRank - 2] : b.shape[bRank - 1];\n\n  const outerDimsA = a.shape.slice(0, -2);\n  const outerDimsB = b.shape.slice(0, -2);\n\n  const batchDimA = util.sizeFromShape(outerDimsA);\n  const batchDimB = util.sizeFromShape(outerDimsB);\n\n  const outShapeOuterDims = broadcast_util.assertAndGetBroadcastShape(\n      a.shape.slice(0, -2), b.shape.slice(0, -2));\n  const outShape = outShapeOuterDims.concat([outerShapeA, outerShapeB]);\n\n  util.assert(\n      innerShapeA === innerShapeB,\n      () => `Error in matMul: inner shapes (${innerShapeA}) and (` +\n          `${innerShapeB}) of Tensors with shapes ${a.shape} and ` +\n          `${b.shape} and transposeA=${transposeA}` +\n          ` and transposeB=${transposeB} must match.`);\n\n  const a3dShape = transposeA ? [batchDimA, innerShapeA, outerShapeA] :\n                                [batchDimA, outerShapeA, innerShapeA];\n  const b3dShape = transposeB ? [batchDimB, outerShapeB, innerShapeB] :\n                                [batchDimB, innerShapeB, outerShapeB];\n\n  // The rest of the implementation is designed to operate on rank-3 tensors\n  const a3d = reshape({inputs: {x: a}, backend, attrs: {shape: a3dShape}});\n  const b3d = reshape({inputs: {x: b}, backend, attrs: {shape: b3dShape}});\n\n  const sharedDim = transposeA ? a3d.shape[1] : a3d.shape[2];\n  const leftDim = transposeA ? a3d.shape[2] : a3d.shape[1];\n  const rightDim = transposeB ? b3d.shape[1] : b3d.shape[2];\n  const batchDim = Math.max(batchDimA, batchDimB);\n\n  const a3dValues = backend.data.get(a3d.dataId).values as TypedArray;\n  const b3dValues = backend.data.get(b3d.dataId).values as TypedArray;\n\n  const a3dStrides = util.computeStrides(a3d.shape);\n  const b3dStrides = util.computeStrides(b3d.shape);\n\n  const [aBatch, aOuterStep, aInnerStep] = transposeA ?\n      [a3dStrides[0], 1, a3dStrides[1]] :\n      [a3dStrides[0], a3dStrides[1], 1];\n  const [bInnerStep, bOuterStep, bBatch] = transposeB ?\n      [1, b3dStrides[1], b3dStrides[0]] :\n      [b3dStrides[1], 1, b3dStrides[0]];\n\n  const size = leftDim * rightDim;\n  const result = buffer([batchDim, leftDim, rightDim], a3d.dtype);\n\n  const resVals = result.values as TypedArray;\n  const blockSize = backend.blockSize;\n\n  for (let bi = 0; bi < batchDim; bi++) {\n    const batchIndexA = bi % batchDimA;\n    const batchIndexB = bi % batchDimB;\n    for (let i0 = 0; i0 < leftDim; i0 += blockSize) {\n      // for when blockSize doesn't evenly divide the input\n      const iBlock = Math.min(i0 + blockSize, leftDim);\n      for (let j0 = 0; j0 < rightDim; j0 += blockSize) {\n        const jBlock = Math.min(j0 + blockSize, rightDim);\n        for (let k0 = 0; k0 < sharedDim; k0 += blockSize) {\n          const kBlock = Math.min(k0 + blockSize, sharedDim);\n\n          for (let i = i0; i < iBlock; i++) {\n            for (let j = j0; j < jBlock; j++) {\n              let sum = 0.0;\n\n              for (let k = k0; k < kBlock; k++) {\n                const aVal =\n                    // tslint:disable-next-line: max-line-length\n                    a3dValues[batchIndexA * aBatch + i * aOuterStep + k * aInnerStep];\n                const bVal =\n                    // tslint:disable-next-line: max-line-length\n                    b3dValues[k * bInnerStep + j * bOuterStep + batchIndexB * bBatch];\n                sum += aVal * bVal;\n              }\n              resVals[bi * size + (i * rightDim + j)] += sum;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  backend.disposeIntermediateTensorInfo(a3d);\n  backend.disposeIntermediateTensorInfo(b3d);\n\n  // set correct shape on output.\n  return backend.makeTensorInfo(\n      outShape, result.dtype, result.values as TypedArray);\n}\n\nexport const batchMatMulConfig: KernelConfig = {\n  kernelName: BatchMatMul,\n  backendName: 'cpu',\n  kernelFunc: batchMatMul as unknown as KernelFunc,\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}