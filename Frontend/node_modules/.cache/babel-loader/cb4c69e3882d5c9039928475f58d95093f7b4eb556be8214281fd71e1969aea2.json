{"ast":null,"code":"/**\n * @license\n * Copyright 2022 CodeSmith LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nimport { denseBincount, mul } from '@tensorflow/tfjs-core';\nimport { getExactlyOneTensor } from '../../utils/types_utils';\nimport { expandDims } from '@tensorflow/tfjs-core';\nimport { ValueError } from '../../errors';\nimport * as K from '../../backend/tfjs_backend';\nexport function encodeCategoricalInputs(inputs, outputMode, depth, weights) {\n  let input = getExactlyOneTensor(inputs);\n  if (input.dtype !== 'int32') {\n    input = K.cast(input, 'int32');\n  }\n  if (outputMode === 'int') {\n    return input;\n  }\n  const originalShape = input.shape;\n  if (input.rank === 0) {\n    input = expandDims(input, -1);\n  }\n  if (outputMode === 'oneHot') {\n    if (input.shape[input.shape.length - 1] !== 1) {\n      input = expandDims(input, -1);\n    }\n  }\n  if (input.rank > 2) {\n    throw new ValueError(`When outputMode is not int, maximum output rank is 2` + ` Received outputMode ${outputMode} and input shape ${originalShape}` + ` which would result in output rank ${input.rank}.`);\n  }\n  const binaryOutput = ['multiHot', 'oneHot'].includes(outputMode);\n  const denseBincountInput = input;\n  let binCounts;\n  if (typeof weights !== 'undefined' && outputMode === 'count') {\n    binCounts = denseBincount(denseBincountInput, weights, depth, binaryOutput);\n  } else {\n    binCounts = denseBincount(denseBincountInput, [], depth, binaryOutput);\n  }\n  if (outputMode !== 'tfIdf') {\n    return binCounts;\n  }\n  if (weights) {\n    return mul(binCounts, weights);\n  } else {\n    throw new ValueError(`When outputMode is 'tfIdf', weights must be provided.`);\n  }\n}","map":{"version":3,"names":["denseBincount","mul","getExactlyOneTensor","expandDims","ValueError","K","encodeCategoricalInputs","inputs","outputMode","depth","weights","input","dtype","cast","originalShape","shape","rank","length","binaryOutput","includes","denseBincountInput","binCounts"],"sources":["/Users/jonchen/Documents/HackPSU/tfjs-layers/src/layers/preprocessing/preprocessing_utils.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2022 CodeSmith LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\nimport { Tensor, denseBincount, Tensor1D, Tensor2D, TensorLike, mul} from '@tensorflow/tfjs-core';\nimport { getExactlyOneTensor } from '../../utils/types_utils';\nimport { expandDims} from '@tensorflow/tfjs-core';\nimport { ValueError } from '../../errors';\nimport * as K from '../../backend/tfjs_backend';\n\nexport type OutputMode = 'int' | 'oneHot' | 'multiHot' | 'count' | 'tfIdf';\n\nexport function encodeCategoricalInputs(inputs: Tensor|Tensor[],\n                                        outputMode: OutputMode,\n                                        depth: number,\n                                        weights?: Tensor1D|Tensor2D|TensorLike):\n                                        Tensor|Tensor[] {\n\n  let input = getExactlyOneTensor(inputs);\n\n  if(input.dtype !== 'int32') {\n    input = K.cast(input, 'int32');\n    }\n\n  if(outputMode === 'int') {\n    return input;\n  }\n\n  const originalShape = input.shape;\n\n  if(input.rank === 0) {\n    input = expandDims(input, -1);\n  }\n\n  if(outputMode === 'oneHot') {\n    if(input.shape[input.shape.length - 1] !== 1) {\n      input = expandDims(input, -1);\n    }\n  }\n\n  if(input.rank > 2) {\n    throw new ValueError(`When outputMode is not int, maximum output rank is 2`\n    + ` Received outputMode ${outputMode} and input shape ${originalShape}`\n    + ` which would result in output rank ${input.rank}.`);\n  }\n\n  const binaryOutput = ['multiHot', 'oneHot'].includes(outputMode);\n\n  const denseBincountInput = input as Tensor1D | Tensor2D;\n\n  let binCounts: Tensor1D | Tensor2D;\n\n  if ((typeof weights) !== 'undefined' && outputMode === 'count') {\n    binCounts = denseBincount(denseBincountInput, weights, depth, binaryOutput);\n   } else {\n    binCounts = denseBincount(denseBincountInput, [], depth, binaryOutput);\n   }\n\n  if(outputMode !== 'tfIdf') {\n    return binCounts;\n  }\n\n  if (weights) {\n    return mul(binCounts, weights);\n  } else {\n      throw new ValueError(\n        `When outputMode is 'tfIdf', weights must be provided.`\n      );\n  }\n}\n"],"mappings":"AAAA;;;;;;;;;AAUA,SAAiBA,aAAa,EAAkCC,GAAG,QAAO,uBAAuB;AACjG,SAASC,mBAAmB,QAAQ,yBAAyB;AAC7D,SAASC,UAAU,QAAO,uBAAuB;AACjD,SAASC,UAAU,QAAQ,cAAc;AACzC,OAAO,KAAKC,CAAC,MAAM,4BAA4B;AAI/C,OAAM,SAAUC,uBAAuBA,CAACC,MAAuB,EACvBC,UAAsB,EACtBC,KAAa,EACbC,OAAsC;EAG5E,IAAIC,KAAK,GAAGT,mBAAmB,CAACK,MAAM,CAAC;EAEvC,IAAGI,KAAK,CAACC,KAAK,KAAK,OAAO,EAAE;IAC1BD,KAAK,GAAGN,CAAC,CAACQ,IAAI,CAACF,KAAK,EAAE,OAAO,CAAC;;EAGhC,IAAGH,UAAU,KAAK,KAAK,EAAE;IACvB,OAAOG,KAAK;;EAGd,MAAMG,aAAa,GAAGH,KAAK,CAACI,KAAK;EAEjC,IAAGJ,KAAK,CAACK,IAAI,KAAK,CAAC,EAAE;IACnBL,KAAK,GAAGR,UAAU,CAACQ,KAAK,EAAE,CAAC,CAAC,CAAC;;EAG/B,IAAGH,UAAU,KAAK,QAAQ,EAAE;IAC1B,IAAGG,KAAK,CAACI,KAAK,CAACJ,KAAK,CAACI,KAAK,CAACE,MAAM,GAAG,CAAC,CAAC,KAAK,CAAC,EAAE;MAC5CN,KAAK,GAAGR,UAAU,CAACQ,KAAK,EAAE,CAAC,CAAC,CAAC;;;EAIjC,IAAGA,KAAK,CAACK,IAAI,GAAG,CAAC,EAAE;IACjB,MAAM,IAAIZ,UAAU,CAAC,sDAAsD,GACzE,wBAAwBI,UAAU,oBAAoBM,aAAa,EAAE,GACrE,sCAAsCH,KAAK,CAACK,IAAI,GAAG,CAAC;;EAGxD,MAAME,YAAY,GAAG,CAAC,UAAU,EAAE,QAAQ,CAAC,CAACC,QAAQ,CAACX,UAAU,CAAC;EAEhE,MAAMY,kBAAkB,GAAGT,KAA4B;EAEvD,IAAIU,SAA8B;EAElC,IAAK,OAAOX,OAAO,KAAM,WAAW,IAAIF,UAAU,KAAK,OAAO,EAAE;IAC9Da,SAAS,GAAGrB,aAAa,CAACoB,kBAAkB,EAAEV,OAAO,EAAED,KAAK,EAAES,YAAY,CAAC;GAC3E,MAAM;IACNG,SAAS,GAAGrB,aAAa,CAACoB,kBAAkB,EAAE,EAAE,EAAEX,KAAK,EAAES,YAAY,CAAC;;EAGxE,IAAGV,UAAU,KAAK,OAAO,EAAE;IACzB,OAAOa,SAAS;;EAGlB,IAAIX,OAAO,EAAE;IACX,OAAOT,GAAG,CAACoB,SAAS,EAAEX,OAAO,CAAC;GAC/B,MAAM;IACH,MAAM,IAAIN,UAAU,CAClB,uDAAuD,CACxD;;AAEP","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}