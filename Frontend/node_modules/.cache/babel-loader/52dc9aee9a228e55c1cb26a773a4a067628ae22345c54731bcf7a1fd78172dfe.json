{"ast":null,"code":"/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env, util } from '@tensorflow/tfjs-core';\nimport { getWebGLContext, setWebGLContext } from './canvas_util';\nimport * as gpgpu_util from './gpgpu_util';\nimport * as tex_util from './tex_util';\nimport * as webgl_util from './webgl_util';\nexport class GPGPUContext {\n  constructor(gl) {\n    this.outputTexture = null;\n    this.program = null;\n    this.disposed = false;\n    this.itemsToPoll = [];\n    const glVersion = env().getNumber('WEBGL_VERSION');\n    if (gl != null) {\n      this.gl = gl;\n      setWebGLContext(glVersion, gl);\n    } else {\n      this.gl = getWebGLContext(glVersion);\n    }\n    gl = this.gl;\n    if (env().getNumber('WEBGL_VERSION') === 2) {\n      const gl2 = gl;\n      this.createVertexArray = () => {\n        return webgl_util.callAndCheck(gl2, () => gl2.createVertexArray());\n      };\n      this.bindVertexArray = vao => {\n        return webgl_util.callAndCheck(gl2, () => gl2.bindVertexArray(vao));\n      };\n      this.deleteVertexArray = vao => {\n        return webgl_util.callAndCheck(gl2, () => gl2.deleteVertexArray(vao));\n      };\n      this.getVertexArray = () => {\n        return webgl_util.callAndCheck(gl2, () => gl2.getParameter(gl2.VERTEX_ARRAY_BINDING));\n      };\n    } else if (gl != null) {\n      const ext = gl.getExtension('OES_vertex_array_object');\n      if (ext == null) {\n        throw new Error('All WebGL1 implementations are expected to offer' + ' OES_vertex_array_object.');\n      }\n      this.createVertexArray = () => {\n        return webgl_util.callAndCheck(gl, () => ext.createVertexArrayOES());\n      };\n      this.bindVertexArray = vao => {\n        return webgl_util.callAndCheck(gl, () => ext.bindVertexArrayOES(vao));\n      };\n      this.deleteVertexArray = vao => {\n        return webgl_util.callAndCheck(gl, () => ext.deleteVertexArrayOES(vao));\n      };\n      this.getVertexArray = () => {\n        return webgl_util.callAndCheck(gl, () => gl.getParameter(ext.VERTEX_ARRAY_BINDING_OES));\n      };\n    }\n    // WebGL 2.0 enables texture floats without an extension.\n    let COLOR_BUFFER_FLOAT = 'WEBGL_color_buffer_float';\n    const COLOR_BUFFER_HALF_FLOAT = 'EXT_color_buffer_half_float';\n    this.parallelCompilationExtension = this.gl.getExtension('KHR_parallel_shader_compile');\n    if (env().getNumber('WEBGL_VERSION') === 1) {\n      const TEXTURE_FLOAT = 'OES_texture_float';\n      const TEXTURE_HALF_FLOAT = 'OES_texture_half_float';\n      this.textureFloatExtension = webgl_util.getExtensionOrThrow(this.gl, TEXTURE_FLOAT);\n      if (webgl_util.hasExtension(this.gl, TEXTURE_HALF_FLOAT)) {\n        this.textureHalfFloatExtension = webgl_util.getExtensionOrThrow(this.gl, TEXTURE_HALF_FLOAT);\n      } else if (env().get('WEBGL_FORCE_F16_TEXTURES')) {\n        throw new Error('GL context does not support half float textures, yet the ' + 'environment flag WEBGL_FORCE_F16_TEXTURES is set to true.');\n      }\n      this.colorBufferFloatExtension = this.gl.getExtension(COLOR_BUFFER_FLOAT);\n      if (webgl_util.hasExtension(this.gl, COLOR_BUFFER_HALF_FLOAT)) {\n        this.colorBufferHalfFloatExtension = webgl_util.getExtensionOrThrow(this.gl, COLOR_BUFFER_HALF_FLOAT);\n      } else if (env().get('WEBGL_FORCE_F16_TEXTURES')) {\n        throw new Error('GL context does not support color renderable half floats, yet ' + 'the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.');\n      }\n    } else {\n      COLOR_BUFFER_FLOAT = 'EXT_color_buffer_float';\n      if (webgl_util.hasExtension(this.gl, COLOR_BUFFER_FLOAT)) {\n        this.colorBufferFloatExtension = this.gl.getExtension(COLOR_BUFFER_FLOAT);\n      } else if (webgl_util.hasExtension(this.gl, COLOR_BUFFER_HALF_FLOAT)) {\n        this.colorBufferHalfFloatExtension = this.gl.getExtension(COLOR_BUFFER_HALF_FLOAT);\n      } else {\n        throw new Error('GL context does not support color renderable floats');\n      }\n    }\n    this.vertexBuffer = gpgpu_util.createVertexBuffer(this.gl);\n    this.indexBuffer = gpgpu_util.createIndexBuffer(this.gl);\n    this.framebuffer = webgl_util.createFramebuffer(this.gl);\n    this.textureConfig = tex_util.getTextureConfig(this.gl, this.textureHalfFloatExtension);\n  }\n  get debug() {\n    return env().getBool('DEBUG');\n  }\n  dispose() {\n    if (this.disposed) {\n      return;\n    }\n    if (this.program != null) {\n      console.warn('Disposing a GPGPUContext that still has a bound WebGLProgram.' + ' This is probably a resource leak, delete the program with ' + 'GPGPUContext.deleteProgram before disposing.');\n    }\n    if (this.outputTexture != null) {\n      console.warn('Disposing a GPGPUContext that still has a bound output matrix ' + 'texture.  This is probably a resource leak, delete the output ' + 'matrix texture with GPGPUContext.deleteMatrixTexture before ' + 'disposing.');\n    }\n    const gl = this.gl;\n    webgl_util.callAndCheck(gl, () => gl.finish());\n    webgl_util.callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, null));\n    webgl_util.callAndCheck(gl, () => gl.deleteFramebuffer(this.framebuffer));\n    webgl_util.callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, null));\n    webgl_util.callAndCheck(gl, () => gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null));\n    webgl_util.callAndCheck(gl, () => gl.deleteBuffer(this.indexBuffer));\n    this.disposed = true;\n  }\n  createFloat32MatrixTexture(rows, columns) {\n    this.throwIfDisposed();\n    return gpgpu_util.createFloat32MatrixTexture(this.gl, rows, columns, this.textureConfig);\n  }\n  createFloat16MatrixTexture(rows, columns) {\n    this.throwIfDisposed();\n    return gpgpu_util.createFloat16MatrixTexture(this.gl, rows, columns, this.textureConfig);\n  }\n  createUnsignedBytesMatrixTexture(rows, columns) {\n    this.throwIfDisposed();\n    return gpgpu_util.createUnsignedBytesMatrixTexture(this.gl, rows, columns, this.textureConfig);\n  }\n  uploadPixelDataToTexture(texture, pixels) {\n    this.throwIfDisposed();\n    gpgpu_util.uploadPixelDataToTexture(this.gl, texture, pixels);\n  }\n  uploadDenseMatrixToTexture(texture, width, height, data) {\n    this.throwIfDisposed();\n    gpgpu_util.uploadDenseMatrixToTexture(this.gl, texture, width, height, data, this.textureConfig);\n  }\n  createFloat16PackedMatrixTexture(rows, columns) {\n    this.throwIfDisposed();\n    return gpgpu_util.createFloat16PackedMatrixTexture(this.gl, rows, columns, this.textureConfig);\n  }\n  createPackedMatrixTexture(rows, columns) {\n    this.throwIfDisposed();\n    return gpgpu_util.createPackedMatrixTexture(this.gl, rows, columns, this.textureConfig);\n  }\n  deleteMatrixTexture(texture) {\n    this.throwIfDisposed();\n    if (this.outputTexture === texture) {\n      webgl_util.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);\n      this.outputTexture = null;\n    }\n    webgl_util.callAndCheck(this.gl, () => this.gl.deleteTexture(texture));\n  }\n  downloadByteEncodedFloatMatrixFromOutputTexture(texture, rows, columns) {\n    return this.downloadMatrixDriver(texture, () => gpgpu_util.downloadByteEncodedFloatMatrixFromOutputTexture(this.gl, rows, columns, this.textureConfig));\n  }\n  downloadPackedMatrixFromBuffer(buffer, batch, rows, columns, physicalRows, physicalCols) {\n    return gpgpu_util.downloadPackedMatrixFromBuffer(this.gl, buffer, batch, rows, columns, physicalRows, physicalCols, this.textureConfig);\n  }\n  downloadFloat32MatrixFromBuffer(buffer, size) {\n    return gpgpu_util.downloadFloat32MatrixFromBuffer(this.gl, buffer, size);\n  }\n  createBufferFromTexture(texture, rows, columns) {\n    this.bindTextureToFrameBuffer(texture);\n    const result = gpgpu_util.createBufferFromOutputTexture(this.gl, rows, columns, this.textureConfig);\n    this.unbindTextureToFrameBuffer();\n    return result;\n  }\n  createAndWaitForFence() {\n    const fenceContext = this.createFence(this.gl);\n    return this.pollFence(fenceContext);\n  }\n  createFence(gl) {\n    let query;\n    let isFencePassed;\n    if (env().getBool('WEBGL_FENCE_API_ENABLED')) {\n      const gl2 = gl;\n      const sync = gl2.fenceSync(gl2.SYNC_GPU_COMMANDS_COMPLETE, 0);\n      gl.flush();\n      isFencePassed = () => {\n        const status = gl2.clientWaitSync(sync, 0, 0);\n        return status === gl2.ALREADY_SIGNALED || status === gl2.CONDITION_SATISFIED;\n      };\n      query = sync;\n    } else if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') > 0) {\n      query = this.beginQuery();\n      this.endQuery();\n      isFencePassed = () => this.isQueryAvailable(query, env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION'));\n    } else {\n      // If we have no way to fence, return true immediately. This will fire in\n      // WebGL 1.0 when there is no disjoint query timer. In this case, because\n      // the fence passes immediately, we'll immediately ask for a download of\n      // the texture, which will cause the UI thread to hang.\n      isFencePassed = () => true;\n    }\n    return {\n      query,\n      isFencePassed\n    };\n  }\n  downloadMatrixFromPackedTexture(texture, physicalRows, physicalCols) {\n    return this.downloadMatrixDriver(texture, () => gpgpu_util.downloadMatrixFromPackedOutputTexture(this.gl, physicalRows, physicalCols));\n  }\n  createProgram(fragmentShader) {\n    this.throwIfDisposed();\n    const gl = this.gl;\n    if (this.vertexShader == null) {\n      this.vertexShader = gpgpu_util.createVertexShader(gl);\n    }\n    const program = webgl_util.createProgram(gl);\n    webgl_util.callAndCheck(gl, () => gl.attachShader(program, this.vertexShader));\n    webgl_util.callAndCheck(gl, () => gl.attachShader(program, fragmentShader));\n    webgl_util.linkProgram(gl, program);\n    const program2 = Object.assign(program, {\n      vao: this.createVertexArray()\n    });\n    if (this.debug) {\n      webgl_util.validateProgram(gl, program2);\n    }\n    return program2;\n  }\n  buildVao(program) {\n    this.setProgram(program);\n    this.bindVertexArray(program.vao);\n    const gl = this.gl;\n    // Bind index buffer, and vertex buffers based on program attrib\n    // locations.\n    webgl_util.callAndCheck(gl, () => gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer));\n    gpgpu_util.bindVertexProgramAttributeStreams(gl, program, this.vertexBuffer);\n  }\n  deleteProgram(program) {\n    this.throwIfDisposed();\n    if (program === this.program) {\n      this.program = null;\n    }\n    if (program != null) {\n      webgl_util.callAndCheck(this.gl, () => this.gl.deleteProgram(program));\n      this.deleteVertexArray(program.vao);\n    }\n  }\n  setProgram(program) {\n    this.throwIfDisposed();\n    this.program = program;\n    if (this.program != null) {\n      if (this.debug) {\n        webgl_util.validateProgram(this.gl, this.program);\n      }\n    }\n    webgl_util.callAndCheck(this.gl, () => this.gl.useProgram(program));\n  }\n  getUniformLocation(program, uniformName, shouldThrow = true) {\n    this.throwIfDisposed();\n    if (shouldThrow) {\n      return webgl_util.getProgramUniformLocationOrThrow(this.gl, program, uniformName);\n    } else {\n      return webgl_util.getProgramUniformLocation(this.gl, program, uniformName);\n    }\n  }\n  getAttributeLocation(program, attribute) {\n    this.throwIfDisposed();\n    return webgl_util.callAndCheck(this.gl, () => this.gl.getAttribLocation(program, attribute));\n  }\n  getUniformLocationNoThrow(program, uniformName) {\n    this.throwIfDisposed();\n    return this.gl.getUniformLocation(program, uniformName);\n  }\n  setInputMatrixTexture(inputMatrixTexture, uniformLocation, textureUnit) {\n    this.throwIfDisposed();\n    this.throwIfNoProgram();\n    webgl_util.bindTextureToProgramUniformSampler(this.gl, inputMatrixTexture, uniformLocation, textureUnit);\n  }\n  setOutputMatrixTexture(outputMatrixTexture, rows, columns) {\n    this.setOutputMatrixTextureDriver(outputMatrixTexture, columns, rows);\n  }\n  setOutputPackedMatrixTexture(outputPackedMatrixTexture, rows, columns) {\n    this.throwIfDisposed();\n    const [width, height] = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns);\n    this.setOutputMatrixTextureDriver(outputPackedMatrixTexture, width, height);\n  }\n  setOutputMatrixWriteRegion(startRow, numRows, startColumn, numColumns) {\n    this.setOutputMatrixWriteRegionDriver(startColumn, startRow, numColumns, numRows);\n  }\n  setOutputPackedMatrixWriteRegion(startRow, numRows, startColumn, numColumns) {\n    throw new Error('setOutputPackedMatrixWriteRegion not implemented.');\n  }\n  debugValidate() {\n    if (this.program != null) {\n      webgl_util.validateProgram(this.gl, this.program);\n    }\n    webgl_util.validateFramebuffer(this.gl);\n  }\n  executeProgram() {\n    this.throwIfDisposed();\n    this.throwIfNoProgram();\n    const gl = this.gl;\n    if (this.debug) {\n      const boundVao = this.getVertexArray();\n      console.assert(boundVao === this.program.vao, 'VAO changed between setProgram and executeProgram!');\n      this.debugValidate();\n    }\n    webgl_util.callAndCheck(gl, () => gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0));\n  }\n  blockUntilAllProgramsCompleted() {\n    this.throwIfDisposed();\n    webgl_util.callAndCheck(this.gl, () => this.gl.finish());\n  }\n  getQueryTimerExtension() {\n    if (this.disjointQueryTimerExtension == null) {\n      this.disjointQueryTimerExtension = webgl_util.getExtensionOrThrow(this.gl, env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2 ? 'EXT_disjoint_timer_query_webgl2' : 'EXT_disjoint_timer_query');\n    }\n    return this.disjointQueryTimerExtension;\n  }\n  getQueryTimerExtensionWebGL2() {\n    return this.getQueryTimerExtension();\n  }\n  getQueryTimerExtensionWebGL1() {\n    return this.getQueryTimerExtension();\n  }\n  beginQuery() {\n    if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2) {\n      const gl2 = this.gl;\n      const ext = this.getQueryTimerExtensionWebGL2();\n      const query = gl2.createQuery();\n      gl2.beginQuery(ext.TIME_ELAPSED_EXT, query);\n      return query;\n    }\n    const ext = this.getQueryTimerExtensionWebGL1();\n    const query = ext.createQueryEXT();\n    ext.beginQueryEXT(ext.TIME_ELAPSED_EXT, query);\n    return query;\n  }\n  endQuery() {\n    if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2) {\n      const gl2 = this.gl;\n      const ext = this.getQueryTimerExtensionWebGL2();\n      gl2.endQuery(ext.TIME_ELAPSED_EXT);\n      return;\n    }\n    const ext = this.getQueryTimerExtensionWebGL1();\n    ext.endQueryEXT(ext.TIME_ELAPSED_EXT);\n  }\n  async waitForQueryAndGetTime(query) {\n    await util.repeatedTry(() => this.disposed ||\n    // while testing contexts are created / disposed\n    // in rapid succession, so without this check we\n    // may poll for the query timer indefinitely\n    this.isQueryAvailable(query, env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION')));\n    return this.getQueryTime(query, env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION'));\n  }\n  getQueryTime(query, queryTimerVersion) {\n    if (queryTimerVersion === 0) {\n      return null;\n    }\n    if (queryTimerVersion === 2) {\n      const gl2 = this.gl;\n      const timeElapsedNanos = gl2.getQueryParameter(query, gl2.QUERY_RESULT);\n      // Return milliseconds.\n      return timeElapsedNanos / 1000000;\n    } else {\n      const ext = this.getQueryTimerExtensionWebGL1();\n      const timeElapsedNanos = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_EXT);\n      // Return milliseconds.\n      return timeElapsedNanos / 1000000;\n    }\n  }\n  isQueryAvailable(query, queryTimerVersion) {\n    if (queryTimerVersion === 0) {\n      return true;\n    }\n    if (queryTimerVersion === 2) {\n      const gl2 = this.gl;\n      const ext = this.getQueryTimerExtensionWebGL2();\n      const available = gl2.getQueryParameter(query, gl2.QUERY_RESULT_AVAILABLE);\n      if (this.disjoint == null) {\n        this.disjoint = this.gl.getParameter(ext.GPU_DISJOINT_EXT);\n      }\n      return available && !this.disjoint;\n    } else {\n      const ext = this.getQueryTimerExtensionWebGL1();\n      const available = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_AVAILABLE_EXT);\n      if (this.disjoint == null) {\n        this.disjoint = this.gl.getParameter(ext.GPU_DISJOINT_EXT);\n      }\n      return available && !this.disjoint;\n    }\n  }\n  pollFence(fenceContext) {\n    return new Promise(resolve => {\n      this.addItemToPoll(() => fenceContext.isFencePassed(), () => resolve());\n    });\n  }\n  pollItems() {\n    // Find the last query that has finished.\n    const index = linearSearchLastTrue(this.itemsToPoll.map(x => x.isDoneFn));\n    for (let i = 0; i <= index; ++i) {\n      const {\n        resolveFn\n      } = this.itemsToPoll[i];\n      resolveFn();\n    }\n    this.itemsToPoll = this.itemsToPoll.slice(index + 1);\n  }\n  addItemToPoll(isDoneFn, resolveFn) {\n    this.itemsToPoll.push({\n      isDoneFn,\n      resolveFn\n    });\n    if (this.itemsToPoll.length > 1) {\n      // We already have a running loop that polls.\n      return;\n    }\n    // Start a new loop that polls.\n    let scheduleFn = undefined;\n    if ('setTimeoutCustom' in env().platform) {\n      scheduleFn = env().platform.setTimeoutCustom.bind(env().platform);\n    }\n    util.repeatedTry(() => {\n      this.pollItems();\n      // End the loop if no more items to poll.\n      return this.itemsToPoll.length === 0;\n    }, () => 0, null, scheduleFn);\n  }\n  bindTextureToFrameBuffer(texture) {\n    this.throwIfDisposed();\n    webgl_util.bindColorTextureToFramebuffer(this.gl, texture, this.framebuffer);\n    if (this.debug) {\n      webgl_util.validateFramebuffer(this.gl);\n    }\n  }\n  unbindTextureToFrameBuffer() {\n    if (this.outputTexture != null) {\n      webgl_util.bindColorTextureToFramebuffer(this.gl, this.outputTexture, this.framebuffer);\n      if (this.debug) {\n        webgl_util.validateFramebuffer(this.gl);\n      }\n    } else {\n      webgl_util.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);\n    }\n  }\n  downloadMatrixDriver(texture, downloadAndDecode) {\n    this.bindTextureToFrameBuffer(texture);\n    const result = downloadAndDecode();\n    this.unbindTextureToFrameBuffer();\n    return result;\n  }\n  setOutputMatrixTextureDriver(outputMatrixTextureMaybePacked, width, height) {\n    this.throwIfDisposed();\n    const gl = this.gl;\n    webgl_util.bindColorTextureToFramebuffer(gl, outputMatrixTextureMaybePacked, this.framebuffer);\n    if (this.debug) {\n      webgl_util.validateFramebuffer(gl);\n    }\n    this.outputTexture = outputMatrixTextureMaybePacked;\n    webgl_util.callAndCheck(gl, () => gl.viewport(0, 0, width, height));\n    webgl_util.callAndCheck(gl, () => gl.scissor(0, 0, width, height));\n  }\n  setOutputMatrixWriteRegionDriver(x, y, width, height) {\n    this.throwIfDisposed();\n    webgl_util.callAndCheck(this.gl, () => this.gl.scissor(x, y, width, height));\n  }\n  throwIfDisposed() {\n    if (this.disposed) {\n      throw new Error('Attempted to use disposed GPGPUContext.');\n    }\n  }\n  throwIfNoProgram() {\n    if (this.program == null) {\n      throw new Error('No GPU program is currently set.');\n    }\n  }\n}\n/**\n * Finds the index of the last true element using linear search.\n * Note: We can't do binary search because Chrome expects us to explicitly\n * test all fences before download:\n * https://github.com/tensorflow/tfjs/issues/1145\n */\nexport function linearSearchLastTrue(arr) {\n  let i = 0;\n  for (; i < arr.length; ++i) {\n    const isDone = arr[i]();\n    if (!isDone) {\n      break;\n    }\n  }\n  return i - 1;\n}","map":{"version":3,"names":["env","util","getWebGLContext","setWebGLContext","gpgpu_util","tex_util","webgl_util","GPGPUContext","constructor","gl","outputTexture","program","disposed","itemsToPoll","glVersion","getNumber","gl2","createVertexArray","callAndCheck","bindVertexArray","vao","deleteVertexArray","getVertexArray","getParameter","VERTEX_ARRAY_BINDING","ext","getExtension","Error","createVertexArrayOES","bindVertexArrayOES","deleteVertexArrayOES","VERTEX_ARRAY_BINDING_OES","COLOR_BUFFER_FLOAT","COLOR_BUFFER_HALF_FLOAT","parallelCompilationExtension","TEXTURE_FLOAT","TEXTURE_HALF_FLOAT","textureFloatExtension","getExtensionOrThrow","hasExtension","textureHalfFloatExtension","get","colorBufferFloatExtension","colorBufferHalfFloatExtension","vertexBuffer","createVertexBuffer","indexBuffer","createIndexBuffer","framebuffer","createFramebuffer","textureConfig","getTextureConfig","debug","getBool","dispose","console","warn","finish","bindFramebuffer","FRAMEBUFFER","deleteFramebuffer","bindBuffer","ARRAY_BUFFER","ELEMENT_ARRAY_BUFFER","deleteBuffer","createFloat32MatrixTexture","rows","columns","throwIfDisposed","createFloat16MatrixTexture","createUnsignedBytesMatrixTexture","uploadPixelDataToTexture","texture","pixels","uploadDenseMatrixToTexture","width","height","data","createFloat16PackedMatrixTexture","createPackedMatrixTexture","deleteMatrixTexture","unbindColorTextureFromFramebuffer","deleteTexture","downloadByteEncodedFloatMatrixFromOutputTexture","downloadMatrixDriver","downloadPackedMatrixFromBuffer","buffer","batch","physicalRows","physicalCols","downloadFloat32MatrixFromBuffer","size","createBufferFromTexture","bindTextureToFrameBuffer","result","createBufferFromOutputTexture","unbindTextureToFrameBuffer","createAndWaitForFence","fenceContext","createFence","pollFence","query","isFencePassed","sync","fenceSync","SYNC_GPU_COMMANDS_COMPLETE","flush","status","clientWaitSync","ALREADY_SIGNALED","CONDITION_SATISFIED","beginQuery","endQuery","isQueryAvailable","downloadMatrixFromPackedTexture","downloadMatrixFromPackedOutputTexture","createProgram","fragmentShader","vertexShader","createVertexShader","attachShader","linkProgram","program2","Object","assign","validateProgram","buildVao","setProgram","bindVertexProgramAttributeStreams","deleteProgram","useProgram","getUniformLocation","uniformName","shouldThrow","getProgramUniformLocationOrThrow","getProgramUniformLocation","getAttributeLocation","attribute","getAttribLocation","getUniformLocationNoThrow","setInputMatrixTexture","inputMatrixTexture","uniformLocation","textureUnit","throwIfNoProgram","bindTextureToProgramUniformSampler","setOutputMatrixTexture","outputMatrixTexture","setOutputMatrixTextureDriver","setOutputPackedMatrixTexture","outputPackedMatrixTexture","getPackedMatrixTextureShapeWidthHeight","setOutputMatrixWriteRegion","startRow","numRows","startColumn","numColumns","setOutputMatrixWriteRegionDriver","setOutputPackedMatrixWriteRegion","debugValidate","validateFramebuffer","executeProgram","boundVao","assert","drawElements","TRIANGLES","UNSIGNED_SHORT","blockUntilAllProgramsCompleted","getQueryTimerExtension","disjointQueryTimerExtension","getQueryTimerExtensionWebGL2","getQueryTimerExtensionWebGL1","createQuery","TIME_ELAPSED_EXT","createQueryEXT","beginQueryEXT","endQueryEXT","waitForQueryAndGetTime","repeatedTry","getQueryTime","queryTimerVersion","timeElapsedNanos","getQueryParameter","QUERY_RESULT","getQueryObjectEXT","QUERY_RESULT_EXT","available","QUERY_RESULT_AVAILABLE","disjoint","GPU_DISJOINT_EXT","QUERY_RESULT_AVAILABLE_EXT","Promise","resolve","addItemToPoll","pollItems","index","linearSearchLastTrue","map","x","isDoneFn","i","resolveFn","slice","push","length","scheduleFn","undefined","platform","setTimeoutCustom","bind","bindColorTextureToFramebuffer","downloadAndDecode","outputMatrixTextureMaybePacked","viewport","scissor","y","arr","isDone"],"sources":["/Users/jonchen/Documents/HackPSU/tfjs-backend-webgl/src/gpgpu_context.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env, PixelData, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {getWebGLContext, setWebGLContext} from './canvas_util';\nimport * as gpgpu_util from './gpgpu_util';\nimport * as tex_util from './tex_util';\nimport {Texture, TextureConfig} from './tex_util';\nimport {WebGL1DisjointQueryTimerExtension, WebGL2DisjointQueryTimerExtension, WebGLParallelCompilationExtension} from './webgl_types';\nimport * as webgl_util from './webgl_util';\n\nexport interface FenceContext {\n  query: WebGLQuery|WebGLSync;\n  isFencePassed(): boolean;\n}\n\ntype WebGLVao = WebGLVertexArrayObject|WebGLVertexArrayObjectOES;\n\nexport interface GPGPUContextProgram extends WebGLProgram {\n  vao: WebGLVao;\n}\n\nexport class GPGPUContext {\n  gl: WebGLRenderingContext;\n  textureFloatExtension: {};\n  textureHalfFloatExtension: {};\n  colorBufferFloatExtension: {};\n  colorBufferHalfFloatExtension: {};\n  disjointQueryTimerExtension: WebGL2DisjointQueryTimerExtension|\n      WebGL1DisjointQueryTimerExtension;\n  parallelCompilationExtension: WebGLParallelCompilationExtension;\n  vertexBuffer: WebGLBuffer;\n  indexBuffer: WebGLBuffer;\n  framebuffer: WebGLFramebuffer;\n  outputTexture: WebGLTexture|null = null;\n  program: GPGPUContextProgram|null = null;\n  private disposed = false;\n  private disjoint: boolean;\n  private vertexShader: WebGLShader;\n  textureConfig: TextureConfig;\n\n  createVertexArray: () => WebGLVao | null;\n  bindVertexArray: (vao: WebGLVao|null) => void;\n  deleteVertexArray: (vao: WebGLVao|null) => void;\n  getVertexArray: () => WebGLVao | null;\n\n  constructor(gl?: WebGLRenderingContext) {\n    const glVersion = env().getNumber('WEBGL_VERSION');\n    if (gl != null) {\n      this.gl = gl;\n      setWebGLContext(glVersion, gl);\n    } else {\n      this.gl = getWebGLContext(glVersion);\n    }\n    gl = this.gl;\n\n    if (env().getNumber('WEBGL_VERSION') === 2) {\n      const gl2 = gl as WebGL2RenderingContext;\n      this.createVertexArray = () => {\n        return webgl_util.callAndCheck(gl2, () => gl2.createVertexArray());\n      };\n      this.bindVertexArray = (vao: WebGLVao|null) => {\n        return webgl_util.callAndCheck(\n            gl2, () => gl2.bindVertexArray(vao as WebGLVertexArrayObject));\n      };\n      this.deleteVertexArray = (vao: WebGLVao|null) => {\n        return webgl_util.callAndCheck(\n            gl2, () => gl2.deleteVertexArray(vao as WebGLVertexArrayObject));\n      };\n      this.getVertexArray = () => {\n        return webgl_util.callAndCheck(\n            gl2, () => gl2.getParameter(gl2.VERTEX_ARRAY_BINDING));\n      };\n    } else if (gl != null) {\n      const ext = gl.getExtension('OES_vertex_array_object');\n      if (ext == null) {\n        throw new Error(\n            'All WebGL1 implementations are expected to offer' +\n            ' OES_vertex_array_object.');\n      }\n      this.createVertexArray = () => {\n        return webgl_util.callAndCheck(gl, () => ext.createVertexArrayOES());\n      };\n      this.bindVertexArray = (vao: WebGLVao|null) => {\n        return webgl_util.callAndCheck(\n            gl, () => ext.bindVertexArrayOES(vao as WebGLVertexArrayObjectOES));\n      };\n      this.deleteVertexArray = (vao: WebGLVao|null) => {\n        return webgl_util.callAndCheck(\n            gl,\n            () => ext.deleteVertexArrayOES(vao as WebGLVertexArrayObjectOES));\n      };\n      this.getVertexArray = () => {\n        return webgl_util.callAndCheck(\n            gl, () => gl.getParameter(ext.VERTEX_ARRAY_BINDING_OES));\n      };\n    }\n\n    // WebGL 2.0 enables texture floats without an extension.\n    let COLOR_BUFFER_FLOAT = 'WEBGL_color_buffer_float';\n    const COLOR_BUFFER_HALF_FLOAT = 'EXT_color_buffer_half_float';\n    this.parallelCompilationExtension =\n        this.gl.getExtension('KHR_parallel_shader_compile');\n    if (env().getNumber('WEBGL_VERSION') === 1) {\n      const TEXTURE_FLOAT = 'OES_texture_float';\n      const TEXTURE_HALF_FLOAT = 'OES_texture_half_float';\n\n      this.textureFloatExtension =\n          webgl_util.getExtensionOrThrow(this.gl, TEXTURE_FLOAT);\n      if (webgl_util.hasExtension(this.gl, TEXTURE_HALF_FLOAT)) {\n        this.textureHalfFloatExtension =\n            webgl_util.getExtensionOrThrow(this.gl, TEXTURE_HALF_FLOAT);\n      } else if (env().get('WEBGL_FORCE_F16_TEXTURES')) {\n        throw new Error(\n            'GL context does not support half float textures, yet the ' +\n            'environment flag WEBGL_FORCE_F16_TEXTURES is set to true.');\n      }\n\n      this.colorBufferFloatExtension = this.gl.getExtension(COLOR_BUFFER_FLOAT);\n      if (webgl_util.hasExtension(this.gl, COLOR_BUFFER_HALF_FLOAT)) {\n        this.colorBufferHalfFloatExtension =\n            webgl_util.getExtensionOrThrow(this.gl, COLOR_BUFFER_HALF_FLOAT);\n      } else if (env().get('WEBGL_FORCE_F16_TEXTURES')) {\n        throw new Error(\n            'GL context does not support color renderable half floats, yet ' +\n            'the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.');\n      }\n    } else {\n      COLOR_BUFFER_FLOAT = 'EXT_color_buffer_float';\n      if (webgl_util.hasExtension(this.gl, COLOR_BUFFER_FLOAT)) {\n        this.colorBufferFloatExtension =\n            this.gl.getExtension(COLOR_BUFFER_FLOAT);\n      } else if (webgl_util.hasExtension(this.gl, COLOR_BUFFER_HALF_FLOAT)) {\n        this.colorBufferHalfFloatExtension =\n            this.gl.getExtension(COLOR_BUFFER_HALF_FLOAT);\n      } else {\n        throw new Error('GL context does not support color renderable floats');\n      }\n    }\n\n    this.vertexBuffer = gpgpu_util.createVertexBuffer(this.gl);\n    this.indexBuffer = gpgpu_util.createIndexBuffer(this.gl);\n    this.framebuffer = webgl_util.createFramebuffer(this.gl);\n\n    this.textureConfig =\n        tex_util.getTextureConfig(this.gl, this.textureHalfFloatExtension);\n  }\n\n  private get debug(): boolean {\n    return env().getBool('DEBUG');\n  }\n\n  public dispose() {\n    if (this.disposed) {\n      return;\n    }\n    if (this.program != null) {\n      console.warn(\n          'Disposing a GPGPUContext that still has a bound WebGLProgram.' +\n          ' This is probably a resource leak, delete the program with ' +\n          'GPGPUContext.deleteProgram before disposing.');\n    }\n    if (this.outputTexture != null) {\n      console.warn(\n          'Disposing a GPGPUContext that still has a bound output matrix ' +\n          'texture.  This is probably a resource leak, delete the output ' +\n          'matrix texture with GPGPUContext.deleteMatrixTexture before ' +\n          'disposing.');\n    }\n    const gl = this.gl;\n    webgl_util.callAndCheck(gl, () => gl.finish());\n    webgl_util.callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, null));\n    webgl_util.callAndCheck(gl, () => gl.deleteFramebuffer(this.framebuffer));\n    webgl_util.callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, null));\n    webgl_util.callAndCheck(\n        gl, () => gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null));\n    webgl_util.callAndCheck(gl, () => gl.deleteBuffer(this.indexBuffer));\n    this.disposed = true;\n  }\n\n  public createFloat32MatrixTexture(rows: number, columns: number): Texture {\n    this.throwIfDisposed();\n    return gpgpu_util.createFloat32MatrixTexture(\n        this.gl, rows, columns, this.textureConfig);\n  }\n\n  public createFloat16MatrixTexture(rows: number, columns: number): Texture {\n    this.throwIfDisposed();\n    return gpgpu_util.createFloat16MatrixTexture(\n        this.gl, rows, columns, this.textureConfig);\n  }\n\n  public createUnsignedBytesMatrixTexture(rows: number, columns: number):\n      Texture {\n    this.throwIfDisposed();\n    return gpgpu_util.createUnsignedBytesMatrixTexture(\n        this.gl, rows, columns, this.textureConfig);\n  }\n\n  public uploadPixelDataToTexture(\n      texture: WebGLTexture,\n      pixels: PixelData|ImageData|HTMLImageElement|HTMLCanvasElement|\n      ImageBitmap) {\n    this.throwIfDisposed();\n    gpgpu_util.uploadPixelDataToTexture(this.gl, texture, pixels);\n  }\n\n  public uploadDenseMatrixToTexture(\n      texture: WebGLTexture, width: number, height: number, data: TypedArray) {\n    this.throwIfDisposed();\n    gpgpu_util.uploadDenseMatrixToTexture(\n        this.gl, texture, width, height, data, this.textureConfig);\n  }\n\n  public createFloat16PackedMatrixTexture(rows: number, columns: number):\n      Texture {\n    this.throwIfDisposed();\n    return gpgpu_util.createFloat16PackedMatrixTexture(\n        this.gl, rows, columns, this.textureConfig);\n  }\n\n  public createPackedMatrixTexture(rows: number, columns: number): Texture {\n    this.throwIfDisposed();\n    return gpgpu_util.createPackedMatrixTexture(\n        this.gl, rows, columns, this.textureConfig);\n  }\n\n  public deleteMatrixTexture(texture: WebGLTexture) {\n    this.throwIfDisposed();\n    if (this.outputTexture === texture) {\n      webgl_util.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);\n      this.outputTexture = null;\n    }\n    webgl_util.callAndCheck(this.gl, () => this.gl.deleteTexture(texture));\n  }\n\n  public downloadByteEncodedFloatMatrixFromOutputTexture(\n      texture: WebGLTexture, rows: number, columns: number): Float32Array {\n    return this.downloadMatrixDriver(\n        texture,\n        () => gpgpu_util.downloadByteEncodedFloatMatrixFromOutputTexture(\n            this.gl, rows, columns, this.textureConfig));\n  }\n\n  public downloadPackedMatrixFromBuffer(\n      buffer: WebGLBuffer, batch: number, rows: number, columns: number,\n      physicalRows: number, physicalCols: number): Float32Array {\n    return gpgpu_util.downloadPackedMatrixFromBuffer(\n        this.gl, buffer, batch, rows, columns, physicalRows, physicalCols,\n        this.textureConfig);\n  }\n\n  public downloadFloat32MatrixFromBuffer(buffer: WebGLBuffer, size: number):\n      Float32Array {\n    return gpgpu_util.downloadFloat32MatrixFromBuffer(this.gl, buffer, size);\n  }\n\n  public createBufferFromTexture(\n      texture: WebGLTexture, rows: number, columns: number): WebGLBuffer {\n    this.bindTextureToFrameBuffer(texture);\n    const result = gpgpu_util.createBufferFromOutputTexture(\n        this.gl as WebGL2RenderingContext, rows, columns, this.textureConfig);\n    this.unbindTextureToFrameBuffer();\n    return result;\n  }\n\n  public createAndWaitForFence(): Promise<void> {\n    const fenceContext = this.createFence(this.gl);\n    return this.pollFence(fenceContext);\n  }\n\n  private createFence(gl: WebGLRenderingContext): FenceContext {\n    let query: WebGLQuery|WebGLSync;\n    let isFencePassed: () => boolean;\n\n    if (env().getBool('WEBGL_FENCE_API_ENABLED')) {\n      const gl2 = gl as WebGL2RenderingContext;\n\n      const sync = gl2.fenceSync(gl2.SYNC_GPU_COMMANDS_COMPLETE, 0);\n      gl.flush();\n\n      isFencePassed = () => {\n        const status = gl2.clientWaitSync(sync, 0, 0);\n        return status === gl2.ALREADY_SIGNALED ||\n            status === gl2.CONDITION_SATISFIED;\n      };\n\n      query = sync;\n    } else if (\n        env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') > 0) {\n      query = this.beginQuery();\n      this.endQuery();\n      isFencePassed = () => this.isQueryAvailable(\n          query,\n          env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION'));\n    } else {\n      // If we have no way to fence, return true immediately. This will fire in\n      // WebGL 1.0 when there is no disjoint query timer. In this case, because\n      // the fence passes immediately, we'll immediately ask for a download of\n      // the texture, which will cause the UI thread to hang.\n      isFencePassed = () => true;\n    }\n\n    return {query, isFencePassed};\n  }\n\n  public downloadMatrixFromPackedTexture(\n      texture: WebGLTexture, physicalRows: number,\n      physicalCols: number): Float32Array {\n    return this.downloadMatrixDriver(\n        texture,\n        () => gpgpu_util.downloadMatrixFromPackedOutputTexture(\n            this.gl, physicalRows, physicalCols));\n  }\n\n  public createProgram(fragmentShader: WebGLShader): GPGPUContextProgram {\n    this.throwIfDisposed();\n    const gl = this.gl;\n    if (this.vertexShader == null) {\n      this.vertexShader = gpgpu_util.createVertexShader(gl);\n    }\n    const program: WebGLProgram = webgl_util.createProgram(gl);\n    webgl_util.callAndCheck(\n        gl, () => gl.attachShader(program, this.vertexShader));\n    webgl_util.callAndCheck(gl, () => gl.attachShader(program, fragmentShader));\n    webgl_util.linkProgram(gl, program);\n\n    const program2 = Object.assign(program, {vao: this.createVertexArray()});\n    if (this.debug) {\n      webgl_util.validateProgram(gl, program2);\n    }\n    return program2;\n  }\n\n  public buildVao(program: GPGPUContextProgram) {\n    this.setProgram(program);\n    this.bindVertexArray(program.vao);\n    const gl = this.gl;\n    // Bind index buffer, and vertex buffers based on program attrib\n    // locations.\n    webgl_util.callAndCheck(\n        gl, () => gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer));\n    gpgpu_util.bindVertexProgramAttributeStreams(\n        gl, program, this.vertexBuffer);\n  }\n\n  public deleteProgram(program: GPGPUContextProgram) {\n    this.throwIfDisposed();\n    if (program === this.program) {\n      this.program = null;\n    }\n    if (program != null) {\n      webgl_util.callAndCheck(this.gl, () => this.gl.deleteProgram(program));\n      this.deleteVertexArray(program.vao);\n    }\n  }\n\n  public setProgram(program: GPGPUContextProgram|null) {\n    this.throwIfDisposed();\n    this.program = program;\n\n    if (this.program != null) {\n      if (this.debug) {\n        webgl_util.validateProgram(this.gl, this.program);\n      }\n    }\n    webgl_util.callAndCheck(this.gl, () => this.gl.useProgram(program));\n  }\n\n  public getUniformLocation(\n      program: WebGLProgram, uniformName: string,\n      shouldThrow = true): WebGLUniformLocation {\n    this.throwIfDisposed();\n    if (shouldThrow) {\n      return webgl_util.getProgramUniformLocationOrThrow(\n          this.gl, program, uniformName);\n    } else {\n      return webgl_util.getProgramUniformLocation(\n          this.gl, program, uniformName);\n    }\n  }\n\n  public getAttributeLocation(program: WebGLProgram, attribute: string):\n      number {\n    this.throwIfDisposed();\n    return webgl_util.callAndCheck(\n        this.gl, () => this.gl.getAttribLocation(program, attribute));\n  }\n\n  public getUniformLocationNoThrow(program: WebGLProgram, uniformName: string):\n      WebGLUniformLocation {\n    this.throwIfDisposed();\n    return this.gl.getUniformLocation(program, uniformName);\n  }\n\n  public setInputMatrixTexture(\n      inputMatrixTexture: WebGLTexture, uniformLocation: WebGLUniformLocation,\n      textureUnit: number) {\n    this.throwIfDisposed();\n    this.throwIfNoProgram();\n    webgl_util.bindTextureToProgramUniformSampler(\n        this.gl, inputMatrixTexture, uniformLocation, textureUnit);\n  }\n\n  public setOutputMatrixTexture(\n      outputMatrixTexture: WebGLTexture, rows: number, columns: number) {\n    this.setOutputMatrixTextureDriver(outputMatrixTexture, columns, rows);\n  }\n\n  public setOutputPackedMatrixTexture(\n      outputPackedMatrixTexture: WebGLTexture, rows: number, columns: number) {\n    this.throwIfDisposed();\n    const [width, height] =\n        tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns);\n    this.setOutputMatrixTextureDriver(outputPackedMatrixTexture, width, height);\n  }\n\n  public setOutputMatrixWriteRegion(\n      startRow: number, numRows: number, startColumn: number,\n      numColumns: number) {\n    this.setOutputMatrixWriteRegionDriver(\n        startColumn, startRow, numColumns, numRows);\n  }\n\n  public setOutputPackedMatrixWriteRegion(\n      startRow: number, numRows: number, startColumn: number,\n      numColumns: number) {\n    throw new Error('setOutputPackedMatrixWriteRegion not implemented.');\n  }\n\n  public debugValidate() {\n    if (this.program != null) {\n      webgl_util.validateProgram(this.gl, this.program);\n    }\n    webgl_util.validateFramebuffer(this.gl);\n  }\n\n  public executeProgram() {\n    this.throwIfDisposed();\n    this.throwIfNoProgram();\n    const gl = this.gl;\n    if (this.debug) {\n      const boundVao = this.getVertexArray();\n      console.assert(\n          boundVao === this.program.vao,\n          'VAO changed between setProgram and executeProgram!');\n\n      this.debugValidate();\n    }\n    webgl_util.callAndCheck(\n        gl, () => gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0));\n  }\n\n  public blockUntilAllProgramsCompleted() {\n    this.throwIfDisposed();\n    webgl_util.callAndCheck(this.gl, () => this.gl.finish());\n  }\n\n  private getQueryTimerExtension(): WebGL1DisjointQueryTimerExtension\n      |WebGL2DisjointQueryTimerExtension {\n    if (this.disjointQueryTimerExtension == null) {\n      this.disjointQueryTimerExtension =\n          webgl_util.getExtensionOrThrow(\n              this.gl,\n              env().getNumber(\n                  'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2 ?\n                  'EXT_disjoint_timer_query_webgl2' :\n                  'EXT_disjoint_timer_query') as\n              WebGL1DisjointQueryTimerExtension |\n          WebGL2DisjointQueryTimerExtension;\n    }\n    return this.disjointQueryTimerExtension;\n  }\n\n  private getQueryTimerExtensionWebGL2(): WebGL2DisjointQueryTimerExtension {\n    return this.getQueryTimerExtension();\n  }\n\n  private getQueryTimerExtensionWebGL1(): WebGL1DisjointQueryTimerExtension {\n    return this.getQueryTimerExtension() as WebGL1DisjointQueryTimerExtension;\n  }\n\n  beginQuery(): WebGLQuery {\n    if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2) {\n      const gl2 = this.gl as WebGL2RenderingContext;\n      const ext = this.getQueryTimerExtensionWebGL2();\n\n      const query = gl2.createQuery();\n      gl2.beginQuery(ext.TIME_ELAPSED_EXT, query);\n      return query;\n    }\n    const ext = this.getQueryTimerExtensionWebGL1();\n    const query = ext.createQueryEXT() as WebGLQuery;\n    ext.beginQueryEXT(ext.TIME_ELAPSED_EXT, query);\n    return query;\n  }\n\n  endQuery() {\n    if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2) {\n      const gl2 = this.gl as WebGL2RenderingContext;\n      const ext = this.getQueryTimerExtensionWebGL2();\n      gl2.endQuery(ext.TIME_ELAPSED_EXT);\n      return;\n    }\n    const ext = this.getQueryTimerExtensionWebGL1();\n    ext.endQueryEXT(ext.TIME_ELAPSED_EXT);\n  }\n\n  public async waitForQueryAndGetTime(query: WebGLQuery): Promise<number> {\n    await util.repeatedTry(\n        () => this.disposed ||  // while testing contexts are created / disposed\n                                // in rapid succession, so without this check we\n                                // may poll for the query timer indefinitely\n            this.isQueryAvailable(\n                query,\n                env().getNumber(\n                    'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION')));\n    return this.getQueryTime(\n        query, env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION'));\n  }\n\n  private getQueryTime(query: WebGLQuery, queryTimerVersion: number): number {\n    if (queryTimerVersion === 0) {\n      return null;\n    }\n\n    if (queryTimerVersion === 2) {\n      const gl2 = this.gl as WebGL2RenderingContext;\n\n      const timeElapsedNanos = gl2.getQueryParameter(query, gl2.QUERY_RESULT);\n      // Return milliseconds.\n      return timeElapsedNanos / 1000000;\n    } else {\n      const ext = this.getQueryTimerExtensionWebGL1();\n\n      const timeElapsedNanos =\n          ext.getQueryObjectEXT(query, ext.QUERY_RESULT_EXT);\n      // Return milliseconds.\n      return timeElapsedNanos / 1000000;\n    }\n  }\n\n  private isQueryAvailable(query: WebGLQuery, queryTimerVersion: number):\n      boolean {\n    if (queryTimerVersion === 0) {\n      return true;\n    }\n\n    if (queryTimerVersion === 2) {\n      const gl2 = this.gl as WebGL2RenderingContext;\n      const ext = this.getQueryTimerExtensionWebGL2();\n\n      const available =\n          gl2.getQueryParameter(query, gl2.QUERY_RESULT_AVAILABLE);\n      if (this.disjoint == null) {\n        this.disjoint = this.gl.getParameter(ext.GPU_DISJOINT_EXT);\n      }\n\n      return available && !this.disjoint;\n    } else {\n      const ext = this.getQueryTimerExtensionWebGL1();\n\n      const available =\n          ext.getQueryObjectEXT(query, ext.QUERY_RESULT_AVAILABLE_EXT);\n      if (this.disjoint == null) {\n        this.disjoint = this.gl.getParameter(ext.GPU_DISJOINT_EXT);\n      }\n\n      return available && !this.disjoint;\n    }\n  }\n\n  pollFence(fenceContext: FenceContext) {\n    return new Promise<void>(resolve => {\n      this.addItemToPoll(() => fenceContext.isFencePassed(), () => resolve());\n    });\n  }\n\n  private itemsToPoll: PollItem[] = [];\n\n  pollItems(): void {\n    // Find the last query that has finished.\n    const index = linearSearchLastTrue(this.itemsToPoll.map(x => x.isDoneFn));\n    for (let i = 0; i <= index; ++i) {\n      const {resolveFn} = this.itemsToPoll[i];\n      resolveFn();\n    }\n    this.itemsToPoll = this.itemsToPoll.slice(index + 1);\n  }\n\n  private addItemToPoll(isDoneFn: () => boolean, resolveFn: () => void) {\n    this.itemsToPoll.push({isDoneFn, resolveFn});\n    if (this.itemsToPoll.length > 1) {\n      // We already have a running loop that polls.\n      return;\n    }\n    // Start a new loop that polls.\n    let scheduleFn = undefined;\n    if ('setTimeoutCustom' in env().platform) {\n      scheduleFn = env().platform.setTimeoutCustom.bind(env().platform);\n    }\n    util.repeatedTry(() => {\n      this.pollItems();\n      // End the loop if no more items to poll.\n      return this.itemsToPoll.length === 0;\n    }, () => 0, null, scheduleFn);\n  }\n\n  private bindTextureToFrameBuffer(texture: WebGLTexture) {\n    this.throwIfDisposed();\n    webgl_util.bindColorTextureToFramebuffer(\n        this.gl, texture, this.framebuffer);\n    if (this.debug) {\n      webgl_util.validateFramebuffer(this.gl);\n    }\n  }\n\n  private unbindTextureToFrameBuffer() {\n    if (this.outputTexture != null) {\n      webgl_util.bindColorTextureToFramebuffer(\n          this.gl, this.outputTexture, this.framebuffer);\n      if (this.debug) {\n        webgl_util.validateFramebuffer(this.gl);\n      }\n    } else {\n      webgl_util.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);\n    }\n  }\n\n  private downloadMatrixDriver(\n      texture: WebGLTexture,\n      downloadAndDecode: () => Float32Array): Float32Array {\n    this.bindTextureToFrameBuffer(texture);\n    const result = downloadAndDecode();\n    this.unbindTextureToFrameBuffer();\n\n    return result;\n  }\n\n  private setOutputMatrixTextureDriver(\n      outputMatrixTextureMaybePacked: WebGLTexture, width: number,\n      height: number) {\n    this.throwIfDisposed();\n    const gl = this.gl;\n    webgl_util.bindColorTextureToFramebuffer(\n        gl, outputMatrixTextureMaybePacked, this.framebuffer);\n    if (this.debug) {\n      webgl_util.validateFramebuffer(gl);\n    }\n    this.outputTexture = outputMatrixTextureMaybePacked;\n    webgl_util.callAndCheck(gl, () => gl.viewport(0, 0, width, height));\n    webgl_util.callAndCheck(gl, () => gl.scissor(0, 0, width, height));\n  }\n\n  private setOutputMatrixWriteRegionDriver(\n      x: number, y: number, width: number, height: number) {\n    this.throwIfDisposed();\n    webgl_util.callAndCheck(\n        this.gl, () => this.gl.scissor(x, y, width, height));\n  }\n\n  private throwIfDisposed() {\n    if (this.disposed) {\n      throw new Error('Attempted to use disposed GPGPUContext.');\n    }\n  }\n\n  private throwIfNoProgram() {\n    if (this.program == null) {\n      throw new Error('No GPU program is currently set.');\n    }\n  }\n}\n\ntype PollItem = {\n  isDoneFn: () => boolean,\n  resolveFn: () => void\n};\n\n/**\n * Finds the index of the last true element using linear search.\n * Note: We can't do binary search because Chrome expects us to explicitly\n * test all fences before download:\n * https://github.com/tensorflow/tfjs/issues/1145\n */\nexport function linearSearchLastTrue(arr: Array<() => boolean>): number {\n  let i = 0;\n  for (; i < arr.length; ++i) {\n    const isDone = arr[i]();\n    if (!isDone) {\n      break;\n    }\n  }\n  return i - 1;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}