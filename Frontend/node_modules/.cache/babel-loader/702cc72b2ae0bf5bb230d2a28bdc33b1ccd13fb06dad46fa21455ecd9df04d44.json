{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { isWebGLData, isWebGPUData } from '../types';\nimport { assert, assertNonNegativeIntegerDimensions, flatten, inferDtype, isTypedArray, sizeFromShape, toTypedArray } from '../util';\n/** This is shared code across all tensor creation methods. */\nexport function makeTensor(values, shape, inferredShape, dtype) {\n  if (dtype == null) {\n    dtype = inferDtype(values);\n  } else if (dtype === 'complex64') {\n    throw new Error(`Cannot construct a complex64 tensor directly. ` + `Please use tf.complex(real, imag).`);\n  }\n  if (isWebGPUData(values) || isWebGLData(values)) {\n    if (dtype !== 'float32' && dtype !== 'int32') {\n      throw new Error(`Creating tensor from GPU data only supports ` + `'float32'|'int32' dtype, while the dtype is ${dtype}.`);\n    }\n    return ENGINE.backend.createTensorFromGPUData(values, shape || inferredShape, dtype);\n  }\n  if (!isTypedArray(values) && !Array.isArray(values) && typeof values !== 'number' && typeof values !== 'boolean' && typeof values !== 'string') {\n    throw new Error('values passed to tensor(values) must be a number/boolean/string or ' + 'an array of numbers/booleans/strings, or a TypedArray');\n  }\n  // Verify that the shape matches the inferred shape.\n  if (shape != null) {\n    assertNonNegativeIntegerDimensions(shape);\n    const providedSize = sizeFromShape(shape);\n    const inferredSize = sizeFromShape(inferredShape);\n    assert(providedSize === inferredSize, () => `Based on the provided shape, [${shape}], the tensor should have ` + `${providedSize} values but has ${inferredSize}`);\n    for (let i = 0; i < inferredShape.length; ++i) {\n      const inferred = inferredShape[i];\n      const flatDimsDontMatch = i === inferredShape.length - 1 ? inferred !== sizeFromShape(shape.slice(i)) : true;\n      assert(inferredShape[i] === shape[i] || !flatDimsDontMatch, () => `Error creating a new Tensor. Inferred shape ` + `(${inferredShape}) does not match the provided ` + `shape (${shape}). `);\n    }\n  }\n  if (!isTypedArray(values) && !Array.isArray(values)) {\n    values = [values];\n  }\n  shape = shape || inferredShape;\n  values = dtype !== 'string' ? toTypedArray(values, dtype) : flatten(values, [], true);\n  return ENGINE.makeTensor(values, shape, dtype);\n}","map":{"version":3,"names":["ENGINE","isWebGLData","isWebGPUData","assert","assertNonNegativeIntegerDimensions","flatten","inferDtype","isTypedArray","sizeFromShape","toTypedArray","makeTensor","values","shape","inferredShape","dtype","Error","backend","createTensorFromGPUData","Array","isArray","providedSize","inferredSize","i","length","inferred","flatDimsDontMatch","slice"],"sources":["/Users/jonchen/Documents/HackPSU/tfjs-core/src/ops/tensor_ops_util.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Tensor} from '../tensor';\nimport {isWebGLData, isWebGPUData, TensorLike, TypedArray, WebGLData, WebGPUData} from '../types';\nimport {DataType} from '../types';\nimport {assert, assertNonNegativeIntegerDimensions, flatten, inferDtype, isTypedArray, sizeFromShape, toTypedArray} from '../util';\n\n/** This is shared code across all tensor creation methods. */\nexport function makeTensor(\n    values: TensorLike|WebGLData|WebGPUData, shape: number[],\n    inferredShape: number[], dtype?: DataType): Tensor {\n  if (dtype == null) {\n    dtype = inferDtype(values);\n  } else if (dtype === 'complex64') {\n    throw new Error(\n        `Cannot construct a complex64 tensor directly. ` +\n        `Please use tf.complex(real, imag).`);\n  }\n\n  if (isWebGPUData(values) || isWebGLData(values)) {\n    if (dtype !== 'float32' && dtype !== 'int32') {\n      throw new Error(\n          `Creating tensor from GPU data only supports ` +\n          `'float32'|'int32' dtype, while the dtype is ${dtype}.`);\n    }\n    return ENGINE.backend.createTensorFromGPUData(\n        values, shape || inferredShape, dtype);\n  }\n\n  if (!isTypedArray(values) && !Array.isArray(values) &&\n      typeof values !== 'number' && typeof values !== 'boolean' &&\n      typeof values !== 'string') {\n    throw new Error(\n        'values passed to tensor(values) must be a number/boolean/string or ' +\n        'an array of numbers/booleans/strings, or a TypedArray');\n  }\n  // Verify that the shape matches the inferred shape.\n  if (shape != null) {\n    assertNonNegativeIntegerDimensions(shape);\n\n    const providedSize = sizeFromShape(shape);\n    const inferredSize = sizeFromShape(inferredShape);\n    assert(\n        providedSize === inferredSize,\n        () =>\n            `Based on the provided shape, [${shape}], the tensor should have ` +\n            `${providedSize} values but has ${inferredSize}`);\n\n    for (let i = 0; i < inferredShape.length; ++i) {\n      const inferred = inferredShape[i];\n      const flatDimsDontMatch = i === inferredShape.length - 1 ?\n          inferred !== sizeFromShape(shape.slice(i)) :\n          true;\n      assert(\n          inferredShape[i] === shape[i] || !flatDimsDontMatch,\n          () => `Error creating a new Tensor. Inferred shape ` +\n              `(${inferredShape}) does not match the provided ` +\n              `shape (${shape}). `);\n    }\n  }\n\n  if (!isTypedArray(values) && !Array.isArray(values)) {\n    values = [values] as number[];\n  }\n\n  shape = shape || inferredShape;\n  values = dtype !== 'string' ?\n      toTypedArray(values, dtype) :\n      flatten(values as string[], [], true) as string[];\n  return ENGINE.makeTensor(values as TypedArray, shape, dtype);\n}\n"],"mappings":"AAAA;;;;;;;;;;;;;;;;AAiBA,SAAQA,MAAM,QAAO,WAAW;AAEhC,SAAQC,WAAW,EAAEC,YAAY,QAAsD,UAAU;AAEjG,SAAQC,MAAM,EAAEC,kCAAkC,EAAEC,OAAO,EAAEC,UAAU,EAAEC,YAAY,EAAEC,aAAa,EAAEC,YAAY,QAAO,SAAS;AAElI;AACA,OAAM,SAAUC,UAAUA,CACtBC,MAAuC,EAAEC,KAAe,EACxDC,aAAuB,EAAEC,KAAgB;EAC3C,IAAIA,KAAK,IAAI,IAAI,EAAE;IACjBA,KAAK,GAAGR,UAAU,CAACK,MAAM,CAAC;GAC3B,MAAM,IAAIG,KAAK,KAAK,WAAW,EAAE;IAChC,MAAM,IAAIC,KAAK,CACX,gDAAgD,GAChD,oCAAoC,CAAC;;EAG3C,IAAIb,YAAY,CAACS,MAAM,CAAC,IAAIV,WAAW,CAACU,MAAM,CAAC,EAAE;IAC/C,IAAIG,KAAK,KAAK,SAAS,IAAIA,KAAK,KAAK,OAAO,EAAE;MAC5C,MAAM,IAAIC,KAAK,CACX,8CAA8C,GAC9C,+CAA+CD,KAAK,GAAG,CAAC;;IAE9D,OAAOd,MAAM,CAACgB,OAAO,CAACC,uBAAuB,CACzCN,MAAM,EAAEC,KAAK,IAAIC,aAAa,EAAEC,KAAK,CAAC;;EAG5C,IAAI,CAACP,YAAY,CAACI,MAAM,CAAC,IAAI,CAACO,KAAK,CAACC,OAAO,CAACR,MAAM,CAAC,IAC/C,OAAOA,MAAM,KAAK,QAAQ,IAAI,OAAOA,MAAM,KAAK,SAAS,IACzD,OAAOA,MAAM,KAAK,QAAQ,EAAE;IAC9B,MAAM,IAAII,KAAK,CACX,qEAAqE,GACrE,uDAAuD,CAAC;;EAE9D;EACA,IAAIH,KAAK,IAAI,IAAI,EAAE;IACjBR,kCAAkC,CAACQ,KAAK,CAAC;IAEzC,MAAMQ,YAAY,GAAGZ,aAAa,CAACI,KAAK,CAAC;IACzC,MAAMS,YAAY,GAAGb,aAAa,CAACK,aAAa,CAAC;IACjDV,MAAM,CACFiB,YAAY,KAAKC,YAAY,EAC7B,MACI,iCAAiCT,KAAK,4BAA4B,GAClE,GAAGQ,YAAY,mBAAmBC,YAAY,EAAE,CAAC;IAEzD,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGT,aAAa,CAACU,MAAM,EAAE,EAAED,CAAC,EAAE;MAC7C,MAAME,QAAQ,GAAGX,aAAa,CAACS,CAAC,CAAC;MACjC,MAAMG,iBAAiB,GAAGH,CAAC,KAAKT,aAAa,CAACU,MAAM,GAAG,CAAC,GACpDC,QAAQ,KAAKhB,aAAa,CAACI,KAAK,CAACc,KAAK,CAACJ,CAAC,CAAC,CAAC,GAC1C,IAAI;MACRnB,MAAM,CACFU,aAAa,CAACS,CAAC,CAAC,KAAKV,KAAK,CAACU,CAAC,CAAC,IAAI,CAACG,iBAAiB,EACnD,MAAM,8CAA8C,GAChD,IAAIZ,aAAa,gCAAgC,GACjD,UAAUD,KAAK,KAAK,CAAC;;;EAIjC,IAAI,CAACL,YAAY,CAACI,MAAM,CAAC,IAAI,CAACO,KAAK,CAACC,OAAO,CAACR,MAAM,CAAC,EAAE;IACnDA,MAAM,GAAG,CAACA,MAAM,CAAa;;EAG/BC,KAAK,GAAGA,KAAK,IAAIC,aAAa;EAC9BF,MAAM,GAAGG,KAAK,KAAK,QAAQ,GACvBL,YAAY,CAACE,MAAM,EAAEG,KAAK,CAAC,GAC3BT,OAAO,CAACM,MAAkB,EAAE,EAAE,EAAE,IAAI,CAAa;EACrD,OAAOX,MAAM,CAACU,UAAU,CAACC,MAAoB,EAAEC,KAAK,EAAEE,KAAK,CAAC;AAC9D","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}