{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, util } from '@tensorflow/tfjs-core';\nimport { useShapeUniforms } from './gpgpu_math';\nimport { getChannels } from './packing_util';\nimport { getCoordsDataType } from './shader_compiler';\nexport const CHECK_NAN_SNIPPET_PACKED = `\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n`;\nexport const ELU_DER = `\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n`;\nexport const NOT_EQUAL = `\n  return vec4(notEqual(a, b));\n`;\nexport class BinaryOpPackedProgram {\n  constructor(op, aShape, bShape, checkOutOfBounds = false) {\n    this.variableNames = ['A', 'B'];\n    this.supportsBroadcasting = true;\n    this.packedInputs = true;\n    this.packedOutput = true;\n    this.outputShape = backend_util.assertAndGetBroadcastShape(aShape, bShape);\n    const rank = this.outputShape.length;\n    this.enableShapeUniforms = useShapeUniforms(rank);\n    let checkOutOfBoundsString = '';\n    if (checkOutOfBounds) {\n      if (rank === 0 || util.sizeFromShape(this.outputShape) === 1) {\n        checkOutOfBoundsString = `\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        `;\n      } else {\n        const dtype = getCoordsDataType(rank);\n        checkOutOfBoundsString = `\n          ${dtype} coords = getOutputCoords();\n        `;\n        if (rank === 1) {\n          if (this.enableShapeUniforms) {\n            checkOutOfBoundsString += `\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;\n          } else {\n            checkOutOfBoundsString += `\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;\n          }\n        } else {\n          const channels = getChannels('coords', rank);\n          if (this.enableShapeUniforms) {\n            checkOutOfBoundsString += `\n            bool nextRowOutOfBounds =\n              (${channels[rank - 2]} + 1) >= outShape[${rank} - 2];\n            bool nextColOutOfBounds =\n              (${channels[rank - 1]} + 1) >= outShape[${rank} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `;\n          } else {\n            checkOutOfBoundsString += `\n            bool nextRowOutOfBounds =\n              (${channels[rank - 2]} + 1) >= ${this.outputShape[rank - 2]};\n            bool nextColOutOfBounds =\n              (${channels[rank - 1]} + 1) >= ${this.outputShape[rank - 1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `;\n          }\n        }\n      }\n    }\n    this.userCode = `\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${op}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${checkOutOfBoundsString}\n\n        setOutput(result);\n      }\n    `;\n  }\n}","map":{"version":3,"names":["backend_util","util","useShapeUniforms","getChannels","getCoordsDataType","CHECK_NAN_SNIPPET_PACKED","ELU_DER","NOT_EQUAL","BinaryOpPackedProgram","constructor","op","aShape","bShape","checkOutOfBounds","variableNames","supportsBroadcasting","packedInputs","packedOutput","outputShape","assertAndGetBroadcastShape","rank","length","enableShapeUniforms","checkOutOfBoundsString","sizeFromShape","dtype","channels","userCode"],"sources":["/Users/jonchen/Documents/HackPSU/tfjs-backend-webgl/src/binaryop_packed_gpu.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, util} from '@tensorflow/tfjs-core';\n\nimport {GPGPUProgram, useShapeUniforms} from './gpgpu_math';\nimport {getChannels} from './packing_util';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport const CHECK_NAN_SNIPPET_PACKED = `\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n`;\n\nexport const ELU_DER = `\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n`;\n\nexport const NOT_EQUAL = `\n  return vec4(notEqual(a, b));\n`;\n\nexport class BinaryOpPackedProgram implements GPGPUProgram {\n  variableNames = ['A', 'B'];\n  outputShape: number[];\n  userCode: string;\n  supportsBroadcasting = true;\n  packedInputs = true;\n  packedOutput = true;\n  enableShapeUniforms: boolean;\n\n  constructor(\n      op: string, aShape: number[], bShape: number[],\n      checkOutOfBounds = false) {\n    this.outputShape = backend_util.assertAndGetBroadcastShape(aShape, bShape);\n    const rank = this.outputShape.length;\n    this.enableShapeUniforms = useShapeUniforms(rank);\n    let checkOutOfBoundsString = '';\n    if (checkOutOfBounds) {\n      if (rank === 0 || util.sizeFromShape(this.outputShape) === 1) {\n        checkOutOfBoundsString = `\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        `;\n      } else {\n        const dtype = getCoordsDataType(rank);\n        checkOutOfBoundsString = `\n          ${dtype} coords = getOutputCoords();\n        `;\n        if (rank === 1) {\n          if (this.enableShapeUniforms) {\n            checkOutOfBoundsString += `\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;\n          } else {\n            checkOutOfBoundsString += `\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;\n          }\n        } else {\n          const channels = getChannels('coords', rank);\n          if (this.enableShapeUniforms) {\n            checkOutOfBoundsString += `\n            bool nextRowOutOfBounds =\n              (${channels[rank - 2]} + 1) >= outShape[${rank} - 2];\n            bool nextColOutOfBounds =\n              (${channels[rank - 1]} + 1) >= outShape[${rank} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `;\n          } else {\n            checkOutOfBoundsString += `\n            bool nextRowOutOfBounds =\n              (${channels[rank - 2]} + 1) >= ${this.outputShape[rank - 2]};\n            bool nextColOutOfBounds =\n              (${channels[rank - 1]} + 1) >= ${this.outputShape[rank - 1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `;\n          }\n        }\n      }\n    }\n\n    this.userCode = `\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${op}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${checkOutOfBoundsString}\n\n        setOutput(result);\n      }\n    `;\n  }\n}\n"],"mappings":"AAAA;;;;;;;;;;;;;;;;AAiBA,SAAQA,YAAY,EAAEC,IAAI,QAAO,uBAAuB;AAExD,SAAsBC,gBAAgB,QAAO,cAAc;AAC3D,SAAQC,WAAW,QAAO,gBAAgB;AAC1C,SAAQC,iBAAiB,QAAO,mBAAmB;AAEnD,OAAO,MAAMC,wBAAwB,GAAG;;;;;CAKvC;AAED,OAAO,MAAMC,OAAO,GAAG;;;CAGtB;AAED,OAAO,MAAMC,SAAS,GAAG;;CAExB;AAED,OAAM,MAAOC,qBAAqB;EAShCC,YACIC,EAAU,EAAEC,MAAgB,EAAEC,MAAgB,EAC9CC,gBAAgB,GAAG,KAAK;IAV5B,KAAAC,aAAa,GAAG,CAAC,GAAG,EAAE,GAAG,CAAC;IAG1B,KAAAC,oBAAoB,GAAG,IAAI;IAC3B,KAAAC,YAAY,GAAG,IAAI;IACnB,KAAAC,YAAY,GAAG,IAAI;IAMjB,IAAI,CAACC,WAAW,GAAGlB,YAAY,CAACmB,0BAA0B,CAACR,MAAM,EAAEC,MAAM,CAAC;IAC1E,MAAMQ,IAAI,GAAG,IAAI,CAACF,WAAW,CAACG,MAAM;IACpC,IAAI,CAACC,mBAAmB,GAAGpB,gBAAgB,CAACkB,IAAI,CAAC;IACjD,IAAIG,sBAAsB,GAAG,EAAE;IAC/B,IAAIV,gBAAgB,EAAE;MACpB,IAAIO,IAAI,KAAK,CAAC,IAAInB,IAAI,CAACuB,aAAa,CAAC,IAAI,CAACN,WAAW,CAAC,KAAK,CAAC,EAAE;QAC5DK,sBAAsB,GAAG;;;;SAIxB;OACF,MAAM;QACL,MAAME,KAAK,GAAGrB,iBAAiB,CAACgB,IAAI,CAAC;QACrCG,sBAAsB,GAAG;YACrBE,KAAK;SACR;QACD,IAAIL,IAAI,KAAK,CAAC,EAAE;UACd,IAAI,IAAI,CAACE,mBAAmB,EAAE;YAC5BC,sBAAsB,IAAI;;;;WAI3B;WACA,MAAM;YACLA,sBAAsB,IAAI;yCACG,IAAI,CAACL,WAAW,CAAC,CAAC,CAAC;;;WAGjD;;SAEF,MAAM;UACL,MAAMQ,QAAQ,GAAGvB,WAAW,CAAC,QAAQ,EAAEiB,IAAI,CAAC;UAC5C,IAAI,IAAI,CAACE,mBAAmB,EAAE;YAC5BC,sBAAsB,IAAI;;iBAErBG,QAAQ,CAACN,IAAI,GAAG,CAAC,CAAC,qBAAqBA,IAAI;;iBAE3CM,QAAQ,CAACN,IAAI,GAAG,CAAC,CAAC,qBAAqBA,IAAI;;;;WAIjD;WACA,MAAM;YACLG,sBAAsB,IAAI;;iBAErBG,QAAQ,CAACN,IAAI,GAAG,CAAC,CAAC,YAAY,IAAI,CAACF,WAAW,CAACE,IAAI,GAAG,CAAC,CAAC;;iBAExDM,QAAQ,CAACN,IAAI,GAAG,CAAC,CAAC,YAAY,IAAI,CAACF,WAAW,CAACE,IAAI,GAAG,CAAC,CAAC;;;;WAI9D;;;;;IAMP,IAAI,CAACO,QAAQ,GAAG;;UAEVjB,EAAE;;;;;;;;UAQFa,sBAAsB;;;;KAI3B;EACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}